{"version":3,"file":"index.es.js","sources":["../src/expect.ts","../../core/util.ts","../../core/logger.ts","../../core/EventEmitter.ts","../../core/errors.ts","../../core/api/parser.ts","../../core/api/mappers/element.ts","../../core/api/mappers/action.ts","../../core/api/mappers/event.ts","../../core/api/mappers/client-socket.ts","../../core/client/client.ts","../../core/waitFor.ts","../../core/config.ts","../../core/client/headful-client.ts","../src/logger.ts","../../core/buffer.ts","../../core/builders/swipe-gesture.ts","../../core/api/mappers/session-socket.ts","../../core/session/session.ts","../src/codegen/pause.ts","../../core/keys.ts","../src/codegen/index.ts","../../core/constants.ts","../src/socket.ts","../src/session.ts","../src/client.ts","../src/appetize-page.ts","../src/device-browser-page.ts","../src/fixture.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-namespace */\nimport { expect } from '@playwright/test';\nimport {\n    Element,\n    ElementSelector,\n    FindElementsAction,\n    PlayActionOptions,\n} from '../../core/api/types/recorder';\nimport { PlaywrightSession } from './session';\n\ndeclare global {\n    namespace PlaywrightTest {\n        interface Matchers<R> {\n            toHaveElement(\n                selector: ElementSelector,\n                options?: ToHaveElementOptions\n            ): Promise<R>;\n        }\n    }\n}\n\ninterface ToHaveElementOptions extends PlayActionOptions<FindElementsAction> {\n    /**\n     * The number of elements for this selector that should be returned\n     */\n    matches?: number;\n}\n\nexpect.extend({\n    toHaveElement: async (\n        session: PlaywrightSession,\n        element: Element,\n        options: ToHaveElementOptions = {}\n    ) => {\n        try {\n            const elements = await session.findElements(element, options);\n\n            const pass =\n                typeof options.matches === 'number'\n                    ? elements.length === options.matches\n                    : elements.length > 0;\n\n            return {\n                pass,\n                message: () =>\n                    `Element not found:\\n${JSON.stringify(element, null, 2)}`,\n            };\n        } catch (e) {\n            return {\n                pass: false,\n                message: () => (e as Error).message,\n            };\n        }\n    },\n});\n","export async function retry<T>(\n    fn: () => T | Promise<T>,\n    {\n        retries = 3,\n        timeout = 1000,\n        predicate = () => true,\n    }: {\n        retries?: number;\n        timeout?: number;\n        predicate?: (e: unknown, attempt: number) => boolean | undefined;\n    }\n): Promise<T> {\n    for (let i = 1; i <= retries; i++) {\n        try {\n            return await fn();\n        } catch (e) {\n            if (i === retries || !predicate(e, i)) {\n                throw e;\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, timeout));\n        }\n    }\n\n    // unreachable, satisifies typescript return type\n    throw null;\n}\n\nexport function clamp(value: number, min: number, max: number) {\n    return Math.min(Math.max(value, min), max);\n}\n\nexport function uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\n\nexport function queryString(params: Record<string, any>) {\n    return Object.entries(params)\n        .map(([key, value]) => {\n            if (typeof value !== 'undefined') {\n                return `${key}=${encodeURIComponent(value)}`;\n            }\n\n            return '';\n        })\n        .join('&');\n}\n\nexport interface DeferredPromise<T> {\n    promise: Promise<T>;\n    resolve: (value: T) => void;\n    reject: (error: any) => void;\n    resolved?: T;\n    rejected?: unknown;\n}\nexport function createDeferredPromise<T = void>(): DeferredPromise<T> {\n    let resolved: T;\n    let rejected: unknown;\n    let resolve: (value: T) => void;\n    let reject: (error: any) => void;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = (value: T) => {\n            resolved = value;\n            res(value);\n        };\n        reject = (err) => {\n            resolved = err;\n            rej(err);\n        };\n    });\n\n    return {\n        promise,\n        resolve: resolve!,\n        reject: reject!,\n        resolved: resolved!,\n        rejected: rejected!,\n    };\n}\n\ntype CleanedObject<T> = {\n    [P in keyof T]: T[P] extends object ? CleanedObject<T[P]> : T[P];\n};\n\n/**\n * Remove undefined and null recursively\n */\nexport function cleanObject<T>(obj: T): CleanedObject<T> {\n    if (Array.isArray(obj)) {\n        return (obj as unknown as any[])\n            .map(cleanObject)\n            .filter(\n                (item) => item !== null && item !== undefined\n            ) as CleanedObject<T>;\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n        return Object.entries(obj).reduce((acc, [key, value]) => {\n            const cleanedValue = cleanObject(value);\n            if (cleanedValue !== null && cleanedValue !== undefined) {\n                acc[key] = cleanedValue;\n            }\n            return acc;\n        }, {} as CleanedObject<T>);\n    }\n\n    return obj as CleanedObject<T>;\n}\n\nexport function parseOsVersion(version: string) {\n    const [major, minor, patch] = version.split('.');\n    return {\n        major: major ? parseInt(major) : 0,\n        minor: minor ? parseInt(minor) : 0,\n        patch: patch ? parseInt(patch) : 0,\n    };\n}\n\ntype UnionKeys<T> = T extends T ? keyof T : never;\ntype StrictUnionHelper<T, TAll> = T extends any\n    ? T & Partial<Record<Exclude<UnionKeys<TAll>, keyof T>, never>>\n    : never;\n\nexport type StrictUnion<T> = StrictUnionHelper<T, T>;\n\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-471566609\nexport type LiteralUnion<T extends U, U = string> =\n    | T\n    | (U & { zz_IGNORE_ME?: never });\n\n/**\n * Omit without breaking union types\n */\nexport type OmitUnion<T, K extends keyof any> = T extends any\n    ? Omit<T, K>\n    : never;\n","export class Logger {\n    log = this.createLogFn('log');\n    warn = this.createLogFn('warn');\n    error = this.createLogFn('error');\n    debug = this.createLogFn('log');\n\n    private createLogFn(type: 'log' | 'warn' | 'error') {\n        const loggedMessages = new Set<string>();\n        const context = '[Appetize]';\n\n        // preserves the original console context\n        const fn: LogFn = Function.prototype.bind.call(\n            console[type],\n            console,\n            context\n        );\n\n        // logs message only once, but we do lose the console context with this implementation\n        fn.once = (msg: string) => {\n            if (loggedMessages.has(msg)) {\n                return;\n            } else {\n                loggedMessages.add(msg);\n            }\n\n            return fn.call(console, msg);\n        };\n\n        return fn;\n    }\n}\n\nexport interface LogFn {\n    (message: string, ...data: any[]): void;\n    once: (message: string, ...data: any[]) => void;\n}\n","import { EventEmitter as BaseEventEmitter } from 'events';\n\nexport class EventEmitter extends BaseEventEmitter {\n    constructor() {\n        super();\n\n        // EventEmitter will throw 'error' events if there are no listeners. We do not\n        // want that behaviuor, so we seutp a no-op listener.\n        this.on('error', () => {});\n    }\n}\n","import { PlayActionErrorResponse } from './api/types/recorder';\n\nexport function captureStackTrace(targetObject, constructorOpt) {\n    if ('captureStackTrace' in Error) {\n        Error.captureStackTrace(targetObject, constructorOpt);\n    } else {\n        // @ts-ignore\n        const container = new Error();\n\n        Object.defineProperty(targetObject, 'stack', {\n            configurable: true,\n            get() {\n                const { stack } = container;\n                Object.defineProperty(this, 'stack', { value: stack });\n                return stack;\n            },\n        });\n    }\n}\n\n/**\n * Captures the stack trace of an operational error so that when the error is logged to the user,\n * the stack points to the given method instead of the method that threw the error.\n *\n * i.e\n *\n * ```bash\n *  TimeoutError: Timed out after 60 seconds waiting for element\n *  await session.tap({ element: { text: 'hello' } });\n *  ^\n * ```\n */\nexport async function captureOperationalError(e: unknown, constructorOpt: any) {\n    if (e instanceof OperationalError) {\n        captureStackTrace(e, constructorOpt);\n    }\n}\n\nexport class OperationalError extends Error {\n    /**\n     * Whether the error is operational or not.\n     * Operational errors are errors that are expected to happen\n     * (such as the failed result of an action playback, or timeout error).\n     */\n    isOperational: boolean;\n\n    constructor(message: string) {\n        super(message);\n        this.name = 'Error';\n        this.isOperational = true;\n        captureStackTrace(this, this.constructor);\n    }\n}\n\nexport class ActionError extends OperationalError {\n    errorId: PlayActionErrorResponse['errorId'];\n    playback: PlayActionErrorResponse['playback'];\n\n    constructor(error: PlayActionErrorResponse, message?: string) {\n        super(message ?? error.message);\n        this.errorId = error.errorId;\n        this.playback = error.playback;\n    }\n}\n\nexport class ActionElementNotFoundError extends ActionError {\n    constructor(error: PlayActionErrorResponse & { errorId: 'notFound' }) {\n        super(\n            error,\n            `No element found for selector\\n${JSON.stringify(\n                error.playback.action.element,\n                null,\n                2\n            )}`\n        );\n    }\n}\n\nexport class ActionAmbiguousElementError extends ActionError {\n    constructor(\n        error: PlayActionErrorResponse & { errorId: 'ambiguousMatch' }\n    ) {\n        super(\n            error,\n            `Action requires 1 unique element but the selector returned ${\n                error.matchedElements.length\n            }. Provide a \\`matchIndex\\` to pick an element below or add additional attributes to your selector.\\n\\n${formatAmbiguousElements(\n                error.matchedElements\n            )}`\n        );\n    }\n}\n\nexport class ActionInvalidArgumentError extends ActionError {\n    constructor(\n        error: PlayActionErrorResponse & { errorId: 'invalidArgument' }\n    ) {\n        let msg = error.message;\n        if (error.message.match('outside the screen bounds')) {\n            const { action } = error.playback;\n            if ('localPosition' in action && action.localPosition) {\n                msg = `localPosition (${action.localPosition.x}, ${action.localPosition.y}) for the element evaluates to a coordinate outside of screen bounds.`;\n            } else {\n                msg = `Element is outside of screen bounds.`;\n            }\n        }\n\n        super(error, msg);\n    }\n}\n\nexport class ActionInternalError extends ActionError {\n    constructor(error: PlayActionErrorResponse & { errorId: 'internalError' }) {\n        super(\n            error,\n            `An internal error has occurred for the action:\\n${JSON.stringify(\n                error.playback.action,\n                null,\n                2\n            )}`\n        );\n    }\n}\n\nexport class TimeoutError extends OperationalError {}\n\nexport class ActionTimeoutError extends OperationalError {\n    playback: PlayActionErrorResponse['playback'];\n\n    constructor(playback: PlayActionErrorResponse['playback'], msg: string) {\n        super(msg);\n        this.playback = playback;\n    }\n}\n\nexport class RecorderRequiredError extends OperationalError {\n    constructor(feature: string) {\n        super(\n            `App Recorder must be enabled to use ${feature}. Please set \"record\" to true in the config.`\n        );\n    }\n}\n\nexport function formatAmbiguousElements(elements: any[]): string {\n    const maxElements = 5;\n    const truncatedElements = elements.slice(0, maxElements);\n    const truncated = elements.length > maxElements;\n\n    const formatted = truncatedElements.map(\n        (e, index) => `// ${index}\\n${JSON.stringify(e, null, 2)}`\n    );\n\n    return `${formatted.join('\\n\\n')}${\n        truncated ? `\\n\\n...and ${elements.length - maxElements} more` : ''\n    }`;\n}\n\n// gets the current line:column from stack trace\nexport function captureLocationFromError(e: Error) {\n    const stack = e.stack;\n    if (!stack) return;\n    const lines = stack.split('\\n');\n    const line = lines[2];\n    const match = line.match(/at (.*)$/);\n    if (!match) return;\n    const location = match[1];\n    return {\n        file: location.split(':')[0],\n        line: location.split(':')[1],\n        column: location.split(':')[2],\n    };\n}\n","import { Coordinates } from './types/recorder';\nimport * as InternalRecorderAPI from './types/recorder/internal';\nimport * as PublicRecorderAPI from './types/recorder/public';\n\nexport class DataValidator {\n    /**\n     * Helper error message to help migrate from old element format to new element format.\n     */\n    static isValidElementSelector(element: PublicRecorderAPI.ElementSelector) {\n        if (typeof element !== 'object' || Array.isArray(element)) {\n            throw new Error('Element must be an object');\n        }\n\n        const rootKeys = Object.keys(element);\n        const knownAttributeFields = [\n            'text',\n            'accessibilityIdentifier',\n            'accessibilityLabel',\n            'resource-id',\n            'content-desc',\n            'class',\n            'baseClass',\n        ];\n\n        const rootAttributes = intersect(rootKeys, knownAttributeFields);\n\n        if (rootAttributes.length > 0) {\n            const list = rootAttributes.map((v) => `'${v}'`).join(', ');\n            throw new Error(\n                `Element has invalid properties: ${list}. Did you mean to put these under 'attributes'?`\n            );\n        }\n\n        return element;\n    }\n\n    static isCoordinatesWithinBounds(\n        coordinates: Coordinates,\n        bounds: { width: number; height: number }\n    ) {\n        if (coordinates.x < 0 || coordinates.x > bounds.width) {\n            return false;\n        }\n\n        if (coordinates.y < 0 || coordinates.y > bounds.height) {\n            return false;\n        }\n\n        return true;\n    }\n\n    static isPositionWithinBounds(\n        position: InternalRecorderAPI.Position | PublicRecorderAPI.Position\n    ) {\n        const x = DataParser.toPositionValue(position.x);\n        const y = DataParser.toPositionValue(position.y);\n\n        if (x < 0 || x > 1) {\n            return false;\n        }\n\n        if (y < 0 || y > 1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    static isValidNumber(value: number) {\n        if (typeof value !== 'number') {\n            return false;\n        }\n\n        if (isNaN(value)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nexport class DataParser {\n    static toBoolean(value: number | null | undefined) {\n        return value === 1 ? true : false;\n    }\n\n    static toNumber(\n        value:\n            | boolean\n            | string\n            | number\n            | InternalRecorderAPI.ObjCNumber\n            | undefined\n    ) {\n        if (typeof value === 'number') {\n            return value;\n        }\n\n        if (typeof value === 'boolean' || value === undefined) {\n            return value ? 1 : 0;\n        }\n\n        // handle obj-c number\n        if (value === 'inf') {\n            return Infinity;\n        } else if (value === '-inf') {\n            return -Infinity;\n        }\n\n        return parseFloat(value);\n    }\n\n    static toObjCNumber(value: number): InternalRecorderAPI.ObjCNumber {\n        if (value === Infinity) {\n            return 'inf';\n        }\n\n        if (value === -Infinity) {\n            return '-inf';\n        }\n\n        return value;\n    }\n\n    /**\n     * If value is a string ending with %, return the value as a number between 0 and 1.\n     *\n     * If value is a number betwen 0 and 1, return the value.\n     */\n    static toPositionValue(value: string | number): number {\n        if (typeof value === 'string') {\n            if (value.endsWith('%')) {\n                return parseInt(value, 10) / 100;\n            } else {\n                throw new Error(\n                    `Invalid position value: ${value}. Must be a number between 0 and 1, or a string ending with %`\n                );\n            }\n        }\n\n        return value;\n    }\n}\n\nfunction intersect(a: any[], b: any[]) {\n    return a.filter((v) => b.includes(v));\n}\n","import { cleanObject } from '../../util';\nimport { DataParser } from '../parser';\nimport { Platform, ScreenBounds } from '../types/recorder/common';\nimport * as InternalRecorderAPI from '../types/recorder/internal';\nimport * as PublicRecorderAPI from '../types/recorder/public';\n\nexport class ElementMapper {\n    platform: Platform;\n    screen: ScreenBounds;\n\n    constructor({\n        platform,\n        screen,\n    }: {\n        platform: Platform;\n        screen: ScreenBounds;\n    }) {\n        this.platform = platform;\n        this.screen = screen;\n    }\n\n    private pixelToDip(value: number) {\n        return value / (this.screen.devicePixelRatio || 1);\n    }\n\n    private dipToPixel(value: number) {\n        return value * (this.screen.devicePixelRatio || 1);\n    }\n\n    toInternal<\n        T extends PublicRecorderAPI.Element | PublicRecorderAPI.ElementSelector\n    >(\n        element: T\n    ): T extends PublicRecorderAPI.Element\n        ? InternalRecorderAPI.Element\n        : InternalRecorderAPI.ElementSelector {\n        const { attributes, bounds, ...rest } = element;\n\n        const mapBounds = () => {\n            if (bounds) {\n                const { x, y, width, height } = bounds;\n                if (this.platform === 'android') {\n                    return {\n                        x: this.dipToPixel(x),\n                        y: this.dipToPixel(y),\n                        width: this.dipToPixel(width),\n                        height: this.dipToPixel(height),\n                    };\n                } else {\n                    return {\n                        x: DataParser.toObjCNumber(x),\n                        y: DataParser.toObjCNumber(y),\n                        width: DataParser.toObjCNumber(width),\n                        height: DataParser.toObjCNumber(height),\n                    };\n                }\n            }\n        };\n\n        const mapAttributes = () => {\n            if (attributes) {\n                return Object.keys(attributes).reduce((acc, key) => {\n                    if (this.platform === 'ios') {\n                        switch (key) {\n                            // convert boolean to '1' or '0'\n                            case 'userInteractionEnabled':\n                            case 'isHidden':\n                                return {\n                                    ...acc,\n                                    [key]: attributes[key]\n                                        ? '1'\n                                        : ('0' as InternalRecorderAPI.BooleanString),\n                                };\n                        }\n                    } else if (this.platform === 'android') {\n                        // nothing yet\n                    }\n\n                    return {\n                        ...acc,\n                        [key]: attributes[key],\n                    };\n                }, {}) as InternalRecorderAPI.Element['attributes'];\n            }\n        };\n\n        return cleanObject({\n            ...rest,\n            bounds: mapBounds(),\n            attributes: mapAttributes(),\n            // internal does not use accessibilityElements for playback, so just remove it\n            accessibilityElements: undefined,\n        }) as T extends PublicRecorderAPI.Element\n            ? InternalRecorderAPI.Element\n            : InternalRecorderAPI.ElementSelector;\n    }\n\n    toPublic<\n        T extends\n            | InternalRecorderAPI.Element\n            | InternalRecorderAPI.ElementSelector\n    >(\n        element: T\n    ): T extends InternalRecorderAPI.Element\n        ? PublicRecorderAPI.Element\n        : PublicRecorderAPI.ElementSelector {\n        const { attributes, bounds, accessibilityElements, ...rest } = element;\n\n        const mapBounds = (bounds: InternalRecorderAPI.ElementBounds) => {\n            if (this.platform === 'android') {\n                return {\n                    x: this.pixelToDip(bounds.x as number),\n                    y: this.pixelToDip(bounds.y as number),\n                    width: this.pixelToDip(bounds.width as number),\n                    height: this.pixelToDip(bounds.height as number),\n                };\n            } else {\n                return {\n                    x: DataParser.toNumber(bounds.x),\n                    y: DataParser.toNumber(bounds.y),\n                    width: DataParser.toNumber(bounds.width),\n                    height: DataParser.toNumber(bounds.height),\n                };\n            }\n        };\n\n        const mapAttributes = (\n            attributes:\n                | InternalRecorderAPI.IOSElementAttributes\n                | InternalRecorderAPI.IOSAccessibilityAttributes\n        ) => {\n            return Object.keys(attributes).reduce((acc, key) => {\n                switch (key) {\n                    // convert boolean to '1' or '0'\n                    case 'userInteractionEnabled':\n                    case 'isHidden':\n                        return {\n                            ...acc,\n                            [key]: attributes[key] === '1' ? true : false,\n                        };\n                    default:\n                        return {\n                            ...acc,\n                            [key]: attributes[key],\n                        };\n                }\n            }, {}) as PublicRecorderAPI.Element['attributes'];\n        };\n\n        const mapAccessibilityElements = (\n            accessibilityElements: InternalRecorderAPI.IOSAccessibilityElement[]\n        ) => {\n            return accessibilityElements.map((accessibilityEl) => {\n                const { accessibilityFrame } = accessibilityEl;\n                return {\n                    ...mapAttributes(accessibilityEl),\n                    accessibilityFrame: accessibilityFrame\n                        ? mapBounds(accessibilityFrame)\n                        : undefined,\n                };\n            });\n        };\n\n        return cleanObject({\n            ...rest,\n            bounds: bounds ? mapBounds(bounds) : undefined,\n            attributes: attributes ? mapAttributes(attributes) : undefined,\n            accessibilityElements: accessibilityElements\n                ? mapAccessibilityElements(accessibilityElements)\n                : undefined,\n        }) as T extends InternalRecorderAPI.Element\n            ? PublicRecorderAPI.Element\n            : PublicRecorderAPI.ElementSelector;\n    }\n}\n\n// prevents accidentally using window.screen that instead of this.screen\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ndeclare let screen: never;\n","import { OperationalError } from '../../errors';\nimport { cleanObject } from '../../util';\nimport { DataParser, DataValidator } from '../parser';\nimport { Coordinates, Platform, ScreenBounds } from '../types/recorder/common';\nimport * as InternalRecorderAPI from '../types/recorder/internal';\nimport * as PublicRecorderAPI from '../types/recorder/public';\n\nimport { ElementMapper } from './element';\n\nexport class ActionMapper {\n    platform: Platform;\n    screen: ScreenBounds;\n\n    elementMapper: ElementMapper;\n    constructor({\n        platform,\n        screen,\n    }: {\n        platform: Platform;\n        screen: ScreenBounds;\n    }) {\n        this.platform = platform;\n        this.screen = screen;\n\n        this.elementMapper = new ElementMapper({\n            platform,\n            screen,\n        });\n    }\n\n    private pixelToDip(value: number) {\n        return value / (this.screen.devicePixelRatio || 1);\n    }\n\n    private dipToPixel(value: number) {\n        return value * (this.screen.devicePixelRatio || 1);\n    }\n\n    private getCoordinates(\n        position: PublicRecorderAPI.Position,\n        bounds: { width: number; height: number }\n    ) {\n        const x = DataParser.toPositionValue(position.x);\n        const y = DataParser.toPositionValue(position.y);\n\n        return {\n            x: x * bounds.width,\n            y: y * bounds.height,\n        };\n    }\n\n    private getPosition(\n        coordinates: Coordinates,\n        bounds: { width: number; height: number }\n    ) {\n        return {\n            x: coordinates.x / bounds.width,\n            y: coordinates.y / bounds.height,\n        };\n    }\n\n    private toInternalKey(value?: string) {\n        switch (value) {\n            case 'HOME':\n                return 'home';\n            case 'VOLUME_UP':\n                return 'volumeUp';\n            case 'VOLUME_DOWN':\n                return 'volumeDown';\n        }\n\n        return value;\n    }\n\n    private toPublicKey(value?: string) {\n        switch (value) {\n            case 'home':\n                return 'HOME';\n            case 'volumeUp':\n                return 'VOLUME_UP';\n            case 'volumeDown':\n                return 'VOLUME_DOWN';\n        }\n\n        return value;\n    }\n\n    toInternal(\n        action: PublicRecorderAPI.Action | PublicRecorderAPI.RecordedAction\n    ) {\n        const map = () => {\n            action = cleanObject(action);\n\n            let element:\n                | InternalRecorderAPI.Element\n                | InternalRecorderAPI.ElementSelector\n                | undefined;\n            let coordinates: Coordinates | undefined;\n            let localPosition: InternalRecorderAPI.Position | undefined;\n\n            if ('element' in action && action.element) {\n                element = this.elementMapper.toInternal(action.element);\n            }\n\n            if ('position' in action && action.position) {\n                const x = DataParser.toPositionValue(action.position.x);\n                const y = DataParser.toPositionValue(action.position.y);\n\n                if (\n                    !DataValidator.isValidNumber(x) ||\n                    !DataValidator.isValidNumber(y)\n                ) {\n                    throw new OperationalError(\n                        `Invalid position: (${action.position.x}, ${action.position.y}). Values must be a number or a percentage`\n                    );\n                }\n\n                if (!DataValidator.isPositionWithinBounds(action.position)) {\n                    if (typeof action.position.x === 'string') {\n                        throw new Error(\n                            `Invalid position: (${action.position.x}, ${action.position.y}) must be within (0%, 0%) and (100%, 100%)`\n                        );\n                    } else {\n                        throw new Error(\n                            `Invalid position: (${action.position.x}, ${action.position.y}) must be within (0, 0) and (1, 1)`\n                        );\n                    }\n                }\n\n                if (this.platform === 'android') {\n                    coordinates = this.getCoordinates(action.position, {\n                        width: this.dipToPixel(this.screen.width) - 1,\n                        height: this.dipToPixel(this.screen.height) - 1,\n                    });\n                } else {\n                    coordinates = this.getCoordinates(action.position, {\n                        width: this.screen.width - 1,\n                        height: this.screen.height - 1,\n                    });\n                }\n            } else if ('coordinates' in action && action.coordinates) {\n                if (\n                    !DataValidator.isValidNumber(action.coordinates.x) ||\n                    !DataValidator.isValidNumber(action.coordinates.y)\n                ) {\n                    throw new OperationalError(\n                        `Invalid coordinates: (${action.coordinates.x}, ${action.coordinates.y}). Values must be a number`\n                    );\n                }\n\n                if (\n                    !DataValidator.isCoordinatesWithinBounds(\n                        action.coordinates,\n                        {\n                            width: this.screen.width - 1,\n                            height: this.screen.height - 1,\n                        }\n                    )\n                ) {\n                    throw new OperationalError(\n                        `Invalid coordinates: (${action.coordinates.x}, ${\n                            action.coordinates.y\n                        }) exceed screen bounds (${this.screen.width - 1}, ${\n                            this.screen.height - 1\n                        })`\n                    );\n                }\n\n                if (this.platform === 'android') {\n                    coordinates = {\n                        x: this.dipToPixel(action.coordinates.x),\n                        y: this.dipToPixel(action.coordinates.y),\n                    };\n                } else {\n                    coordinates = action.coordinates;\n                }\n            }\n\n            if ('localPosition' in action && action.localPosition) {\n                const x = DataParser.toPositionValue(action.localPosition.x);\n                const y = DataParser.toPositionValue(action.localPosition.y);\n\n                if (\n                    !DataValidator.isValidNumber(x) ||\n                    !DataValidator.isValidNumber(y)\n                ) {\n                    throw new OperationalError(\n                        `Invalid localPosition: (${action.localPosition.x}, ${action.localPosition.y}). Values must be a number or a percentage`\n                    );\n                }\n\n                // iOS sometimes reports localPosition values out of bounds. for the time being\n                // we will disable this check.\n                // if (!Validator.isPositionWithinBounds(action.localPosition)) {\n                //     if (typeof action.localPosition.x === 'string') {\n                //         throw new Error(\n                //             `Invalid localPosition: (${action.localPosition.x}, ${action.localPosition.y}) must be within (0%, 0%) and (100%, 100%)`\n                //         );\n                //     } else {\n                //         throw new Error(\n                //             `Invalid localPosition: (${action.localPosition.x}, ${action.localPosition.y}) must be within (0, 0) and (1, 1)`\n                //         );\n                //     }\n                // }\n\n                localPosition = {\n                    x,\n                    y,\n                };\n            } else {\n                if (element) {\n                    localPosition = { x: 0.5, y: 0.5 };\n                }\n            }\n\n            if ('duration' in action && action.duration) {\n                if (!DataValidator.isValidNumber(action.duration)) {\n                    throw new OperationalError(\n                        `Invalid duration: ${action.duration}. Value must be a number`\n                    );\n                }\n            }\n\n            switch (action.type) {\n                case 'tap': {\n                    const { position, ...rest } = action;\n\n                    return {\n                        ...rest,\n                        element,\n                        localPosition,\n                        coordinates,\n                    } as InternalRecorderAPI.TapAction;\n                }\n                case 'swipe': {\n                    const { position, ...rest } = action;\n\n                    return {\n                        ...rest,\n                        element,\n                        localPosition,\n                        coordinates,\n                        moves: action.moves.map((move) => {\n                            if (this.platform === 'android') {\n                                const { x, y } = this.getCoordinates(move, {\n                                    width:\n                                        this.dipToPixel(this.screen.width) - 1,\n                                    height:\n                                        this.dipToPixel(this.screen.height) - 1,\n                                });\n                                return {\n                                    ...move,\n                                    x,\n                                    y,\n                                };\n                            } else {\n                                const { x, y } = this.getCoordinates(move, {\n                                    width: this.screen.width - 1,\n                                    height: this.screen.height - 1,\n                                });\n                                return {\n                                    ...move,\n                                    x,\n                                    y,\n                                };\n                            }\n                        }),\n                    } as InternalRecorderAPI.SwipeAction;\n                }\n                case 'keypress': {\n                    const key = this.toInternalKey(action.key);\n                    const character = this.toInternalKey(action.character);\n\n                    return {\n                        ...action,\n                        key,\n                        character,\n                        shiftKey:\n                            this.platform === 'ios'\n                                ? DataParser.toNumber(action.shiftKey)\n                                : action.shiftKey,\n                    } as InternalRecorderAPI.KeypressAction;\n                }\n                case 'findElements': {\n                    return {\n                        ...action,\n                        element,\n                    } as InternalRecorderAPI.FindElementsAction;\n                }\n            }\n            return action;\n        };\n\n        return cleanObject(map());\n    }\n\n    toPublic(\n        action: InternalRecorderAPI.Action | InternalRecorderAPI.RecordedAction\n    ): PublicRecorderAPI.Action | PublicRecorderAPI.RecordedAction {\n        const map = () => {\n            let element:\n                | PublicRecorderAPI.Element\n                | PublicRecorderAPI.ElementSelector\n                | undefined;\n            let coordinates: Coordinates | undefined;\n            let position: PublicRecorderAPI.Position | undefined;\n            let localPosition: PublicRecorderAPI.Position | undefined =\n                // if this is a playback result payload, localPosition may be defined\n                'localPosition' in action ? action.localPosition : undefined;\n\n            if ('coordinates' in action && action.coordinates) {\n                coordinates = {\n                    x: this.pixelToDip(action.coordinates.x),\n                    y: this.pixelToDip(action.coordinates.y),\n                };\n\n                position = this.getPosition(coordinates, {\n                    width: this.screen.width - 1,\n                    height: this.screen.height - 1,\n                });\n            }\n\n            if ('element' in action && action.element) {\n                element = this.elementMapper.toPublic(action.element);\n\n                if (coordinates && element.bounds) {\n                    localPosition = this.getPosition(\n                        {\n                            x: coordinates.x - element.bounds.x,\n                            y: coordinates.y - element.bounds.y,\n                        },\n                        {\n                            width: element.bounds.width,\n                            height: element.bounds.height,\n                        }\n                    );\n                }\n            }\n\n            switch (action.type) {\n                case 'tap': {\n                    return {\n                        ...action,\n                        coordinates,\n                        element,\n                        position,\n                        localPosition,\n                    } as PublicRecorderAPI.TapAction;\n                }\n                case 'swipe': {\n                    return {\n                        ...action,\n                        coordinates,\n                        element,\n                        position,\n                        localPosition,\n                        moves: action.moves.map((move) => {\n                            const { x, y } = this.getPosition(\n                                {\n                                    x: this.pixelToDip(move.x),\n                                    y: this.pixelToDip(move.y),\n                                },\n                                {\n                                    width: this.screen.width - 1,\n                                    height: this.screen.height - 1,\n                                }\n                            );\n\n                            return {\n                                x,\n                                y,\n                                t: move.t,\n                            };\n                        }),\n                    } as PublicRecorderAPI.SwipeAction;\n                }\n\n                case 'keypress': {\n                    const key = this.toPublicKey(action.key);\n                    const character = this.toPublicKey(action.character);\n\n                    return {\n                        ...action,\n                        key,\n                        character,\n                        shiftKey:\n                            typeof action.shiftKey === 'number'\n                                ? DataParser.toBoolean(action.shiftKey)\n                                : Boolean(action.shiftKey),\n                    } as PublicRecorderAPI.KeypressAction;\n                }\n                case 'findElements': {\n                    return {\n                        ...action,\n                        element,\n                    } as PublicRecorderAPI.FindElementsAction;\n                }\n            }\n\n            return action;\n        };\n\n        return cleanObject(map());\n    }\n}\n\n// prevents accidentally using window.screen that instead of this.screen\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ndeclare let screen: never;\n","import { Platform, ScreenBounds } from '../types/recorder/common';\nimport * as InternalRecorderAPI from '../types/recorder/internal';\nimport * as PublicRecorderAPI from '../types/recorder/public';\nimport { AppetizeApp } from '../types/app';\n\nimport { ActionMapper } from './action';\nimport { ElementMapper } from './element';\n\nexport class SessionEventMapper {\n    platform?: Platform;\n    screen?: ScreenBounds;\n    app?: AppetizeApp;\n\n    actionMapper: ActionMapper;\n    elementMapper: ElementMapper;\n\n    constructor({\n        platform,\n        screen,\n        app,\n    }: {\n        platform: Platform;\n        screen: ScreenBounds;\n        app?: AppetizeApp;\n    }) {\n        this.app = app;\n        this.platform = platform;\n        this.screen = screen;\n\n        this.actionMapper = new ActionMapper({\n            platform,\n            screen,\n        });\n\n        this.elementMapper = new ElementMapper({\n            platform,\n            screen,\n        });\n    }\n\n    public toInternal(type: string, value: any) {\n        switch (type) {\n            case 'playAction': {\n                const payload = value as {\n                    id: string;\n                    action: PublicRecorderAPI.Action;\n                    timeout?: number;\n                };\n                const noMap = value.__noMap__; // for internal debug, not a public option\n\n                const mappedAction = noMap\n                    ? value.action\n                    : this.actionMapper.toInternal(payload.action);\n\n                return {\n                    type,\n                    value: {\n                        ...payload,\n                        action: mappedAction,\n                    },\n                };\n            }\n        }\n\n        return { type, value };\n    }\n\n    public toPublic(type: string, value: any) {\n        switch (type) {\n            case 'debug':\n                return {\n                    type: 'log',\n                    value: value,\n                };\n            case 'interceptResponse':\n                return {\n                    type: 'network',\n                    value: {\n                        type: 'response',\n                        ...value,\n                    },\n                };\n            case 'interceptRequest':\n                return {\n                    type: 'network',\n                    value: {\n                        type: 'request',\n                        ...value,\n                    },\n                };\n\n            case 'interceptError':\n                return {\n                    type: 'network',\n                    value: {\n                        type: 'error',\n                        ...value,\n                    },\n                };\n\n            case 'userError':\n                return {\n                    type: 'error',\n                    value: value,\n                };\n            case 'userInteractionReceived':\n                return {\n                    type: 'interaction',\n                    value: value,\n                };\n            case 'countdownWarning':\n                return {\n                    type: 'inactivityWarning',\n                    value: value,\n                };\n            case 'h264Data':\n                return {\n                    type: 'video',\n                    value: {\n                        ...value,\n                        codec: 'h264',\n                    },\n                };\n\n            case 'frameData':\n                return {\n                    type: 'video',\n                    value: {\n                        ...value,\n                        codec: 'jpeg',\n                    },\n                };\n            case 'audioData': {\n                return {\n                    type: 'audio',\n                    value: {\n                        ...value,\n                        codec: 'aac',\n                    },\n                };\n            }\n\n            case 'concurrentQueue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'concurrent',\n                        name: value.name,\n                        position: value.position,\n                    },\n                };\n            case 'queue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'session',\n                        position: value.position,\n                    },\n                };\n\n            // xdoc events\n            case 'orientationChanged':\n                return {\n                    type,\n                    value,\n                };\n            case 'chromeDevToolsUrl':\n                return {\n                    type: 'networkInspectorUrl',\n                    value,\n                };\n\n            // app recorder\n            case 'recordedAction': {\n                return {\n                    type: 'action',\n                    value: this.actionMapper.toPublic(value),\n                };\n            }\n            case 'playbackFoundAndSent': {\n                const v = value as InternalRecorderAPI.PlayActionResult;\n\n                return {\n                    type: 'playbackFoundAndSent',\n                    value: {\n                        ...v,\n                        playback: {\n                            ...v.playback,\n                            action: v.playback?.action\n                                ? this.actionMapper.toPublic(v.playback.action)\n                                : undefined,\n                        },\n                        matchedElements: v.matchedElements?.map((e) => {\n                            if (e) {\n                                return this.elementMapper!.toPublic(e);\n                            }\n                        }),\n                    },\n                } as {\n                    type: string;\n                    value: PublicRecorderAPI.PlayActionResult;\n                };\n            }\n            case 'playbackError': {\n                const v = value as InternalRecorderAPI.PlayActionResult;\n\n                return {\n                    type: 'playbackError',\n                    value: {\n                        ...v,\n                        playback: {\n                            ...v.playback,\n                            action: v.playback?.action\n                                ? this.actionMapper.toPublic(v.playback.action)\n                                : undefined,\n                        },\n                        matchedElements: v.matchedElements?.map((e) => {\n                            if (e) {\n                                return this.elementMapper!.toPublic(e);\n                            }\n                        }),\n                    },\n                } as {\n                    type: string;\n                    value: PublicRecorderAPI.PlayActionErrorResponse;\n                };\n            }\n            case 'uiDump': {\n                const appUi = value.ui ?? value.result;\n                const springboardUi = value.springboard;\n\n                const mapRecursive = (\n                    element: InternalRecorderAPI.FullElement\n                ): PublicRecorderAPI.FullElement => {\n                    return {\n                        ...this.elementMapper!.toPublic(element),\n                        children: element.children?.map(mapRecursive),\n                    };\n                };\n\n                const result: PublicRecorderAPI.AllUI = [];\n\n                if (appUi) {\n                    if (this.platform === 'ios') {\n                        result.push({\n                            type: 'app',\n                            appId: this.app?.bundle,\n                            children: appUi.map(mapRecursive),\n                        });\n                    } else {\n                        // on android, everything is one tree. in the future they will separate.\n                        result.push({\n                            type: 'app',\n                            children: appUi.map(mapRecursive),\n                        });\n                    }\n                }\n\n                if (springboardUi) {\n                    result.push({\n                        type: 'app',\n                        appId: 'com.apple.springboard',\n                        children: springboardUi.map(mapRecursive),\n                    });\n                }\n\n                return {\n                    type: 'uiDump',\n                    value: result,\n                };\n            }\n            // suppressed events\n            case 'deleteEvent':\n                return null;\n        }\n\n        return {\n            type,\n            value,\n        };\n    }\n}\n\nexport class ClientEventMapper {\n    public toInternal(type: string, value: any) {\n        return { type, value };\n    }\n\n    public toPublic(type: string, value: any) {\n        switch (type) {\n            case 'userError':\n                return {\n                    type: 'error',\n                    value: value,\n                };\n            case 'concurrentQueue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'concurrent',\n                        name: value.name,\n                        position: value.position,\n                    },\n                };\n            case 'queue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'session',\n                        position: value.position,\n                    },\n                };\n\n            // xdoc events\n            case 'deviceInfo':\n            case 'sessionInfo':\n            case 'sessionRequested':\n                return {\n                    type,\n                    value,\n                };\n        }\n\n        return {\n            type,\n            value,\n        };\n    }\n}\n\n// prevents accidentally using window.screen that instead of this.screen\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ndeclare let screen: never;\n","import { EventEmitter } from '../../EventEmitter';\nimport { SocketProtocol } from '../types/socket';\nimport { ClientEventMapper } from './event';\n\nexport class ClientSocketMapper extends EventEmitter implements SocketProtocol {\n    private _socket: SocketProtocol;\n    private eventMapper = new ClientEventMapper();\n\n    constructor({ socket }: { socket: SocketProtocol }) {\n        super();\n        this._socket = socket;\n\n        socket.on('*', ({ type, value }) => {\n            const mapped = this.mapEmit(type, value);\n            const suppressed = mapped === null;\n\n            if (!suppressed) {\n                this.emit(mapped.type, mapped.value);\n                this.emit('*', mapped);\n            }\n        });\n    }\n\n    private mapEmit(type: string, value: any) {\n        return this.eventMapper.toPublic(type, value);\n    }\n\n    private mapSend(type: string, value: any) {\n        return this.eventMapper.toInternal(type, value);\n    }\n\n    send(event: string, data?: any): Promise<void> {\n        const mapped = this.mapSend(event, data);\n\n        return this._socket.send(mapped.type, mapped.value);\n    }\n\n    disconnect(): Promise<void> {\n        return this._socket.disconnect();\n    }\n}\n","import {\n    Session,\n    SessionConfig,\n    SessionEvents,\n    UserSessionConfig,\n} from '../session';\nimport { SocketProtocol } from '../api/types/socket';\nimport { Logger } from '../logger';\nimport { EventEmitter } from '../EventEmitter';\nimport { ClientSocketMapper } from '../api/mappers/client-socket';\n\nexport class Client<\n    TSocket extends SocketProtocol,\n    TEvents extends ClientEvents,\n    TSession extends Session<SessionEvents>\n> extends EventEmitter {\n    socket: TSocket;\n    logger: Logger;\n\n    // needed for swipes, but it's currently only possible to get from the embed page\n    // TODO: for headless, we need this to be receivable from appetizer socket\n    device!: DeviceInfo;\n    protected _config: SessionConfig | undefined;\n\n    queue?: ClientEvents['queue'];\n\n    constructor({\n        socket,\n        logger = new Logger(),\n    }: {\n        socket: TSocket;\n        logger?: Logger;\n    }) {\n        super();\n        this.logger = logger;\n        this.socket = new ClientSocketMapper({ socket }) as any as TSocket;\n        this.socket.on('*', ({ type, value }) => {\n            // don't forward socket newSession, we emit a 'session' event\n            // with the session instance instead\n            if (type === 'newSession') {\n                return;\n            }\n\n            this.emit(type, value);\n            this.emit('*', { type, value });\n        });\n\n        this.socket.on('newSession', () => {\n            if (this.queue) {\n                this.emit('queueEnd');\n                this.queue = undefined;\n            }\n        });\n\n        this.on('queue' as any, (queue: ClientEvents['queue']) => {\n            this.queue = queue;\n        });\n    }\n\n    on<K extends Extract<keyof TEvents, string>>(\n        event: K,\n        listener: (value: TEvents[K]) => void\n    ): this {\n        return super.on(event, listener);\n    }\n\n    // implementation of this method depends on the class\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async startSession(config?: Partial<UserSessionConfig>): Promise<TSession> {\n        throw new Error('Not implemented');\n    }\n\n    // implementation of this method depends on the class\n    async setConfig(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        config: Partial<UserSessionConfig>\n    ): Promise<SessionConfig> {\n        throw new Error('Not implemented');\n    }\n\n    getConfig() {\n        return this._config;\n    }\n\n    protected async waitForSessionStart(session: TSession) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            const handleDisconnect = () => {\n                reject(new Error('Session disconnected before it was ready'));\n            };\n\n            const handleSessionError = (ev: any) => {\n                reject(\n                    new Error(\n                        `Session failed to start - ${\n                            typeof ev.message === 'object'\n                                ? JSON.stringify(ev.message)\n                                : ev.message\n                        }`\n                    )\n                );\n            };\n\n            // at this point we have the session, but just incase an error comes through on client we'll\n            // reject the promise too\n            const handleClientError = (ev: { message: string }) => {\n                reject(\n                    new Error(\n                        `Session failed to start - ${\n                            ev?.message ?? 'Unknown error'\n                        }`\n                    )\n                );\n            };\n\n            try {\n                this.on('error' as any, handleClientError);\n                session.on('disconnect', handleDisconnect);\n                session.on('error', handleSessionError);\n\n                await session.waitUntilReady();\n            } catch (e) {\n                reject(e);\n            } finally {\n                this.off('error', handleClientError);\n                session.off('disconnect', handleDisconnect);\n                session.off('error', handleSessionError);\n            }\n\n            resolve(session);\n        });\n    }\n}\n\nexport interface ClientEvents {\n    queue:\n        | { type: 'session'; position: number }\n        | { type: 'concurrent'; name: string; position: number };\n    queueEnd: void;\n    error: { message: string };\n    session: Session;\n}\n\nexport interface DeviceInfo {\n    type: string;\n    name: string;\n    osVersion: string;\n    orientation: 'portrait' | 'landscape';\n    screen: {\n        width: number;\n        height: number;\n        devicePixelRatio?: number;\n    };\n}\n","import { EventEmitter } from 'events';\nimport { TimeoutError } from './errors';\n\n/**\n * Waits for the function to succeed without an error. If the function throws an error, it will retry until it succeeds or the timeout is reached.\n * Alternatively, you can call the `bail` function to throw an error and stop retrying.\n */\nexport async function waitFor<T>(\n    fn: (bail: (error: Error) => void) => T | Promise<T>,\n    timeout: number | null = 5000\n): Promise<T> {\n    const start = Date.now();\n\n    let bail = false;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            const result = await fn((error) => {\n                if (error) {\n                    bail = true;\n                    throw error;\n                }\n            });\n\n            return result;\n        } catch (e) {\n            await new Promise((resolve) => setTimeout(resolve, 100));\n            if (bail || (timeout !== null && Date.now() - start > timeout)) {\n                throw e;\n            }\n        }\n    }\n}\n\nexport async function waitForTimeout(ms: number) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport interface WaitForEventOptions<T> {\n    timeout?: number | null;\n    predicate?: (data: T) => boolean;\n}\n\nexport type WaitForEventOptionsOrPredicate<T> =\n    | WaitForEventOptions<T>\n    | ((data: T) => boolean | undefined);\n\n/**\n * Waits for the event to fire on the emitter and resolves with the value\n */\nexport async function waitForEvent<T>(\n    emitter: EventEmitter,\n    event: string,\n    optionsOrPredicate?: WaitForEventOptionsOrPredicate<T>\n): Promise<T> {\n    const options =\n        typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate;\n    const predicate =\n        typeof optionsOrPredicate === 'function'\n            ? optionsOrPredicate\n            : optionsOrPredicate?.predicate;\n\n    const timeout =\n        typeof options?.timeout !== 'undefined' ? options.timeout : 10000;\n\n    return new Promise((resolve, reject) => {\n        const listener = (data) => {\n            if (!predicate || predicate(data)) {\n                emitter.off(event, listener);\n                resolve(data);\n            }\n        };\n        emitter.on(event, listener);\n\n        if (timeout !== null) {\n            setTimeout(() => {\n                emitter.off(event, listener);\n                reject(\n                    new TimeoutError(\n                        `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`\n                    )\n                );\n            }, timeout);\n        }\n    });\n}\n","import { UserSessionConfig } from './session';\nimport { cleanObject } from './util';\n\n/**\n * Parses user config and does any necessary transformations\n */\nexport function parseConfig(config?: UserSessionConfig) {\n    if (!config) {\n        return {};\n    }\n\n    return {\n        ...cleanObject(config),\n        device: (config as any).deviceType || config.device,\n    };\n}\n","import { AppetizeApp } from '../api/types/app';\nimport { Client, ClientEvents, DeviceInfo } from './client';\nimport { Logger } from '../logger';\nimport {\n    Session,\n    SessionConfig,\n    SessionEvents,\n    SessionInfo,\n    UserSessionConfig,\n} from '../session';\nimport { SocketProtocol } from '../api/types/socket';\nimport { waitFor } from '../waitFor';\nimport { AppetizeWindowProtocol } from '../window';\nimport { parseConfig } from '../config';\n\n/**\n * Any client that interacts with the /embed Appetize.io page (embed, playwright)\n */\nexport class HeadfulClient<\n    TSocket extends SocketProtocol,\n    TEvents extends HeadfulClientEvents<TSession>,\n    TSession extends Session<SessionEvents>\n> extends Client<TSocket, TEvents, TSession> {\n    device!: HeadfulDeviceInfo;\n    app?: AppetizeApp;\n\n    /**\n     * an embed can only have 1 session at a time\n     * but it can be started either by user clicking on the iframe,\n     * or by calling client.startSession(). for either case,\n     * we store that session reference here\n     */\n    protected session: TSession | undefined;\n    protected window: AppetizeWindowProtocol;\n    protected ready = false;\n\n    /**\n     * True if the client is currently requesting a session (in queue / waiting for connection)\n     */\n    protected isRequestingSession = false;\n\n    private _lastSetConfigCallId: string | null = null;\n\n    constructor({\n        socket,\n        window,\n        logger = new Logger(),\n        config,\n        autoInit = true,\n    }: {\n        autoInit?: boolean;\n        socket: TSocket;\n        window: AppetizeWindowProtocol;\n        logger?: Logger;\n        config?: SessionConfig;\n    }) {\n        super({ socket, logger });\n        this.window = window;\n\n        if (config) {\n            this.assignConfig(config);\n        }\n\n        this.window.on('*', async ({ type, value }) => {\n            if (this.ready) {\n                switch (type) {\n                    case 'app':\n                        this.app = value;\n                        this.emit(type, value);\n                        break;\n                    case 'deviceInfo':\n                        this.device = value;\n                        this.emit(type, value);\n                        break;\n                    case 'config':\n                        this.assignConfig(value);\n                        break;\n                }\n            }\n        });\n\n        this.window.on('reinit', () => {\n            this.ready = false;\n            this.session = undefined;\n\n            this.init({ isReinit: true });\n        });\n\n        this.socket.on('*', async ({ type, value }) => {\n            if (this.ready) {\n                switch (type) {\n                    // when newSession is received, create the session instance\n                    case 'newSession': {\n                        try {\n                            this.isRequestingSession = false;\n                            this.session = this.createSession(this._config!, {\n                                path: value.path,\n                                token: value.sessionToken,\n                            });\n                            await this.waitForSessionStart(this.session);\n                            this.emit('session', this.session);\n                        } catch (e) {\n                            this.session = undefined;\n                            this.emit('sessionError', e);\n                        }\n                    }\n                }\n            }\n        });\n\n        if (autoInit !== false) {\n            this.init();\n        }\n    }\n\n    protected async init(\n        args: {\n            isReinit?: boolean;\n        } = { isReinit: false }\n    ) {\n        await this.window.waitUntilReady();\n\n        const setConfig = async () => {\n            if (args.isReinit) {\n                const oldConfig = this._config;\n\n                // get the new config from the window\n                const newConfig = await this.setConfig({});\n\n                // shallowly merge the old config with the new config\n                return this.setConfig({\n                    record: true,\n                    ...oldConfig,\n                    ...newConfig,\n                });\n            } else {\n                return this.setConfig({\n                    // always set record config unless explicitly set to false\n                    record: true,\n                    ...this._config,\n                });\n            }\n        };\n        const [app, deviceInfo] = await Promise.all([\n            this.window.postMessage({ type: 'getApp' }, true),\n            this.window.postMessage<HeadfulDeviceInfo>(\n                { type: 'getDeviceInfo' },\n                true\n            ),\n            setConfig(),\n        ]);\n\n        this.app = app;\n        this.device = deviceInfo;\n        // this.setConfig already sets this._config\n\n        this.ready = true;\n    }\n\n    async waitUntilReady() {\n        if (this.ready) {\n            return;\n        }\n\n        return waitFor(async () => {\n            if (!this.ready) {\n                throw new Error('Timed out waiting for client to be ready');\n            }\n        }, 30000);\n    }\n\n    async startSession(config?: Partial<UserSessionConfig>) {\n        const wasRequestingSession = this.isRequestingSession;\n\n        // startSession can be cancelled at any point by calling endSession, so whenever we await we'll\n        // need to check if we're still requesting a session\n        const wasCancelled = () => this.isRequestingSession === false;\n        this.isRequestingSession = true;\n\n        try {\n            // wait until client is ready\n            try {\n                await this.waitUntilReady();\n            } catch (e) {\n                const message = e instanceof Error ? e.message : e;\n                throw new Error(`Failed to start session. ${message}`);\n            }\n\n            if (!wasCancelled()) {\n                if (this.session) {\n                    await this.session.end();\n                } else if (wasRequestingSession) {\n                    await this.cancelSessionRequest();\n\n                    // cancelSessionRequest will set this to false so we need to set to true again\n                    this.isRequestingSession = true;\n                }\n            }\n\n            // send through config\n            if (!wasCancelled()) {\n                await this.setConfig(config ?? {});\n            }\n\n            // wait for session to be requested and received\n            if (!wasCancelled()) {\n                // request session and wait for `session` event to be emitted off self, then resolve\n                const [session] = await Promise.all([\n                    new Promise<TSession>((resolve, reject) => {\n                        const handleResolve = (data: TSession) => {\n                            this.off('session' as any, handleResolve);\n                            this.off('sessionError' as any, handleReject);\n                            this.off('error' as any, handleReject);\n                            resolve(data);\n                        };\n\n                        const handleReject = (data: any) => {\n                            this.off('session' as any, handleResolve);\n                            this.off('sessionError' as any, handleReject);\n                            this.off('error' as any, handleReject);\n\n                            if (data instanceof Error) {\n                                reject(data);\n                            } else if (\n                                data &&\n                                typeof data.message === 'string'\n                            ) {\n                                reject(\n                                    new Error(\n                                        `Session failed to start - ${data.message}`\n                                    )\n                                );\n                            } else {\n                                reject(data);\n                            }\n                        };\n\n                        this.on('session' as any, handleResolve);\n                        this.on('sessionError' as any, handleReject);\n                        this.on('error' as any, handleReject);\n                    }),\n                    this.window.postMessage({ type: 'requestSession' }, true),\n                ]);\n\n                return session;\n            } else {\n                throw new Error('Session request was cancelled');\n            }\n        } finally {\n            this.isRequestingSession = false;\n        }\n    }\n\n    async endSession() {\n        if (this.session) {\n            await this.session.end();\n        } else if (this.isRequestingSession) {\n            await this.cancelSessionRequest();\n        }\n    }\n\n    /**\n     * @deprecated Use client.setConfig()\n     */\n    async config(args: Partial<UserSessionConfig>): Promise<UserSessionConfig> {\n        // TODO: remove in v2\n        this.logger.warn(\n            `client.config() is deprecated and will be removed in a future major release. Use client.setConfig() instead.`\n        );\n        return this.setConfig(args);\n    }\n\n    async setConfig({\n        // buildId & publicKey are not part of config object but we accept them\n        // as parameters so we can load a new app & set config in one call\n        buildId,\n        publicKey,\n        ...config\n    }: Partial<UserSessionConfig>): Promise<SessionConfig> {\n        this._lastSetConfigCallId = Math.random().toString(36);\n        const currentSetConfigCallId = this._lastSetConfigCallId;\n\n        if (!buildId && publicKey) {\n            // TODO: we are just going to silently support publicKey since 100% of projects are going to be\n            // using it. After a month or so (?) of v2, we'll enable this warning.\n            // this.logger.warn.once(\n            //     `'publicKey' is deprecated and will be removed in a future release. Please rename 'publicKey' to 'buildId'. \\n More info: https://docs.appetize.io/platform/embedding-apps`\n            // );\n            buildId = publicKey;\n        }\n\n        if (buildId) {\n            const response = await this.window.postMessage<\n                AppetizeApp | { error: string }\n            >(\n                {\n                    type: 'loadApp',\n                    value: buildId,\n                },\n                true\n            );\n\n            if (response && 'error' in response) {\n                // loadApp was cancelled from consecutive setConfig({ buildId }) calls before the app was loaded.\n                // silently return the current config as we can expect another setConfig call to be in-progress\n                if (response.error === 'cancelled') {\n                    return this._config!;\n                }\n\n                throw new Error(response.error);\n            }\n\n            // additional check for multiple setConfig calls, can be removed once frontend responds with 'cancelled' error\n            if (currentSetConfigCallId !== this._lastSetConfigCallId) {\n                return this._config!;\n            }\n        }\n\n        const validatedConfig = await this.window.postMessage<SessionConfig>(\n            {\n                type: 'setConfig',\n                value: this.validateConfig({\n                    ...config,\n                    // embed takes publicKey for this payload still\n                    ...(buildId ? { publicKey: buildId } : {}),\n                }),\n            },\n            true\n        );\n\n        return this.assignConfig(validatedConfig);\n    }\n\n    /**\n     * Updates internal _config and carries over buildId/publicKey from previous config if not defined in new config\n     *\n     * We carry it over because buildId/publicKey is not part of the config as far as the embed is concerned,\n     * so the relayed response won't contain it. The SDK keeps it in the config as a convention for the user.\n     * Eventually, we should have the embed reflect this behaviour as well.\n     */\n    protected assignConfig(config: UserSessionConfig) {\n        if (config.autoplay === true) {\n            this.logger.warn.once(\n                'autoplay=true may cause the session to start before the SDK is ready. You should start the session programmatically using client.startSession() instead.'\n            );\n        }\n\n        this._config = parseConfig(config);\n\n        return this._config;\n    }\n\n    /**\n     * Runs during this.setConfig() before sending config options to the embed. Override this\n     * to add default or validate config values\n     */\n    protected validateConfig(config: Partial<UserSessionConfig>) {\n        return config;\n    }\n\n    private async cancelSessionRequest() {\n        if (this.isRequestingSession) {\n            this.isRequestingSession = false;\n            await this.window.postMessage('endSession');\n            this.emit('sessionEnded');\n        }\n    }\n\n    /**\n     * Called by either client.startSession() or when user starts a session manually.\n     * This should simply assign this.session to a new Session instance\n     */\n    protected createSession(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        config: SessionConfig,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        info: SessionInfo\n    ): TSession {\n        throw new Error('Not implemented');\n    }\n}\n\nexport interface HeadfulClientEvents<TSession extends Session>\n    extends ClientEvents {\n    session: TSession;\n    app: AppetizeApp;\n    deviceInfo: HeadfulDeviceInfo;\n    sessionRequested: void;\n    sessionEnded: void;\n}\n\nexport interface HeadfulDeviceInfo extends DeviceInfo {\n    embed: {\n        width: number;\n        height: number;\n        screen: {\n            width: number;\n            height: number;\n            offset: {\n                x: number;\n                y: number;\n            };\n        };\n    };\n}\n","import { LogFn, Logger } from '../../core/logger';\n\n/**\n * This logger will not print to the console when silent=true.\n *\n * This is good for CI to keep output clean and only print the logs\n * after a test fails. The fixture handles this logic, and by default\n * this logger is silent when process.env.CI is true.\n */\nexport class PlaywrightLogger extends Logger {\n    logHistory: Array<{\n        method: 'log' | 'warn' | 'error' | 'debug';\n        data: any[];\n    }> = [];\n\n    logLevel: 'verbose' | 'warnings-errors' | 'none' =\n        process.env.CI === 'true' ? 'warnings-errors' : 'verbose';\n\n    log = this.createPlaywrightLogFn('log', () => this.logLevel === 'verbose');\n\n    warn = this.createPlaywrightLogFn(\n        'warn',\n        () => this.logLevel === 'verbose' || this.logLevel === 'warnings-errors'\n    );\n\n    error = this.createPlaywrightLogFn(\n        'error',\n        () => this.logLevel === 'verbose' || this.logLevel === 'warnings-errors'\n    );\n\n    debug = this.createPlaywrightLogFn(\n        'debug',\n        () => this.logLevel === 'verbose'\n    );\n\n    clearLogHistory = () => {\n        this.logHistory = [];\n    };\n\n    private createPlaywrightLogFn(\n        type: 'log' | 'warn' | 'error' | 'debug',\n        print: () => boolean\n    ) {\n        const loggedMessages = new Set<string>();\n        const context = '[Appetize]';\n\n        // preserves the original console context\n        const fn: LogFn = (...data: any[]) => {\n            this.logHistory.push({\n                method: type,\n                data,\n            });\n\n            if (print()) {\n                console[type](context, ...data);\n            }\n        };\n\n        // logs message only once, but we do lose the console context with this implementation\n        fn.once = (msg: string) => {\n            if (loggedMessages.has(msg)) {\n                return;\n            } else {\n                loggedMessages.add(msg);\n            }\n\n            return fn.call(console, msg);\n        };\n\n        return fn;\n    }\n}\n\nexport const logger = new PlaywrightLogger();\n","export function uint8ArrayToString(uint8Arr: Uint8Array) {\n    const length = uint8Arr.length;\n    let result = '';\n    for (let i = 0; i < length; i += 65535) {\n        let addition = 65535;\n        if (i + 65535 > length) {\n            addition = length - i;\n        }\n        result += String.fromCharCode.apply(\n            null,\n            uint8Arr.subarray(i, i + addition) as unknown as number[]\n        );\n    }\n    return result;\n}\n\nexport function uint8ArrayToBase64(uint8Arr: Uint8Array, mimeType: string) {\n    // if we're in node, use Buffer.from for faster conversion\n    if (typeof window === 'undefined' && typeof Buffer !== 'undefined') {\n        const str = Buffer.from(uint8Arr).toString('base64');\n        return `data:${mimeType};base64,` + str;\n    } else {\n        const str = uint8ArrayToString(uint8Arr);\n        const base64String = btoa(str);\n        return `data:${mimeType};base64,` + base64String;\n    }\n}\n","import { OperationalError } from '../errors';\nimport { SwipeMove } from '../api/types/recorder';\n\nexport interface SwipeGestureArgs {\n    duration?: number;\n    stepDuration?: number;\n}\n\nexport class SwipeGesture {\n    private moves: Movement[] = [];\n    private duration?: number;\n    private stepDuration: number;\n\n    constructor({ duration, stepDuration }: SwipeGestureArgs) {\n        this.duration = duration;\n        this.stepDuration = stepDuration ?? 16;\n\n        this.moves = [{ x: 0, y: 0 }];\n    }\n\n    to(x: string, y: string) {\n        if (typeof x !== 'string' || typeof y !== 'string') {\n            throw new OperationalError(\n                'x and y must be strings and in percentages (e.g. \"50%\")'\n            );\n        }\n\n        if (!x.endsWith('%') || !y.endsWith('%')) {\n            throw new OperationalError(\n                'x and y must be in percentages (e.g. \"50%\")'\n            );\n        }\n\n        this.moves.push({\n            x: parseFloat(x) / 100,\n            y: parseFloat(y) / 100,\n        });\n\n        return this;\n    }\n\n    // undecided if we want to support this\n    // move(x: string, y: string) {\n    //     if (typeof x !== 'string' || typeof y !== 'string') {\n    //         throw new Error(\n    //             'x and y must be strings and in percentages (e.g. \"50%\")'\n    //         );\n    //     }\n\n    //     if (!x.endsWith('%') || !y.endsWith('%')) {\n    //         throw new Error('x and y must be in percentages (e.g. \"50%\")');\n    //     }\n\n    //     const previous = this.moves[this.moves.length - 1];\n\n    //     this.moves.push({\n    //         x: (previous?.x ?? 0) + parseFloat(x) / 100,\n    //         y: (previous?.y ?? 0) + parseFloat(y) / 100,\n    //     });\n\n    //     return this;\n    // }\n\n    wait(duration: number) {\n        const previous = this.moves[this.moves.length - 1];\n        if (previous) {\n            previous.wait = duration + (previous.wait ?? 0);\n        }\n\n        return this;\n    }\n\n    build() {\n        const stepDuration = this.stepDuration;\n\n        const duration =\n            this.duration ??\n            Math.max(500, stepDuration * (this.moves.length - 1));\n\n        const totalSteps = Math.floor(duration / stepDuration);\n        const stepsPerSegment = Math.floor(\n            totalSteps / (this.moves.length - 1)\n        );\n\n        const result: SwipeMove[] = [];\n        let accruedWaitTime = 0;\n\n        if (stepsPerSegment === 0) {\n            const requiredDuration = (this.moves.length - 1) * stepDuration;\n\n            throw new Error(\n                `Duration is too short for ${\n                    this.moves.length - 1\n                } moves, please set duration to at least ${requiredDuration}ms`\n            );\n        }\n\n        for (let i = 0; i < this.moves.length - 1; i++) {\n            const lowerCoord = this.moves[i];\n            const upperCoord = this.moves[i + 1];\n            const isLastPair = i === this.moves.length - 2;\n\n            for (let step = 0; step <= stepsPerSegment; step++) {\n                // Skip the last step for all pairs except the final one to prevent duplicates\n                if (!isLastPair && step === stepsPerSegment) continue;\n\n                const progress = step / stepsPerSegment;\n                const interpolatedX =\n                    lowerCoord.x + progress * (upperCoord.x - lowerCoord.x);\n                const interpolatedY =\n                    lowerCoord.y + progress * (upperCoord.y - lowerCoord.y);\n                const t =\n                    ((i * stepsPerSegment + step) * stepDuration +\n                        accruedWaitTime) /\n                    1000;\n\n                result.push({ x: interpolatedX, y: interpolatedY, t });\n\n                // If the current pair has a wait time, add duplicate point\n                // with extended ts\n                if (step === 0 && lowerCoord.wait) {\n                    result.push({\n                        x: interpolatedX,\n                        y: interpolatedY,\n                        t: t + lowerCoord.wait / 1000,\n                    });\n                    accruedWaitTime += lowerCoord.wait;\n                }\n            }\n\n            // if the last move was a wait, duplicate the last point and extend the ts\n            if (i === this.moves.length - 2 && upperCoord.wait) {\n                const lastResult = result[result.length - 1];\n                result.push({\n                    x: lastResult.x,\n                    y: lastResult.y,\n                    t: lastResult.t + upperCoord.wait / 1000,\n                });\n            }\n        }\n        return result;\n    }\n\n    up(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to('0%', `-${value}%`);\n    }\n\n    down(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to('0%', `${value}%`);\n    }\n\n    left(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to(`-${value}%`, '0%');\n    }\n\n    right(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to(`${value}%`, '0%');\n    }\n}\n\ninterface Movement {\n    x: number;\n    y: number;\n    wait?: number;\n}\n","import { EventEmitter } from '../../EventEmitter';\nimport { Platform, ScreenBounds } from '../types/recorder/common';\nimport { AppetizeApp } from '../types/app';\nimport { DeviceInfo } from '../../client';\nimport { SessionConfig } from '../../session';\nimport { SocketProtocol } from '../types/socket';\nimport { SessionEventMapper } from './event';\n\n/**\n * Wraps an Appetize socket and maps payloads to and from the public API.\n */\nexport class SessionSocketMapper\n    extends EventEmitter\n    implements SocketProtocol\n{\n    platform: Platform;\n    screen: ScreenBounds;\n    app?: AppetizeApp;\n    private _socket: SocketProtocol;\n\n    constructor({\n        socket,\n        platform,\n        screen,\n        app,\n    }: {\n        socket: SocketProtocol;\n        platform: Platform;\n        screen: ScreenBounds;\n        app?: AppetizeApp;\n    }) {\n        super();\n        this._socket = socket;\n        this.platform = platform;\n        this.screen = screen;\n        this.app = app;\n\n        socket.on('*', ({ type, value }) => {\n            const mapped = this.mapEmit(type, value);\n            const suppressed = mapped === null;\n\n            if (!suppressed) {\n                this.handleEvent(mapped.type, mapped.value);\n                this.emit(mapped.type, mapped.value);\n                this.emit('*', mapped);\n            }\n        });\n    }\n\n    send(event: string, data?: any): Promise<void> {\n        const mapped = this.mapSend(event, data);\n        return this._socket.send(mapped.type, mapped.value);\n    }\n\n    disconnect(): Promise<void> {\n        return this._socket.disconnect();\n    }\n\n    private handleEvent(type: string, value: any) {\n        // update app, screen, platform for mappers\n        switch (type) {\n            case 'app':\n                this.app = value;\n                break;\n            case 'deviceInfo': {\n                const deviceInfo = value as DeviceInfo;\n                if (deviceInfo?.screen) {\n                    this.screen = deviceInfo.screen;\n                }\n                break;\n            }\n            case 'config': {\n                const config = value as SessionConfig;\n                if (config.platform) {\n                    this.platform = config.platform;\n                }\n                break;\n            }\n        }\n    }\n\n    private mapEmit(type: string, value: any) {\n        const eventMapper = new SessionEventMapper({\n            platform: this.platform,\n            screen: this.screen,\n            app: this.app,\n        });\n\n        return eventMapper.toPublic(type, value);\n    }\n\n    private mapSend(type: string, value: any) {\n        const eventMapper = new SessionEventMapper({\n            platform: this.platform,\n            screen: this.screen,\n            app: this.app,\n        });\n\n        return eventMapper.toInternal(type, value);\n    }\n}\n","import {\n    LiteralUnion,\n    OmitUnion,\n    createDeferredPromise,\n    uuid,\n} from '../../core/util';\nimport {\n    WaitForEventOptions,\n    waitFor,\n    waitForEvent,\n    waitForTimeout,\n} from '../../core/waitFor';\nimport { EventEmitter } from '../EventEmitter';\n\nimport {\n    Action,\n    Element,\n    ElementSelector,\n    FindElementsAction,\n    PlayActionErrorResponse,\n    PlayActionOptions,\n    PlayActionResult,\n    RecordedAction,\n    SwipeAction,\n    TapAction,\n} from '../api/types/recorder';\nimport { AllUI } from '../api/types/recorder/public';\nimport { AppetizeApp } from '../api/types/app';\nimport { uint8ArrayToBase64 } from '../buffer';\nimport { SwipeGesture } from '../builders/swipe-gesture';\nimport { DeviceInfo } from '../client';\nimport {\n    ActionAmbiguousElementError,\n    ActionElementNotFoundError,\n    ActionError,\n    ActionInternalError,\n    ActionInvalidArgumentError,\n    ActionTimeoutError,\n    OperationalError,\n    RecorderRequiredError,\n    TimeoutError,\n    captureOperationalError,\n} from '../errors';\nimport { Logger } from '../logger';\nimport { SocketProtocol } from '../api/types/socket';\nimport { SessionSocketMapper } from '../api/mappers/session-socket';\nimport { DataValidator } from '../api/parser';\n\nexport interface SessionArgs {\n    path: string;\n    token: string;\n    socket: SocketProtocol;\n    config: SessionConfig;\n    device: DeviceInfo;\n    logger: Logger;\n    app?: AppetizeApp;\n}\nexport class Session<\n    Events extends SessionEvents = SessionEvents\n> extends EventEmitter {\n    socket: SocketProtocol;\n    logger: Logger;\n\n    path: string;\n    token: string;\n\n    app?: AppetizeApp;\n    device: DeviceInfo;\n    config: SessionConfig;\n    #adbConnection?: AdbConnectionInfo;\n    #networkInspectorUrl?: string;\n\n    /**\n     * Session is ending due to session.end()\n     */\n    protected isEndingManually = false;\n\n    /**\n     * Countdown warning due to inactivity has been received\n     */\n    protected countdownWarning = false;\n\n    protected ready = false;\n\n    private _waitForAnimationsPromises: Set<Promise<void>> = new Set();\n\n    constructor({\n        socket,\n        config,\n        path,\n        token,\n        app,\n        device,\n        logger = new Logger(),\n    }: SessionArgs) {\n        super();\n        this.config = config;\n        this.socket = new SessionSocketMapper({\n            socket,\n            app,\n            screen: device.screen,\n            platform: config.platform!,\n        });\n        this.device = device;\n        this.app = app;\n        this.path = path;\n        this.token = token;\n        this.logger = logger;\n\n        const handleSocketEvent = ({ type, value }) => {\n            switch (type) {\n                case 'ready':\n                    this.ready = true;\n                    break;\n                case 'adbOverTcp': {\n                    this.#adbConnection = {\n                        ...value,\n                        command: getAdbShellCommand(value),\n                    };\n                    break;\n                }\n                case 'networkInspectorUrl':\n                    this.#networkInspectorUrl = value;\n                    break;\n                case 'countdownWarning':\n                    this.countdownWarning = true;\n                    break;\n                case 'timeoutReset':\n                    this.countdownWarning = false;\n                    break;\n                case 'deviceInfo':\n                    this.device = value;\n                    break;\n                case 'disconnect':\n                    this.emit('end');\n                    this.emit('*', { type: 'end' });\n                    break;\n            }\n\n            this.emit(type, value);\n            this.emit('*', { type, value });\n        };\n\n        this.socket.on('*', handleSocketEvent);\n\n        /**\n         * remove socket event handler on disconnect\n         *\n         * this is important for embed/playwright, where the \"socket\" is\n         * a connection to the iframe. if the session ends, the iframe/page may still\n         * exist, so we need to \"disconnect\" this session instance from future postMessages.\n         * otherwise, event listeners on the \"old\" session will fire.\n         */\n        this.on('disconnect' as Extract<keyof Events, string>, () => {\n            this.socket.off('*', handleSocketEvent);\n\n            if (!this.isEndingManually) {\n                if (this.countdownWarning) {\n                    this.logger.warn(\n                        `Appetize session has ended due to inactivity`\n                    );\n                } else {\n                    this.logger.warn(`Session disconnected`);\n                }\n            }\n        });\n    }\n\n    on<K extends Extract<keyof Events, string>>(\n        event: K,\n        listener: (value: Events[K]) => void\n    ): this {\n        if (event === 'network' && this.config.proxy !== 'intercept') {\n            this.logger.warn(\n                'Session must be configured with `proxy: \"intercept\"` to listen to network events.'\n            );\n        }\n\n        if (event === 'log' && this.config.debug !== true) {\n            this.logger.warn(\n                'Session must be configured with `debug: true` to listen to log events.'\n            );\n        }\n\n        if (event === 'action' && this.config.record !== true) {\n            this.logger.warn(\n                'Session must configured with `record: true` to listen to action events.'\n            );\n        }\n\n        return super.on(event, listener);\n    }\n\n    async waitUntilReady() {\n        let isConnected = true;\n\n        // we would like certain properties to be defined on the session before we resolve,\n        // but we don't want to block the session from starting if not. so we wait a max of 3s\n        const waitForValue = async (cb: () => boolean) => {\n            return new Promise((res) => {\n                const interval = setInterval(() => {\n                    if (cb()) {\n                        res(undefined);\n                    }\n                }, 10);\n\n                setTimeout(() => {\n                    clearInterval(interval);\n                    res(undefined);\n                }, 3000);\n            });\n        };\n\n        const handleDisconnect = () => {\n            isConnected = false;\n        };\n\n        this.socket.once('disconnect', handleDisconnect);\n\n        // we could be at 'switching device' state, which if we're running against a single server\n        // can take a long time when it's under load, so we give it a generous timeout\n        try {\n            await waitFor((bail) => {\n                if (this.ready) {\n                    return;\n                }\n\n                if (isConnected) {\n                    throw new TimeoutError(\n                        'Timed out after 180s waiting for session to be ready'\n                    );\n                } else {\n                    bail(new Error('Session disconnected'));\n                }\n            }, 180000);\n        } finally {\n            this.socket.off('disconnect', handleDisconnect);\n        }\n\n        // wait for properties\n        await Promise.all([\n            this.config.proxy === 'intercept'\n                ? waitForValue(() => Boolean(this.#networkInspectorUrl))\n                : Promise.resolve(),\n            this.config.enableAdb\n                ? waitForValue(() => Boolean(this.#adbConnection))\n                : Promise.resolve(),\n        ]);\n    }\n\n    async waitForEvent<K extends keyof SessionEvents>(\n        event: K,\n        options?: WaitForEventOptions<SessionEvents[K]>\n    ) {\n        try {\n            return await waitForEvent(this, event, options);\n        } catch (e) {\n            captureOperationalError(e, this.waitForEvent);\n            throw e;\n        }\n    }\n\n    /**\n     * Ends the current session\n     */\n    async end() {\n        this.isEndingManually = true;\n        await this.socket.disconnect();\n    }\n\n    get networkInspectorUrl() {\n        if (this.config.proxy !== 'intercept') {\n            this.logger.warn(\n                'Session must be configured with `proxy: \"intercept\"` to use the network inspector'\n            );\n        }\n\n        return this.#networkInspectorUrl;\n    }\n\n    get adbConnection() {\n        if (this.config.platform && this.config.platform !== 'android') {\n            this.logger.warn(\n                'Session must be connected to an Android device to use adb'\n            );\n        }\n\n        if (!this.config.enableAdb) {\n            this.logger.warn(\n                'Session must be configured with `enableAdb: true` to use adb'\n            );\n        }\n\n        if (this.#adbConnection) {\n            return this.#adbConnection;\n        }\n    }\n\n    /**\n     * Rotates the device left or right by 90 degrees\n     */\n\n    async rotate(\n        direction: 'left' | 'right'\n    ): Promise<'portrait' | 'landscape'> {\n        try {\n            const [orientation] = await Promise.all([\n                this.waitForEvent('orientationChanged'),\n                this.socket.send('userInteraction', {\n                    type: 'keypress',\n                    key: direction === 'left' ? 'rotateLeft' : 'rotateRight',\n                    timeStamp: Date.now(),\n                }),\n            ]);\n\n            return orientation;\n        } catch (e) {\n            captureOperationalError(e, this.rotate);\n            throw e;\n        }\n    }\n\n    /**\n     * Takes a screenshot of the device. Format returned can be either 'buffer' or 'base64'.\n     *\n     * If buffer format is requested on browser and Buffer is not polyfilled the result will be a Uint8Array.\n     */\n    async screenshot<\n        T extends 'buffer' | 'base64',\n        Data = T extends 'buffer' ? Buffer : string\n    >(\n        format: T = 'buffer' as T\n    ): Promise<{\n        data: Data;\n        mimeType: string;\n    }> {\n        try {\n            this.socket.send('getScreenshot', {});\n\n            const result = await waitForEvent<{\n                data: Uint8Array;\n                success: boolean;\n                mimeType: string;\n                error?: string;\n            }>(this.socket, 'screenshot', { timeout: 60000 });\n\n            if (!result.success) {\n                throw new OperationalError(result.error ?? `Screenshot failed`);\n            }\n\n            // if on Node, convert to buffer. otherwise leave as Uint8Array\n            const toBuffer = (data: Uint8Array) => {\n                return typeof window === 'undefined' ? Buffer.from(data) : data;\n            };\n\n            const data =\n                format === 'buffer'\n                    ? (toBuffer(result.data) as unknown as Data)\n                    : (uint8ArrayToBase64(\n                          new Uint8Array(result.data),\n                          result.mimeType\n                      ) as unknown as Data);\n\n            return {\n                data,\n                mimeType: result.mimeType,\n            };\n        } catch (e) {\n            captureOperationalError(e, this.screenshot);\n            throw e;\n        }\n    }\n\n    /**\n     * Sends a heartbeat to the appetize server. This will reset the inactivity timer.\n     **/\n    async heartbeat() {\n        try {\n            return await this.socket.send('heartbeat');\n        } catch (e) {\n            captureOperationalError(e, this.heartbeat);\n            throw e;\n        }\n    }\n\n    /**\n     * Types the given text\n     */\n    async type(text: string) {\n        try {\n            // on both iOS and Android, if a type comes after a tap on an input,\n            // there seems to be a necessary delay for accurate typing.\n            // TODO: a better solution here would be to track whether or not a tap was\n            // the last action, and if so, do this wait.\n            await waitForTimeout(1000);\n\n            const result = await this.playAction({\n                type: 'typeText',\n                text: text,\n            });\n\n            // incase the user is tapping on an input next, wait an additional 500ms\n            await waitForTimeout(500);\n\n            return result;\n        } catch (e) {\n            captureOperationalError(e, this.type);\n            throw e;\n        }\n    }\n\n    /**\n     * Sends a keypress event to the device.\n     */\n    async keypress(key: KeyValue, options?: { shift?: boolean }) {\n        try {\n            // temporary, until backend can emit this as a keypress\n            if (key === 'ANDROID_KEYCODE_MENU') {\n                return await this.socket.send('androidKeycodeMenu');\n            }\n\n            // if shift, we need to use legacy keypress api\n            // character: 'HOME' not supported on android, will fix later.\n            if (options?.shift || key === 'HOME') {\n                switch (key) {\n                    case 'ArrowUp':\n                        key = 'arrowUp';\n                        break;\n                    case 'ArrowDown':\n                        key = 'arrowDown';\n                        break;\n                    case 'ArrowLeft':\n                        key = 'arrowLeft';\n                        break;\n                    case 'ArrowRight':\n                        key = 'arrowRight';\n                        break;\n                    case 'Enter':\n                        key = '\\r';\n                        break;\n                    case 'Tab':\n                        key = '\\t';\n                        break;\n                    case 'Backspace':\n                        key = '\\b';\n                        break;\n                }\n\n                return this.playAction({\n                    type: 'keypress',\n                    key,\n                    shiftKey: !!options?.shift,\n                });\n            } else {\n                return this.playAction({\n                    type: 'keypress',\n                    character: key,\n                });\n            }\n        } catch (e) {\n            captureOperationalError(e, this.keypress);\n            throw e;\n        }\n    }\n\n    /**\n     * Sets the language and restarts the app\n     */\n    async setLanguage(language: string) {\n        try {\n            this.config.language = language;\n            return await this.socket.send('setLanguage', {\n                language,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.setLanguage);\n            throw e;\n        }\n    }\n\n    /**\n     * Sets the location with the given latitude and longitude\n     */\n    async setLocation(latitude: number, longitude: number) {\n        try {\n            if (typeof latitude !== 'number' || typeof longitude !== 'number') {\n                throw new OperationalError(\n                    `setLocation requires latitude and longitude to be numbers`\n                );\n            }\n\n            const location = [latitude, longitude];\n            this.config.location = location;\n\n            return await this.socket.send('setLocation', {\n                location: location,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.setLocation);\n            throw e;\n        }\n    }\n\n    /**\n     * Opens a deep-link or regular URL\n     */\n    async openUrl(url: string) {\n        try {\n            return await this.socket.send('openUrl', {\n                url: url,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.openUrl);\n            throw e;\n        }\n    }\n\n    /**\n     * Launch an application by the app's ID.\n     * Android also accepts a format of <PACKAGE_NAME>/<ACTIVITY_NAME>\n     * Default activity name for Android will be resolved if it's not passed here\n     */\n    async launchApp(appId: string) {\n        try {\n            return await this.socket.send('launchApp', {\n                appId,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.launchApp);\n            throw e;\n        }\n    }\n\n    /**\n     * Sends shake gesture (iOS only)\n     */\n    async shake() {\n        try {\n            return await this.socket.send('shakeDevice');\n        } catch (e) {\n            captureOperationalError(e, this.swipe);\n            throw e;\n        }\n    }\n\n    async toggleSoftKeyboard() {\n        try {\n            if (this.config.platform !== 'ios') {\n                throw new Error(\n                    'toggleSoftKeyboard is only available on iOS devices'\n                );\n            }\n            return await this.socket.send('toggleSoftKeyboard');\n        } catch (e) {\n            captureOperationalError(e, this.toggleSoftKeyboard);\n            throw e;\n        }\n    }\n\n    /**\n     * Simulate a matching fingerprint (Android 8+ only)\n     */\n    async biometry({ match }: { match: boolean }) {\n        try {\n            return await this.socket.send(\n                match ? 'biometryMatch' : 'biometryNonMatch'\n            );\n        } catch (e) {\n            captureOperationalError(e, this.biometry);\n            throw e;\n        }\n    }\n\n    /**\n     * Upload media to the simulator.\n     * @param file The file we want to upload to the running device\n     */\n    async addMedia(file: File) {\n        if (file.size > 50 * 1024 * 1024) {\n            // client-side check file size <= 50 MB\n            throw new Error(\n                'Your proposed upload exceeds the maximum allowed size of 50MB'\n            );\n        }\n\n        try {\n            const endpoint = `${this.path}/session/${this.token}/addMedia`;\n            // Headers only support ISO-8859-1 characters\n            // eslint-disable-next-line no-control-regex\n            const invalidFileNameExpression = /[^\\u0000-\\u00ff]/g;\n            const filename = file.name.replace(invalidFileNameExpression, '-');\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                body: file,\n                headers: {\n                    'X-Appetize-File-Name': filename,\n                    'Content-Type': file.type,\n                },\n            });\n\n            if (!response.ok) {\n                const message = await response.text();\n                throw new Error(\n                    `Failed to upload media file. Received ${response.status} - ${message}`\n                );\n            }\n            return response;\n        } catch (error) {\n            captureOperationalError(error, this.addMedia);\n            throw error;\n        }\n    }\n\n    /**\n     * Sets biometry enrollment status (iOS only)\n     */\n    async biometryEnrollment(isEnrolled: boolean) {\n        try {\n            if (this.config.platform !== 'ios') {\n                throw new Error(\n                    'biometryEnrollment is only available on iOS devices'\n                );\n            }\n\n            return await this.socket.send('biometryEnrollment', { isEnrolled });\n        } catch (e) {\n            captureOperationalError(e, this.biometryEnrollment);\n            throw e;\n        }\n    }\n\n    /**\n     * Whether or not to allow interactions from the user on the device\n     */\n    async allowInteractions(allow: boolean): Promise<void> {\n        try {\n            return await this.socket.send(\n                allow ? 'enableInteractions' : 'disableInteractions'\n            );\n        } catch (e) {\n            captureOperationalError(e, this.allowInteractions);\n            throw e;\n        }\n    }\n\n    /**\n     * Restarts the app\n     */\n    async restartApp() {\n        try {\n            if (this.isStandalone) {\n                this.logger.warn('restartApp has no effect on a Standalone');\n            } else {\n                this.socket.send('restartApp');\n                await this.waitForEvent('appLaunch', { timeout: 60000 });\n            }\n        } catch (e) {\n            captureOperationalError(e, this.restartApp);\n            throw e;\n        }\n    }\n\n    /**\n     * Reinstalls the app\n     */\n    async reinstallApp() {\n        try {\n            if (this.isStandalone) {\n                this.logger.warn('reinstallApp has no effect on a Standalone');\n            } else {\n                this.socket.send('reinstallApp');\n                await this.waitForEvent('appLaunch', { timeout: 60000 });\n            }\n        } catch (e) {\n            captureOperationalError(e, this.reinstallApp);\n            throw e;\n        }\n    }\n\n    async adbShellCommand(command: string) {\n        if (this.config.platform !== 'android') {\n            throw new Error(\n                'adbShellCommand is only available on Android devices'\n            );\n        }\n\n        try {\n            return await this.socket.send('adbShellCommand', {\n                command,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.adbShellCommand);\n            throw e;\n        }\n    }\n\n    async playAction<T extends Action | RecordedAction>(\n        action: T,\n        options: PlayActionOptions<T> = {}\n    ): Promise<PlayActionResult<T>> {\n        const { timeout = 10000 } = options;\n\n        /**\n         *  appetizer has a max timeout of 10s per playAction\n         */\n        const MAX_APP_RECORDER_TIMEOUT = 10000;\n\n        /**\n         * the longest we'll wait for appetizer to respond before throwing a timeout error.\n         * this is to prevent the session from hanging if the server doesn't respond\n         * (it's possible the server is slow, so it's generous)\n         *\n         * this can cause playAction() to run for up to this value past options.timeout, but it's\n         * better than hanging forever or timing out too early.\n         */\n        const MAX_WAIT_FOR_RESPONSE = timeout + 30000;\n\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('playAction()');\n            }\n\n            if (isNaN(timeout)) {\n                throw new OperationalError(\n                    `Invalid timeout value: ${options.timeout}`\n                );\n            }\n\n            if (timeout < 0) {\n                throw new OperationalError(\n                    `Timeout value cannot be negative: ${options.timeout}`\n                );\n            }\n\n            if ('element' in action && action.element) {\n                DataValidator.isValidElementSelector(action.element);\n            }\n\n            const payload = {\n                id: uuid(),\n                action,\n                options: {\n                    ...options,\n                    timeout: Math.round(\n                        // appetizer has a max timeout of 10s per playAction event\n                        // (we will keep retrying until we use up the full timeout)\n                        Math.min(timeout, MAX_APP_RECORDER_TIMEOUT) / 1000\n                    ),\n                },\n            };\n\n            try {\n                const result = await new Promise<PlayActionResult<T>>(\n                    (resolve, reject) => {\n                        // set a hard timeout for incase the server doesn't respond within API_MAX_TIMEOUT\n                        const hardTimeout = setTimeout(() => {\n                            cleanup();\n                            reject(\n                                new ActionTimeoutError(\n                                    {\n                                        id: payload.id,\n                                        action: action as Action,\n                                        timeout: payload.options.timeout,\n                                    },\n                                    `Timed out waiting for response from device`\n                                )\n                            );\n                        }, MAX_WAIT_FOR_RESPONSE);\n\n                        const cleanup = () => {\n                            this.off('playbackFoundAndSent', handleSuccess);\n                            this.off('playbackError', handleError);\n                            clearTimeout(hardTimeout);\n                        };\n\n                        const handleSuccess = async (\n                            value: PlayActionResult<any>\n                        ) => {\n                            if (value.playback?.id !== payload.id) return;\n\n                            cleanup();\n                            resolve(value);\n                        };\n\n                        const handleError = async (\n                            error: PlayActionErrorResponse<Action>\n                        ) => {\n                            if (error.playback?.id !== payload.id) return;\n\n                            cleanup();\n\n                            switch (error.errorId) {\n                                case 'internalError':\n                                    reject(new ActionInternalError(error));\n                                    break;\n                                case 'notFound': {\n                                    reject(\n                                        new ActionElementNotFoundError(error)\n                                    );\n                                    break;\n                                }\n                                case 'ambiguousMatch':\n                                    reject(\n                                        new ActionAmbiguousElementError(error)\n                                    );\n                                    break;\n                                case 'invalidArgument': {\n                                    reject(\n                                        new ActionInvalidArgumentError(error)\n                                    );\n                                    break;\n                                }\n                                default:\n                                    reject(new ActionError(error));\n                                    break;\n                            }\n                        };\n\n                        this.on('playbackFoundAndSent' as any, handleSuccess);\n                        this.on('playbackError' as any, handleError);\n                        this.socket.send('playAction', payload);\n                    }\n                );\n\n                return result;\n            } catch (e) {\n                const remainingTimeout = Math.max(\n                    0,\n                    timeout - MAX_APP_RECORDER_TIMEOUT\n                );\n\n                // if not an internal or hard timeout error, try again until timeout elapsed\n                if (\n                    remainingTimeout > 0 &&\n                    !(e instanceof ActionTimeoutError) &&\n                    !(e instanceof ActionInternalError)\n                ) {\n                    return await this.playAction(action, {\n                        ...options,\n                        timeout: remainingTimeout,\n                    });\n                }\n\n                throw e;\n            }\n        } catch (e) {\n            captureOperationalError(e, this.playAction);\n            throw e;\n        }\n    }\n\n    async playActions<T extends Action | RecordedAction>(\n        actions: T[],\n        options: PlayActionOptions<any> = {}\n    ) {\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('playActions()');\n            }\n\n            const results: PlayActionResult<any>[] = [];\n\n            for (const action of actions) {\n                const result = await this.playAction(action, options);\n\n                results.push(result);\n\n                const nextAction = actions[actions.indexOf(action) + 1];\n\n                const isConsecutiveKeypress =\n                    nextAction &&\n                    nextAction.type === 'keypress' &&\n                    action.type === 'keypress';\n\n                // wait between each action unless we are playing back consecutive keypresses\n                if (!isConsecutiveKeypress) {\n                    // wait for animations to settle on screen for up to 2s\n                    await this.waitForAnimations({ timeout: 2000 }).catch(\n                        () => {\n                            // no-op - continue if animations haven't settled yet\n                        }\n                    );\n                }\n            }\n\n            return results;\n        } catch (e) {\n            captureOperationalError(e, this.playActions);\n            throw e;\n        }\n    }\n\n    async getUI({\n        timeout = 30000,\n    }: {\n        timeout?: number;\n    } = {}) {\n        try {\n            this.socket.send('dumpUi');\n\n            const data = await waitForEvent<AllUI>(this, 'uiDump', {\n                timeout,\n            });\n\n            return data;\n        } catch (e) {\n            captureOperationalError(e, this.getUI);\n            throw e;\n        }\n    }\n\n    async findElement(\n        element: ElementSelector,\n        options?: PlayActionOptions<FindElementsAction> &\n            Pick<FindElementsAction, 'appId'>\n    ): Promise<Element | undefined> {\n        try {\n            const result = await this.playAction(\n                {\n                    type: 'findElements',\n                    element,\n                    appId: options?.appId,\n                },\n                options\n            );\n\n            return result.matchedElements?.[0];\n        } catch (e) {\n            captureOperationalError(e, this.findElement);\n            throw e;\n        }\n    }\n\n    async findElements(\n        element: ElementSelector,\n        options?: PlayActionOptions<FindElementsAction> &\n            Pick<FindElementsAction, 'appId'>\n    ) {\n        try {\n            const result = await this.playAction(\n                {\n                    type: 'findElements',\n                    element,\n                    appId: options?.appId,\n                },\n                options\n            );\n\n            return result.matchedElements;\n        } catch (e) {\n            captureOperationalError(e, this.findElements);\n            throw e;\n        }\n    }\n\n    /**\n     * Taps on the screen\n     */\n    async tap(\n        args: OmitUnion<TapAction, 'type' | 'id'>,\n        options?: PlayActionOptions<TapAction>\n    ) {\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('tap()');\n            }\n            return await this.playAction(\n                {\n                    type: 'tap',\n                    ...args,\n                    duration: (args.duration ?? 0) / 1000,\n                },\n                options\n            );\n        } catch (e) {\n            captureOperationalError(e, this.tap);\n            throw e;\n        }\n    }\n\n    /**\n     * Swipes on the screen\n     */\n    async swipe(\n        { duration, gesture, ...args }: SwipeArgs,\n        options?: PlayActionOptions<SwipeAction>\n    ) {\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('swipe()');\n            }\n\n            let action: SwipeAction;\n            const g = new SwipeGesture({\n                duration,\n                // @ts-expect-error - experimental api option\n                stepDuration: args.stepDuration,\n            });\n\n            if (typeof gesture === 'function') {\n                gesture(g);\n            } else {\n                switch (gesture) {\n                    case 'up':\n                        g.up();\n                        break;\n                    case 'down':\n                        g.down();\n                        break;\n                    case 'left':\n                        g.left();\n                        break;\n                    case 'right':\n                        g.right();\n                        break;\n                }\n            }\n\n            if ('element' in args) {\n                action = {\n                    type: 'swipe',\n                    element: args.element,\n                    localPosition: args.localPosition,\n                    moves: g.build(),\n                } as SwipeAction;\n            } else if ('position' in args) {\n                action = {\n                    type: 'swipe',\n                    position: args.position,\n                    moves: g.build(),\n                } as SwipeAction;\n            } else {\n                throw new Error('Either element or position must be specified');\n            }\n\n            return this.playAction(action, options);\n        } catch (e) {\n            captureOperationalError(e, this.swipe);\n            throw e;\n        }\n    }\n\n    /**\n     * Waits until the there are no ongoing animations the screen\n     * by waiting for the image to stabilize for at least 1 second\n     */\n    async waitForAnimations(\n        options: {\n            /**\n             * The threshold for the amount of pixels (in %) that can change between frames\n             * before the image is considered to be stable\n             *\n             * @default 0.01\n             */\n            imageThreshold?: number;\n\n            /**\n             * The maximum amount of time to wait for the image to stabilize\n             *\n             * @default 10000\n             */\n            timeout?: number;\n        } = {}\n    ) {\n        try {\n            const { imageThreshold = 0.001, timeout = 10000 } = options;\n\n            let imageThresholdDuration = 1000;\n            let lowestImageThreshold = 1;\n\n            // this is undocumented - we're not sure we want to expose this yet\n            if ((options as any).imageThresholdDuration) {\n                imageThresholdDuration = (options as any)\n                    .imageThresholdDuration;\n            }\n\n            const { promise, resolve, reject } = createDeferredPromise();\n\n            const timeoutId = setTimeout(() => {\n                let msg = `Timed out after ${timeout}ms waiting for animation to end.`;\n\n                if (imageThreshold < lowestImageThreshold) {\n                    msg += ` Waited for imageThreshold of ${imageThreshold} but lowest was ${\n                        Math.round(lowestImageThreshold * 10000) / 10000\n                    }`;\n                }\n\n                reject(new TimeoutError(msg));\n            }, timeout);\n\n            let lastTimeUnderThreshold: number | undefined;\n\n            const handlePixelsChanged = ({\n                percentage,\n                timestamp,\n            }: {\n                percentage: number;\n                timestamp: number;\n            }) => {\n                if (percentage < lowestImageThreshold) {\n                    lowestImageThreshold = percentage;\n                }\n\n                if (percentage <= imageThreshold) {\n                    if (!lastTimeUnderThreshold) {\n                        lastTimeUnderThreshold = timestamp;\n                    }\n\n                    if (\n                        lastTimeUnderThreshold &&\n                        timestamp - lastTimeUnderThreshold >=\n                            imageThresholdDuration\n                    ) {\n                        resolve();\n                    }\n                } else {\n                    lastTimeUnderThreshold = undefined;\n                }\n            };\n\n            this.socket.send('enablePixelChangeDetection');\n            this.socket.on('pixelsChanged', handlePixelsChanged);\n            this._waitForAnimationsPromises.add(promise);\n\n            return await promise.finally(() => {\n                clearTimeout(timeoutId);\n                this.socket.off('pixelsChanged', handlePixelsChanged);\n                this._waitForAnimationsPromises.delete(promise);\n\n                // only disable pixel change detection if there are no more active waitForAnimations\n                if (this._waitForAnimationsPromises.size === 0) {\n                    this.socket.send('disablePixelChangeDetection');\n                }\n            });\n        } catch (e) {\n            captureOperationalError(e, this.waitForAnimations);\n            throw e;\n        }\n    }\n\n    /* DEBUG METHODS */\n    /**\n     *\n     * @deprecated use `adbConnection` property instead\n     */\n    async getAdbInfo() {\n        this.logger.warn(\n            `getAdbInfo() is deprecated. Please use the \\`adbConnection\\` property instead.`\n        );\n        return Promise.resolve(this.#adbConnection);\n    }\n\n    /**\n     *\n     * @deprecated use `networkInspectorUrl` property instead\n     */\n    async getNetworkInspectorUrl() {\n        this.logger.warn(\n            `getNetworkInspectorUrl() is deprecated. Please use the \\`networkInspectorUrl\\` property instead.`\n        );\n        return Promise.resolve(this.#networkInspectorUrl);\n    }\n\n    /**\n     *\n     * @deprecated use `device` property instead\n     */\n    async getDeviceInfo() {\n        this.logger.warn(\n            `getDeviceInfo() is deprecated. Please use the \\`device\\` property instead.`\n        );\n        return Promise.resolve(this.device);\n    }\n\n    private get isStandalone() {\n        if (this.app?.buildId) {\n            return this.app.buildId.startsWith('standalone_');\n        }\n\n        return false;\n    }\n}\n\nexport interface SessionInfo {\n    path: string;\n    token: string;\n}\n\nfunction getAdbShellCommand(connectionInfo: AdbConnectionInfo) {\n    const template =\n        'ssh -fN -o StrictHostKeyChecking=no -oHostKeyAlgorithms=+ssh-rsa -p SERVER_PORT USERNAME@HOSTNAME -L6000:FORWARD_DESTINATION:FORWARD_PORT && adb connect localhost:6000';\n    if (!connectionInfo || !connectionInfo.forwards[0]) {\n        return undefined;\n    }\n    let returnValue = template;\n    returnValue = returnValue.replace(\n        /SERVER_PORT/,\n        connectionInfo.port.toString()\n    );\n    returnValue = returnValue.replace(/USERNAME/, connectionInfo.user);\n    returnValue = returnValue.replace(/HOSTNAME/, connectionInfo.hostname);\n    returnValue = returnValue.replace(\n        /FORWARD_DESTINATION/,\n        connectionInfo.forwards[0].destination\n    );\n    returnValue = returnValue.replace(\n        /FORWARD_PORT/,\n        connectionInfo.forwards[0].port.toString()\n    );\n    return returnValue;\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                    TYPES                                   */\n/* -------------------------------------------------------------------------- */\nexport interface SessionEvents {\n    log: { message: string };\n    network: NetworkRequest | NetworkResponse;\n    error: { message: string };\n    action: RecordedAction;\n\n    /**\n     * @deprecated use \"end\" event\n     */\n    disconnect: void;\n    end: void;\n\n    interaction: {\n        timeStamp: number;\n        type: string;\n        altKey?: boolean;\n        shiftKey?: boolean;\n        xPos?: number;\n        yPos?: number;\n    };\n    heartbeat: void;\n    orientationChanged: 'landscape' | 'portrait';\n    appLaunch: void;\n    firstFrameReceived: void;\n    inactivityWarning: { secondsRemaining: number };\n    ready: void;\n    video: {\n        buffer: Uint8Array;\n        width: number;\n        height: number;\n        codec: 'h264' | 'jpeg';\n    };\n    audio: {\n        buffer: Uint8Array;\n        codec: 'aac';\n        duration: number;\n    };\n\n    playbackFoundAndSent: PlayActionResult<Action>;\n    playbackError: PlayActionErrorResponse<Action>;\n}\n\nexport interface AdbConnectionInfo {\n    command: string;\n    forwards: Array<{ destination: string; port: number }>;\n    hash: string;\n    hostname: string;\n    port: number;\n    user: string;\n}\n\nexport interface SessionConfig {\n    device?: string;\n    osVersion?: string;\n    scale?: number | 'auto';\n    autoplay?: boolean;\n    adbShellCommand?: string;\n    androidPackageManager?: boolean;\n    appearance?: string;\n    audio?: boolean;\n    codec?: string;\n    debug?: boolean;\n    deviceColor?: string;\n    disableSessionStart?: boolean;\n    disableVirtualKeyboard?: boolean;\n    enableAdb?: boolean;\n    grantPermissions?: boolean;\n    hidePasswords?: boolean;\n    iosKeyboard?: string;\n    iosAutocorrect?: string;\n    language?: string;\n    launchUrl?: string;\n    launchArgs?: Array<string | number>;\n    locale?: string;\n    location?: number[];\n    loopback?: boolean;\n    noVideo?: boolean;\n    orientation?: string;\n    platform?: 'ios' | 'android';\n    payerCode?: string;\n    params?: Record<string, any>;\n    plistEdit?: Record<string, any>;\n    proxy?: string;\n    record?: boolean;\n    region?: string;\n    screenOnly?: boolean;\n    screenRecording?: boolean;\n    showRotateButtons?: boolean;\n    timezone?: string;\n    xdocMsg?: boolean;\n    endSessionRedirectUrl?: string;\n    userInteractionDisabled?: boolean;\n    volume?: number;\n    debugSession?: boolean;\n}\n\n// config that is specifiable by the user\nexport interface UserSessionConfig\n    extends Omit<SessionConfig, 'platform' | 'xdocMsg'> {\n    /**\n     * @deprecated use `buildId` instead\n     */\n    publicKey?: string;\n    buildId?: string;\n}\n\nexport interface NetworkRequest {\n    type: 'request';\n    serverIPAddress: string;\n    requestId: string;\n    request: {\n        method: string;\n        url: string;\n        httpVersion: string;\n        cookies: string[];\n        headers: Array<{ name: string; value: string }>;\n        queryString: string[];\n        headersSize: number;\n        bodySize: number;\n    };\n    cache: Record<string, any>;\n}\nexport interface NetworkResponse extends Omit<NetworkRequest, 'type'> {\n    type: 'response';\n    response: {\n        status: number;\n        statusText: string;\n        httpVersion: string;\n        cookies: string[];\n        headers: Array<{ name: string; value: string }>;\n        redirectURL: string;\n        headersSize: number;\n        bodySize: number;\n        content: {\n            size: number;\n            mimeType: string;\n            compression: number;\n            text: string;\n        };\n        postData?: {\n            mimeType: string;\n            text?: string;\n        };\n    };\n}\n\nexport type KeyValue = LiteralUnion<\n    'HOME' | 'VOLUME_UP' | 'VOLUME_DOWN' | 'ANDROID_KEYCODE_MENU',\n    string\n>;\n\ntype SimpleGesture = 'up' | 'down' | 'left' | 'right';\n\nexport type SwipeArgs = OmitUnion<SwipeAction, 'type' | 'moves'> & {\n    duration?: number;\n    gesture: SimpleGesture | ((gesture: SwipeGesture) => any);\n};\n","export default async function pause(page) {\n    /**\n     * Record your tests by interacting with your device! Once you are finished,\n     * press the \"Resume\" button at the top to continue.\n     */\n    await page.pause();\n}\n","import { KeypressAction } from './api/types/recorder';\n\nexport const controlKeys = [8, 9, 13, 16, 37, 38, 39, 40, null];\nexport const digitCharsWithShift = [\n    ')',\n    '!',\n    '@',\n    '#',\n    '$',\n    '%',\n    '^',\n    '&',\n    '*',\n    '(',\n];\nexport const charsWithShift = {\n    47: '?',\n    44: '<',\n    45: '_',\n    46: '>',\n    91: '{',\n    92: '|',\n    93: '}',\n    96: '~',\n    59: ':',\n    61: '+',\n    39: '\"',\n};\n\nexport const keysWithShift = {\n    191: '?',\n    188: '<',\n    189: '_',\n    190: '>',\n    219: '{',\n    220: '|',\n    221: '}',\n    192: '~',\n    186: ':',\n    187: '+',\n    222: '\"',\n};\n\nexport function convertCharToRawKey(key: string): {\n    key: string;\n    shiftKey: boolean;\n} {\n    let result;\n    for (const entry in charsWithShift) {\n        if (key === charsWithShift[entry]) {\n            result = {\n                // @ts-expect-error - copied from angular, entry should be a number but not sure if this works/is used\n                key: String.fromCharCode(entry),\n                shiftKey: 'true',\n            };\n            return result;\n        }\n    }\n    const indexInDigits = digitCharsWithShift.indexOf(key);\n    if (indexInDigits > -1) {\n        result = {\n            key: String.fromCharCode(indexInDigits + 48).toLowerCase(),\n            shiftKey: true,\n        };\n    } else if (key !== key.toLowerCase()) {\n        result = {\n            key: key.toLowerCase(),\n            shiftKey: true,\n        };\n    } else {\n        result = {\n            key: key,\n            shiftKey: false,\n        };\n    }\n    return result;\n}\n\nexport function getKeyFromKeypress(keypress: KeypressAction) {\n    if (keypress.character) {\n        return keypress.character;\n    }\n\n    // if no character, key must exist\n    const key = keypress.key!;\n\n    if (isSpecialKey(key)) {\n        return key;\n    }\n\n    return keypress.shiftKey ? key.toUpperCase() : key.toLowerCase();\n}\n\nexport function isSpecialKey(key: string) {\n    const pattern = /^[\\b\\t\\r]/;\n\n    return pattern.test(key);\n}\n\nexport function isSpecialChar(char: string) {\n    return char.length > 0;\n}\n/**\n * Converts legacy keycode to new keycode\n */\nexport function mapLegacyKeyCode(key: string) {\n    switch (key) {\n        case 'home':\n            return 'HOME';\n        case 'volumeUp':\n            return 'VOLUME_UP';\n        case 'volumeDown':\n            return 'VOLUME_DOWN';\n    }\n\n    return key;\n}\n\n/**\n * Converts new keycode to legacy keycode\n */\nexport function mapKeyCodeToLegacy(key: string) {\n    switch (key) {\n        case 'HOME':\n            return 'home';\n        case 'VOLUME_UP':\n            return 'volumeUp';\n        case 'VOLUME_DOWN':\n            return 'volumeDown';\n    }\n\n    return key;\n}\n","import { PlaywrightSession } from '../session';\nimport { TestInfo } from '@playwright/test';\nimport type {\n    RecordedAction,\n    TypeAction,\n} from '../../../core/api/types/recorder';\nimport fs from 'fs';\nimport { waitForTimeout } from '../../../core/waitFor';\nimport pause from './pause';\nimport { getKeyFromKeypress, isSpecialKey } from '../../../core/keys';\n\nexport class Codegen {\n    private session: PlaywrightSession;\n    private testInfo: TestInfo;\n    private currentRecord = 0;\n\n    constructor({\n        testInfo,\n        session,\n    }: {\n        testInfo: TestInfo;\n        session: PlaywrightSession;\n    }) {\n        this.session = session;\n        this.testInfo = testInfo;\n    }\n\n    async record() {\n        const file = this.testInfo.file;\n        const contents = await fs.promises.readFile(file, 'utf8');\n\n        // get session.record() statements for this test\n        const recordStatements = contents\n            .split('\\n')\n            // attach line numbers to each line\n            .map((line, num) => ({ line, num: num + 1 }))\n            // remove up to the current test() line #\n            .slice(this.testInfo.line)\n            // filter out lines that don't contain session.record()\n            .filter(({ line }) => line.includes('session.record()'));\n\n        const currentLine = recordStatements[this.currentRecord].num;\n\n        if (currentLine !== undefined) {\n            console.log(` Recording at line ${currentLine}`);\n\n            const actions: any[] = [];\n\n            const handleAction = (action: RecordedAction) => {\n                concatActions(actions, action);\n                console.log(describeAction(action));\n            };\n\n            this.session.on('action', handleAction);\n\n            // playwright shows the codecalling the pause, so we'll jump them\n            // to another file with some helpful comments\n            await pause(this.session.page);\n\n            // wait a few seconds to catch any other actions\n            await waitForTimeout(2000);\n\n            this.session.off('action', handleAction);\n\n            const newContents = contents.split('\\n').map((line, index) => {\n                if (index === currentLine - 1) {\n                    const tabs = line.match(/^\\s*/)?.[0] ?? 0;\n\n                    // generates a comment to summarize the recorded events\n                    const descriptions = actions\n                        .map((action) => {\n                            return describeAction(action);\n                        })\n                        .reduce(\n                            (acc, cur, i) => `${acc}\\n// ${i + 1}. ${cur}`,\n                            '// Recorded using session.record()'\n                        );\n\n                    return `${descriptions}\\nawait session.playActions(${JSON.stringify(\n                        actions,\n                        null,\n                        '\\t'\n                    )})`\n                        .split('\\n')\n                        .map((line) => tabs + line)\n                        .join('\\n');\n                }\n                return line;\n            });\n            await fs.promises.writeFile(file, newContents.join('\\n'));\n\n            console.log(` Finished`);\n            this.currentRecord += 1;\n        }\n    }\n}\n\n/**\n * Concatenates consecutive actions of the sam etype into single ones when applicable\n */\nfunction concatActions(\n    actions: Array<RecordedAction | TypeAction>,\n    action: RecordedAction\n) {\n    const lastAction = actions[actions.length - 1];\n\n    if (lastAction) {\n        switch (action.type) {\n            case 'keypress': {\n                // join consecutive keypress events into a single action\n                if (\n                    lastAction?.type === 'keypress' &&\n                    !isSpecialKey(action.key) &&\n                    !isSpecialKey(lastAction.key)\n                ) {\n                    actions.pop();\n\n                    actions.push({\n                        type: 'typeText',\n                        text:\n                            getKeyFromKeypress(lastAction) +\n                            getKeyFromKeypress(action),\n                    });\n                } else if (\n                    lastAction?.type === 'typeText' &&\n                    !isSpecialKey(action.key)\n                ) {\n                    actions.pop();\n\n                    actions.push({\n                        type: 'typeText',\n                        text: lastAction.text + getKeyFromKeypress(action),\n                    });\n                } else {\n                    actions.push(action);\n                }\n\n                break;\n            }\n            default:\n                actions.push(action);\n        }\n    } else {\n        actions.push(action);\n    }\n}\n\n/**\n * Describes the action in a human readable way\n */\nfunction describeAction(action: RecordedAction | TypeAction) {\n    let on = '';\n\n    switch (action.type) {\n        case 'swipe':\n        case 'tap': {\n            const element = action.element;\n\n            if (typeof element === 'string') {\n                on = ` on element \"${element}\"`;\n            } else {\n                if (element?.attributes?.accessibilityIdentifier) {\n                    on = `element with accessibilityIdentifier \"${element.attributes?.accessibilityIdentifier}\"`;\n                } else if (element?.attributes?.class) {\n                    on = `element with class \"${element.attributes?.class}\"`;\n                } else if (\n                    'position' in action &&\n                    action.position?.x &&\n                    action.position?.y\n                ) {\n                    on = `position ${Math.round(\n                        action.position.x * 100\n                    )}%, ${Math.round(action.position.y * 100)}%`;\n                }\n            }\n\n            if (on) {\n                return `${action.type} on ${on}`;\n            } else {\n                return action.type;\n            }\n        }\n        case 'keypress':\n            return `type \"${getKeyFromKeypress(action)}\"`;\n        case 'typeText':\n            return `type \"${action.text}\"`;\n    }\n}\n","import { version } from './package.json';\n\nexport const VERSION = version;\n","import { Page } from '@playwright/test';\nimport { SocketProtocol } from '../../core/api/types/socket';\nimport { waitFor, waitForEvent, WaitForEventOptions } from '../../core/waitFor';\nimport { VERSION } from '../../core/constants';\nimport { AppetizeWindowProtocol } from '../../core/window';\nimport { TimeoutError } from '../../core/errors';\nimport { EventEmitter } from '../../core/EventEmitter';\nimport { logger } from './logger';\nimport { AppetizeTestFixture } from './fixture';\n\n/**\n * Communicates with Appetize /embed page\n */\nexport class AppetizeWindow\n    extends EventEmitter\n    implements AppetizeWindowProtocol\n{\n    page: Page;\n    ready = false;\n    testFixture: AppetizeTestFixture;\n\n    constructor({\n        page,\n        testFixture,\n    }: {\n        page: Page;\n        testFixture: AppetizeTestFixture;\n    }) {\n        super();\n        this.page = page;\n        this.testFixture = testFixture;\n    }\n\n    async init() {\n        this.ready = false;\n\n        await this.testFixture.step('Connect to Appetize page', async () => {\n            // attach __appetize_on function\n            await this.page.exposeFunction('__appetize_on', (json) => {\n                const data = JSON.parse(json, function (key, value) {\n                    // look for typed array flags\n                    try {\n                        if ('flag' in value && value.flag === 'TYPED_ARRAY') {\n                            return global[value.constructor].from(\n                                value.data.split(',').map(Number)\n                            );\n                        }\n                    } catch (e) {\n                        // no-op\n                    }\n\n                    return value;\n                });\n\n                const type = data === 'string' ? data : data.type;\n                const value = data.value;\n\n                this.emit(type, value);\n                this.emit('*', { type, value });\n            });\n\n            await this.page.evaluate(\n                async ([VERSION]) => {\n                    return new Promise<boolean>((resolve, reject) => {\n                        const timeout = setTimeout(() => {\n                            clearInterval(interval);\n                            reject(\n                                new TimeoutError(\n                                    `Timed out after 60000ms waiting for connection to Appetize page`\n                                )\n                            );\n                        }, 60000);\n\n                        const interval = setInterval(() => {\n                            const channel = new MessageChannel();\n\n                            channel.port1.onmessage = () => {\n                                clearInterval(interval);\n                                clearTimeout(timeout);\n                                channel.port1.close();\n                                channel.port2.close();\n                                resolve(false);\n                            };\n                            window.postMessage(\n                                {\n                                    type: 'init',\n                                    appetizeClient: true,\n                                    version: VERSION,\n                                },\n                                '*',\n                                [channel.port2]\n                            );\n                            window.__appetize_postMessage = async (\n                                data,\n                                waitForResponse = false\n                            ) => {\n                                const channel = new MessageChannel();\n\n                                window.postMessage(data, '*', [channel.port2]);\n\n                                if (waitForResponse) {\n                                    return new Promise((resolve, reject) => {\n                                        const tm = setTimeout(() => {\n                                            reject(\n                                                new TimeoutError(\n                                                    'Timed out after 60000ms while waiting for postMessage response'\n                                                )\n                                            );\n                                        }, 60000);\n\n                                        channel.port1.onmessage = (ev) => {\n                                            clearTimeout(tm);\n                                            channel.port1.close();\n                                            channel.port2.close();\n                                            resolve(ev.data as any);\n                                        };\n                                    });\n                                } else {\n                                    channel.port1.close();\n                                    channel.port2.close();\n                                }\n                            };\n                        }, 100);\n                    });\n                },\n                [VERSION]\n            );\n\n            // call exposed function on client/session events\n            await this.page.evaluate(() => {\n                window.addEventListener('message', (event) => {\n                    if (event.source === window) {\n                        const eventType =\n                            typeof event.data === 'string'\n                                ? event.data\n                                : event.data?.type;\n\n                        switch (eventType) {\n                            // we'll get these from socket xdoc events directly.\n                            // save some bandwidth by not sending them twice\n                            case 'frameData':\n                            case 'recordedAction':\n                            case 'playbackFoundAndSent':\n                            case 'playbackNotFound':\n                            case 'debug':\n                            case 'interceptRequest':\n                            case 'interceptResponse':\n                            case 'interceptError':\n                            case 'uiDump':\n                                return;\n                        }\n\n                        window.__appetize_on(\n                            JSON.stringify(event.data, function (key, value) {\n                                // typed arrays will be serialized to normal arrays, so\n                                // we flag them as typed arrays for the parser to correctly convert them back\n                                // modified from https://gist.github.com/jonathanlurie/04fa6343e64f750d03072ac92584b5df\n                                if (\n                                    value instanceof Int8Array ||\n                                    value instanceof Uint8Array ||\n                                    value instanceof Uint8ClampedArray ||\n                                    value instanceof Int16Array ||\n                                    value instanceof Uint16Array ||\n                                    value instanceof Int32Array ||\n                                    value instanceof Uint32Array ||\n                                    value instanceof Float32Array ||\n                                    value instanceof Float64Array\n                                ) {\n                                    const replacement = {\n                                        constructor: value.constructor.name,\n                                        data: value.join(','),\n                                        flag: 'TYPED_ARRAY',\n                                    };\n                                    return replacement;\n                                }\n                                return value;\n                            })\n                        );\n                    }\n                });\n            }, []);\n        });\n\n        this.ready = true;\n    }\n\n    /**\n     * Waits for page to be loaded and ready for xdoc messages\n     */\n    async waitUntilReady() {\n        return waitFor(async () => {\n            if (!this.ready) {\n                throw new TimeoutError(\n                    `Timed out after 60000ms while waiting for Appetize window to be ready.`\n                );\n            }\n        }, 60000);\n    }\n\n    /**\n     * Sends a raw postMessage to the window\n     */\n    async postMessage<T>(data: any, waitForResponse = false) {\n        await this.waitUntilReady();\n        try {\n            return await this.testFixture.step('postMessage', async () =>\n                this.page.evaluate(\n                    async ([data, waitForResponse]) => {\n                        return window.__appetize_postMessage(\n                            data,\n                            waitForResponse\n                        ) as T;\n                    },\n                    [data, waitForResponse]\n                )\n            );\n        } catch (e) {\n            logger.error('Error sending postMessage: ', data);\n            throw e;\n        }\n    }\n}\n\nexport class PlaywrightSocket extends EventEmitter implements SocketProtocol {\n    page: Page;\n    type: 'webserver' | 'appetizer';\n    window: AppetizeWindow;\n\n    constructor({\n        page,\n        type,\n        window,\n    }: {\n        page: Page;\n        type: 'webserver' | 'appetizer';\n        window: AppetizeWindow;\n    }) {\n        super();\n        this.page = page;\n        this.type = type;\n        this.window = window;\n\n        this.window.on('*', ({ type, value }) => {\n            switch (type) {\n                case 'socketEvent':\n                    if (value.socket === this.type) {\n                        const socketEventType = value.type;\n                        const socketEventValue = value.value;\n\n                        this.emit(socketEventType, socketEventValue);\n                        this.emit('*', {\n                            type: socketEventType,\n                            value: socketEventValue,\n                        });\n                    }\n                    break;\n                case 'disconnect':\n                    this.emit('disconnect');\n                    this.emit('*', { type: 'disconnect' });\n                    break;\n\n                // map xdocs to appetizer events\n                case 'sessionInfo':\n                case 'chromeDevToolsUrl':\n                case 'orientationChanged':\n                case 'deviceInfo':\n                    if (this.type === 'appetizer') {\n                        this.emit(type, value);\n                        this.emit('*', { type, value });\n                    }\n                    break;\n\n                // map xdocs to client events\n                case 'sessionRequested':\n                    if (this.type === 'webserver') {\n                        this.emit(type, value);\n                        this.emit('*', { type, value });\n                    }\n                    break;\n            }\n        });\n    }\n\n    async send(event: string, data?: any) {\n        return this.window.postMessage<void>({\n            type: 'emitSocketEvent',\n            value: { type: event, value: data, socket: this.type },\n        });\n    }\n\n    async disconnect() {\n        await this.send('disconnect');\n    }\n\n    waitForEvent<T>(\n        event: string,\n        options: WaitForEventOptions<T>\n    ): Promise<T> {\n        return waitForEvent(this, event, options);\n    }\n}\n\ndeclare const window: Window & {\n    __appetize_postMessage: (\n        data: any,\n        waitForResponse?: boolean\n    ) => Promise<void>;\n    __appetize_on: (data: any) => void;\n};\n","import { Page } from '@playwright/test';\nimport type {\n    Action,\n    ElementSelector,\n    PlayActionErrorResponse,\n    PlayActionOptions,\n    PlayActionResult,\n    RecordedAction,\n} from '../../core/api/types/recorder';\nimport { FindElementsAction } from '../../core/api/types/recorder/internal';\nimport { OperationalError, captureOperationalError } from '../../core/errors';\nimport {\n    Session,\n    SessionArgs,\n    SessionConfig,\n    SessionEvents,\n} from '../../core/session';\nimport {\n    WaitForEventOptionsOrPredicate,\n    waitForEvent,\n    waitForTimeout,\n} from '../../core/waitFor';\nimport { Codegen } from './codegen';\nimport { logger } from './logger';\nimport { AppetizeWindow, PlaywrightSocket } from './socket';\nimport { AllUI } from '../../core/api/types/recorder/public';\nimport { AppetizeTestFixture } from './fixture';\n\ninterface ActionLog {\n    action: Action | RecordedAction;\n    result?: PlayActionResult;\n    payload?: any;\n    error?: PlayActionErrorResponse;\n    ui?: AllUI;\n}\n\nexport interface PlaywrightSessionEvents extends SessionEvents {}\n\nexport interface PlaywrightSessionConfig extends SessionConfig {\n    buildId?: string;\n\n    /**\n     * @deprecated use buildId instead\n     */\n    publicKey?: string;\n}\nexport class PlaywrightSession extends Session {\n    page: Page;\n    window: AppetizeWindow;\n    testFixture: AppetizeTestFixture;\n\n    config: SessionConfig;\n    protected actionLogs: Array<ActionLog> = [];\n\n    constructor({\n        page,\n        config,\n        window,\n        testFixture,\n        ...args\n    }: Omit<SessionArgs, 'socket' | 'logger'> & {\n        page: Page;\n        config: SessionConfig;\n        window: AppetizeWindow;\n        testFixture: AppetizeTestFixture;\n    }) {\n        const socket = new PlaywrightSocket({\n            page,\n            window,\n            type: 'appetizer',\n        });\n        super({ ...args, socket, config, logger });\n        this.window = window;\n        this.page = page;\n        this.config = config;\n        this.testFixture = testFixture;\n\n        // disconnect session on page navigation\n        // is there a better event to listen for? 'framenavigated' event fires too soon\n        this.page.on('load', () => {\n            this.emit('disconnect');\n        });\n\n        // Wrap our methods as steps to be shown in playwright trace\n        // with proper titles\n        this.adbShellCommand = this.wrapAsStep(this.adbShellCommand);\n        this.biometry = this.wrapAsStep(this.biometry);\n        this.findElement = this.wrapAsStep(this.findElement, {\n            subStepTitle: (selector) => JSON.stringify(selector),\n        });\n        this.findElements = this.wrapAsStep(this.findElements, {\n            subStepTitle: (selector) => JSON.stringify(selector),\n        });\n        this.getUI = this.wrapAsStep(this.getUI);\n        this.keypress = this.wrapAsStep(this.keypress, {\n            subStepTitle: (key) => JSON.stringify(key),\n        });\n        this.launchApp = this.wrapAsStep(this.launchApp, {\n            subStepTitle: (app) => JSON.stringify(app),\n        });\n        this.openUrl = this.wrapAsStep(this.openUrl, {\n            subStepTitle: (url) => JSON.stringify(url),\n        });\n        this.playAction = this.wrapAsStep(this.playAction, {\n            subStepTitle: (action) => JSON.stringify(action),\n        });\n        this.playActions = this.wrapAsStep(this.playActions, {\n            subStepTitle: (actions) => JSON.stringify(actions),\n        });\n        this.reinstallApp = this.wrapAsStep(this.reinstallApp);\n        this.restartApp = this.wrapAsStep(this.restartApp);\n        this.rotate = this.wrapAsStep(this.rotate, {\n            subStepTitle: (direction) => JSON.stringify(direction),\n        });\n        this.screenshot = this.wrapAsStep(this.screenshot);\n        this.setLanguage = this.wrapAsStep(this.setLanguage, {\n            subStepTitle: (language) => JSON.stringify(language),\n        });\n        this.setLocation = this.wrapAsStep(this.setLocation, {\n            subStepTitle: (location) => JSON.stringify(location),\n        });\n        this.shake = this.wrapAsStep(this.shake);\n        this.swipe = this.wrapAsStep(this.swipe, {\n            subStepTitle: (args) => JSON.stringify(args),\n        });\n        this.tap = this.wrapAsStep(this.tap, {\n            subStepTitle: (args) => JSON.stringify(args),\n        });\n        this.type = this.wrapAsStep(this.type, {\n            subStepTitle: (text) => JSON.stringify(text),\n        });\n        this.waitForAnimations = this.wrapAsStep(this.waitForAnimations);\n        this.waitForElement = this.wrapAsStep(this.waitForElement, {\n            subStepTitle: (selector) => JSON.stringify(selector),\n        });\n        this.waitForEvent = this.wrapAsStep(this.waitForEvent, {\n            title: (event) => `session.waitForEvent - ${JSON.stringify(event)}`,\n        });\n        this.waitForTimeout = this.wrapAsStep(this.waitForTimeout, {\n            title: (ms) => `session.waitForTimeout - ${JSON.stringify(ms)}`,\n        });\n    }\n\n    protected async addActionLog(log: ActionLog): Promise<void> {\n        if (log.error) {\n            const ui = await this.getUI().catch(this.logger.warn);\n\n            if (ui) {\n                log.ui = ui;\n            }\n        }\n\n        this.actionLogs.push(log);\n    }\n\n    async rotate(direction: 'left' | 'right') {\n        try {\n            const [orientation] = await Promise.all([\n                waitForEvent<'landscape' | 'portrait'>(\n                    this.window,\n                    'orientationChanged'\n                ),\n                // we need to use postmessage api so that embed knows which direction we rotated.\n                // otherwise, if we emit directly over the socket, frontend only knows that orientation changed\n                // from/to portrait/landscape, not the actual rotation in degrees\n                await this.window.postMessage(\n                    direction === 'left' ? 'rotateLeft' : 'rotateRight'\n                ),\n            ]);\n\n            this.window.page.waitForTimeout(1000);\n\n            return orientation;\n        } catch (e) {\n            captureOperationalError(e, this.rotate);\n            throw e;\n        }\n    }\n\n    async record() {\n        try {\n            if (!this.config.record) {\n                throw new OperationalError(\n                    'Recording is not enabled, please enable it by setting `record: true` in session config'\n                );\n            }\n\n            if (!this.testFixture) {\n                throw new OperationalError(\n                    'session.record() requires using `session` from the test() arguments'\n                );\n            }\n\n            const codegen = new Codegen({\n                session: this,\n                testInfo: this.testFixture.info(),\n            });\n\n            return codegen.record();\n        } catch (e) {\n            captureOperationalError(e, this.record);\n            throw e;\n        }\n    }\n\n    async waitForEvent<K extends keyof SessionEvents>(\n        event: K,\n        options?: WaitForEventOptionsOrPredicate<SessionEvents[K]>\n    ): Promise<SessionEvents[K]> {\n        try {\n            return await waitForEvent(this, event, options);\n        } catch (e) {\n            captureOperationalError(e, this.waitForEvent);\n            throw e;\n        }\n    }\n\n    async waitForTimeout(ms: number) {\n        try {\n            return await waitForTimeout(ms);\n        } catch (e) {\n            captureOperationalError(e, this.waitForTimeout);\n            throw e;\n        }\n    }\n\n    /**\n     * Waits for the element(s) to appear or else throws an error.\n     */\n    async waitForElement(\n        element: ElementSelector,\n        options?: PlayActionOptions<FindElementsAction> & {\n            /**\n             * The number of elements for this selector that should be returned\n             */\n            matches?: number;\n        }\n    ) {\n        try {\n            const elements = await this.findElements(element, options);\n\n            if (elements.length) {\n                if (options?.matches && elements.length !== options.matches) {\n                    throw new Error(\n                        `Expected ${options.matches} elements, found ${elements.length}`\n                    );\n                }\n\n                return elements;\n            } else {\n                throw new Error(\n                    `Element not found:\\n${JSON.stringify(element)}`\n                );\n            }\n        } catch (e) {\n            captureOperationalError(e, this.waitForElement);\n            throw e;\n        }\n    }\n\n    on<K extends keyof SessionEvents>(\n        event: K,\n        listener: (value: SessionEvents[K]) => void\n    ): this {\n        return super.on(event, listener);\n    }\n\n    once<K extends keyof SessionEvents>(\n        event: K,\n        listener: (value: SessionEvents[K]) => void\n    ): this {\n        return super.once(event, listener);\n    }\n\n    async getVideoFrames(): Promise<never[]> {\n        console.warn(\n            `getVideoFrames() is deprecated. Use session.on('video') event instead`\n        );\n        return [];\n    }\n\n    async getAudioFrames(): Promise<never[]> {\n        console.warn(\n            `getAudioFrames() is deprecated. Use session.on('audio') event instead`\n        );\n        return [];\n    }\n\n    // returns a bound version of the function that will run as a step\n    private wrapAsStep<T extends (...args: any[]) => any>(\n        fn: T,\n        options: {\n            title?: (...args: Parameters<T>) => string;\n\n            /**\n             * Playwright doesn't offer a great way to add additional detail like params,\n             * so we can add a substep title to provide more context when expanded and keep things clean.\n             */\n            subStepTitle?: (...args: Parameters<T>) => string;\n        } = {}\n    ) {\n        return (...args: Parameters<T>) => {\n            let title = `session.${fn.name}`;\n\n            if (options?.title) {\n                title = options.title(...args);\n            }\n\n            const subStepTitle = options?.subStepTitle?.(...args);\n\n            if (subStepTitle) {\n                return this.testFixture.step(\n                    title,\n                    () =>\n                        this.testFixture.step(subStepTitle, () =>\n                            fn.apply(this, args)\n                        ),\n                    { box: true }\n                );\n            } else {\n                return this.testFixture.step(\n                    title,\n                    () => fn.apply(this, args),\n                    { box: true }\n                );\n            }\n        };\n    }\n}\n","import { Page } from '@playwright/test';\nimport {\n    HeadfulClient,\n    HeadfulClientEvents,\n} from '../../core/client/headful-client';\nimport {\n    SessionConfig,\n    SessionInfo,\n    UserSessionConfig,\n} from '../../core/session';\nimport { logger } from './logger';\nimport { PlaywrightSession } from './session';\nimport { AppetizeWindow, PlaywrightSocket } from './socket';\nimport { AppetizeTestFixture } from './fixture';\n\n/**\n * AppetizeWindow can only be instantiated once per page,\n * so if a client is reinitialized a second time,\n * we need to reuse the window instance\n **/\nconst windows = new WeakMap<Page, AppetizeWindow>();\n\nexport class PlaywrightClient extends HeadfulClient<\n    PlaywrightSocket,\n    PlaywrightClientEvents,\n    PlaywrightSession\n> {\n    page: Page;\n    window!: AppetizeWindow;\n    testFixture: AppetizeTestFixture;\n\n    constructor({\n        page,\n        testFixture,\n    }: {\n        page: Page;\n        testFixture: AppetizeTestFixture;\n    }) {\n        const window =\n            windows.get(page) ?? new AppetizeWindow({ page, testFixture });\n        windows.set(page, window);\n\n        const socket = new PlaywrightSocket({\n            type: 'webserver',\n            page,\n            window,\n        });\n        super({ socket, window, logger, autoInit: false });\n        this.window = window;\n        this.page = page;\n        this.testFixture = testFixture;\n\n        let isInQueue = false;\n\n        this.on('queue', (queue) => {\n            if (!isInQueue) {\n                isInQueue = true;\n                if (queue.type === 'concurrent') {\n                    this.logger.log(\n                        `Entered ${queue.name}. Please wait until a slot becomes available.`\n                    );\n                } else {\n                    this.logger.log(\n                        `All devices are currently in use. Please wait until requested device becomes available.`\n                    );\n                }\n            }\n\n            if (queue.position > 0) {\n                if (queue.type === 'concurrent') {\n                    this.logger.log(\n                        `Position in ${queue.name}: ${queue.position}`\n                    );\n                } else {\n                    this.logger.log(`Position in queue: ${queue.position}`);\n                }\n            }\n        });\n\n        this.on('session', () => {\n            if (isInQueue) {\n                isInQueue = false;\n            }\n        });\n    }\n\n    async init() {\n        return this.testFixture.step('Initialize client', async () => {\n            await this.window.init();\n            await super.init();\n        });\n    }\n    protected validateConfig(config: UserSessionConfig) {\n        const browserType = this.page.context().browser()?.browserType().name();\n        return {\n            codec: browserType === 'chromium' ? 'jpeg' : 'h264',\n            ...config,\n        };\n    }\n\n    protected createSession(config: SessionConfig, sessionInfo: SessionInfo) {\n        this.session = new PlaywrightSession({\n            config,\n            page: this.page,\n            window: this.window,\n            path: sessionInfo.path,\n            token: sessionInfo.token,\n            device: this.device,\n            app: this.app,\n            testFixture: this.testFixture,\n        });\n\n        return this.session;\n    }\n}\n\nexport interface PlaywrightClientEvents\n    extends HeadfulClientEvents<PlaywrightSession> {}\n","import { Page } from '@playwright/test';\nimport { SessionConfig } from '../../core/session';\nimport { retry } from '../../core/util';\nimport { PlaywrightClient } from './client';\nimport { PlaywrightSession, PlaywrightSessionConfig } from './session';\nimport { queryString } from '../../core/util';\nimport { HeadfulDeviceInfo } from '../../core/client/headful-client';\nimport {\n    PlayActionResult,\n    PlayActionErrorResponse,\n} from '../../core/api/types/recorder';\nimport { AppetizeTestFixture } from './fixture';\n\nexport class AppetizePage {\n    readonly page: Page;\n    readonly testFixture: AppetizeTestFixture;\n\n    session?: PlaywrightSession;\n    client!: PlaywrightClient;\n    queueStart: number | null = null;\n    queueEnd: number | null = null;\n    config: PlaywrightSessionConfig;\n    baseURL = 'https://appetize.io';\n\n    sessionDebugInfo = {\n        playedActions: [] as ActionLog[],\n        videoFrames: [] as Array<{\n            buffer: Uint8Array;\n            codec: 'h264' | 'jpeg';\n        }>,\n        audioFrames: [] as Array<{ buffer: Uint8Array; codec: 'aac' }>,\n        debugLogs: [] as string[],\n    };\n\n    constructor(args: {\n        page: Page;\n        testFixture: AppetizeTestFixture;\n        config: PlaywrightSessionConfig;\n        baseURL?: string;\n    }) {\n        this.page = args.page;\n        this.testFixture = args.testFixture;\n        this.config = {\n            ...args.config,\n            buildId: args.config.buildId ?? args.config.publicKey,\n            // only define publicKey if it's set\n            ...(args.config.publicKey\n                ? { publicKey: args.config.publicKey }\n                : {}),\n        };\n\n        if (args.baseURL) {\n            this.baseURL = args.baseURL;\n        }\n    }\n\n    get queueTime() {\n        if (this.queueStart) {\n            return (this.queueEnd ?? Date.now()) - this.queueStart;\n        }\n\n        return null;\n    }\n\n    async init() {\n        const params = {};\n\n        for (const key in this.config) {\n            switch (key) {\n                case 'device':\n                case 'osVersion':\n                case 'scale':\n                case 'orientation':\n                    params[key] = this.config[key];\n                    break;\n            }\n        }\n\n        const pageRes = await this.page.goto(\n            `${this.baseURL}/embed/${this.config.buildId}?${queryString(\n                params\n            )}`\n        );\n\n        if (pageRes?.status() === 404) {\n            const label = this.config.publicKey ? 'publicKey' : 'buildId';\n            throw new Error(\n                `App not found for ${label} \"${\n                    this.config.publicKey ?? this.config.buildId\n                }\"`\n            );\n        }\n\n        this.client = new PlaywrightClient({\n            page: this.page,\n            testFixture: this.testFixture,\n        });\n\n        await this.client.init();\n    }\n\n    async start(args: { config: SessionConfig }) {\n        this.queueStart = null;\n        this.queueEnd = null;\n\n        this.client.on('queue', () => {\n            if (!this.queueStart) {\n                this.queueStart = Date.now();\n            }\n        });\n\n        this.client.on('queueEnd', () => {\n            if (this.queueStart) {\n                this.queueEnd = Date.now();\n            }\n        });\n\n        const resizeToDevice = async (info?: HeadfulDeviceInfo) => {\n            if (info?.embed) {\n                await this.page.setViewportSize({\n                    // add some padding to prevent scrollbars from showing on chromium\n                    width: info.embed.width + 8,\n                    height: info.embed.height + 8,\n                });\n            }\n        };\n        this.client.on('deviceInfo', resizeToDevice);\n\n        await this.client.waitUntilReady();\n\n        // set initial size\n        if (this.client.device) {\n            resizeToDevice(this.client.device);\n        }\n\n        const session = await retry(\n            () => this.client.startSession(args.config),\n            {\n                retries: 5,\n                timeout: 30000,\n                predicate: (e, attempt) => {\n                    if (\n                        e instanceof Error &&\n                        e.message.match(/too many requests/)\n                    ) {\n                        console.warn(\n                            `Too many session requests. Retrying in 30 seconds... (attempt #${attempt})`\n                        );\n                        return true;\n                    }\n\n                    return false;\n                },\n            }\n        );\n\n        this.config = session.config;\n\n        // startSession resolves slightly after stream has started, so request a keyframe\n        this.requestKeyFrame();\n\n        if (session.config.debug === true) {\n            session.on('log', (value) => {\n                this.sessionDebugInfo.debugLogs.push(value.message);\n            });\n        }\n\n        session.on('playbackFoundAndSent', (value) => {\n            this.sessionDebugInfo.playedActions.push(value);\n        });\n\n        session.on('playbackError', (value) => {\n            this.sessionDebugInfo.playedActions.push(value);\n        });\n\n        session.on('video', (frame) => {\n            this.sessionDebugInfo.videoFrames.push(frame);\n        });\n\n        session.on('audio', (frame) => {\n            this.sessionDebugInfo.audioFrames.push(frame);\n        });\n\n        session.on('end', () => {\n            this.session = undefined;\n        });\n\n        this.session = session;\n\n        return session;\n    }\n\n    onTestStart() {\n        this.clearSessionDebugInfo();\n        this.requestKeyFrame();\n    }\n\n    private clearSessionDebugInfo() {\n        this.sessionDebugInfo.playedActions = [];\n        this.sessionDebugInfo.videoFrames = [];\n        this.sessionDebugInfo.audioFrames = [];\n        this.sessionDebugInfo.debugLogs = [];\n    }\n\n    private requestKeyFrame() {\n        if (this.session) {\n            this.testFixture.step(/* hidden step */ '', async () => {\n                return (\n                    this.session?.socket\n                        .send('requestKeyFrame')\n                        // don't log error if this fails\n                        .catch(() => {})\n                );\n            });\n        }\n    }\n}\n\ntype ActionLog = PlayActionErrorResponse | PlayActionResult;\n","import { exec } from 'child_process';\nimport { _android as android } from 'playwright-core';\nimport { promisify } from 'util';\nimport { PlaywrightSession } from './session';\nimport { AndroidDevice, TestInfo } from '@playwright/test';\nimport fs from 'fs';\nimport { logger } from './logger';\n\nconst execAsync = promisify(exec);\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\n\n/**\n * Create a Chrome browser page on an Appetize Android device.\n * Pre-requisites:\n * - Session must be configured with `enableAdb: true`.\n * - Must have the [adb daemon](https://developer.android.com/studio/command-line/adb) installed & running.\n * - No other connected devices.\n *\n * @param session The Appetize Playwright session\n * @param testInfo The test info object\n * @returns the running Chrome Browser page, BrowserContext, and Android device.\n */\nexport async function createAndroidDeviceBrowserPage(\n    session: PlaywrightSession,\n    testInfo: TestInfo\n) {\n    const adbInfo = session.adbConnection;\n    const host = 'localhost';\n    const port = 6000;\n\n    if (!adbInfo) {\n        throw new Error(\n            'ADB connection info not found. Session must be configured with `enableAdb: true`'\n        );\n    }\n\n    await checkAdbInstalled();\n\n    // Disconnect any existing ADB connections\n    try {\n        await execAsync(`adb disconnect ${host}:${port}`);\n    } catch (e) {\n        // no-op\n    }\n\n    const sshCmd = `ssh -fN -o StrictHostKeyChecking=no -oHostKeyAlgorithms=+ssh-rsa -p ${adbInfo.port} ${adbInfo.user}@${adbInfo.hostname} -L${port}:${adbInfo.forwards[0].destination}:${adbInfo.forwards[0].port}`;\n    const sshOutput = await execAsync(sshCmd);\n\n    if (sshOutput.stdout) {\n        logger.error(sshOutput.stdout);\n    }\n\n    if (sshOutput.stderr) {\n        logger.error(sshOutput.stderr);\n    }\n\n    const adbCmd = `adb connect ${host}:${port}`;\n    const adbOutput = await execAsync(adbCmd);\n\n    if (adbOutput.stdout) {\n        logger.error(adbOutput.stdout);\n    }\n\n    if (adbOutput.stderr) {\n        logger.error(adbOutput.stderr);\n    }\n\n    // Connect to the Android device\n    const device = await android\n        .devices()\n        .then((devices) =>\n            devices.find((device) => device.serial() === `${host}:${port}`)\n        );\n\n    if (!device) {\n        throw new Error(`Device ${host}:${port} not found`);\n    }\n\n    logger.debug(\n        `Connected to device ${device.model()} with serial ${device.serial()}`\n    );\n\n    // launchBrowser overwrites the command line file, so we need to read\n    // what is there before launching the browser and pass it into the args option\n    const flags = await getExistingChromeCommandLineFlags(testInfo);\n\n    const browserContext = await device.launchBrowser({\n        args: flags,\n    });\n\n    // launchBrowser removes the cmd line file afterwards, so we want to restore our original incase\n    // the browser is restarted\n    await pushChromeCommandLine(testInfo, `chrome ${flags.join(' ')}`);\n\n    const pages = browserContext.pages();\n\n    // use existing page if available. it seems there is no difference in either using\n    // this page or calling newPage(), but sometimes newPage() throws an error which\n    // (might just be a playwright bug w/ android)\n    if (pages[0]) {\n        return {\n            page: pages[0],\n            browserContext,\n            device,\n        };\n    }\n\n    const page = await browserContext.newPage();\n    return { page, browserContext, device };\n}\n\n/**\n * Disconnects and closes the running Android device.\n * @param device Device to disconnect\n */\nexport async function disconnectAndroidDevice(device: AndroidDevice) {\n    await device.close();\n    await execAsync(`adb disconnect ${device.serial()}`);\n}\n\nasync function getExistingChromeCommandLineFlags(\n    testInfo: TestInfo\n): Promise<string[]> {\n    const testOutputDir = testInfo.outputPath();\n    const pulledPath = testInfo.outputPath('chrome-command-line');\n\n    const chromeCommandLinePath = '/data/local/tmp/chrome-command-line';\n\n    let flags: string[] = [];\n\n    // get the file if it exists\n    try {\n        await execAsync(`adb pull ${chromeCommandLinePath} ${testOutputDir}`);\n        const file = await readFileAsync(pulledPath, 'utf-8');\n\n        if (file) {\n            const flagsString = file.split('chrome ').at(1);\n\n            if (flagsString) {\n                flags = flagsString.split(' ') || [];\n            }\n        }\n\n        // the permissions for this file on our emulator will prevent playwright from writing to it,\n        // but we can work around it by pushing it and that will correct the permissions\n        await execAsync(`adb push ${pulledPath} ${chromeCommandLinePath}`);\n    } catch (e) {\n        // no-op\n    }\n\n    return flags;\n}\n\nasync function pushChromeCommandLine(testInfo: TestInfo, content: string) {\n    const pulledPath = testInfo.outputPath('chrome-command-line');\n\n    const chromeCommandLinePath = '/data/local/tmp/chrome-command-line';\n\n    try {\n        await writeFileAsync(pulledPath, content);\n        await execAsync(`adb push ${pulledPath} ${chromeCommandLinePath}`);\n    } catch (e) {\n        logger.error('Error pushing chrome-command-line file', e);\n    }\n}\n\nasync function checkAdbInstalled() {\n    try {\n        await execAsync('adb version');\n    } catch (e) {\n        throw new Error(\n            'ADB is not installed or not found in PATH. Please install ADB and ensure it is accessible.'\n        );\n    }\n}\n","import {\n    BrowserContext,\n    PlaywrightTestArgs,\n    PlaywrightTestOptions,\n    PlaywrightWorkerArgs,\n    PlaywrightWorkerOptions,\n    test as base,\n    TestInfo,\n    TestType,\n} from '@playwright/test';\nimport { PlaywrightClient } from './client';\nimport './expect';\nimport { PlaywrightSession, PlaywrightSessionConfig } from './session';\nimport { AppetizePage } from './appetize-page';\nimport { logger } from './logger';\nimport fs from 'fs';\nimport JMuxer from 'jmuxer';\nimport { Readable } from 'stream';\nimport os from 'os';\nimport path from 'path';\nimport {\n    createAndroidDeviceBrowserPage,\n    disconnectAndroidDevice,\n} from './device-browser-page';\n\nexport interface AppetizeTestOptions extends PlaywrightTestOptions {\n    /**\n     * The session config to use for the tests\n     */\n    config: Partial<PlaywrightSessionConfig>;\n}\n\ninterface TestArgs extends PlaywrightTestArgs, AppetizeTestOptions {\n    appetizePage: AppetizePage;\n    session: PlaywrightSession;\n    client: PlaywrightClient;\n}\n\ninterface WorkerArgs extends PlaywrightWorkerArgs, PlaywrightWorkerOptions {\n    _browserContext: BrowserContext;\n}\n\nlet appetizePage: AppetizePage | null = null;\nlet lastConfig: Partial<PlaywrightSessionConfig> | null = null;\n\nconst _test = base.extend<\n    TestArgs & {\n        _autoSnapshotSuffix: void;\n        _doSetupAndTeardown: void;\n        _useConfig: Partial<PlaywrightSessionConfig>;\n    },\n    WorkerArgs\n>({\n    // shallow merges _useConfig with project.use.config\n    config: [\n        async ({ _useConfig }, use, testInfo) => {\n            const config = {\n                ...(testInfo.project.use as AppetizeTestOptions).config,\n                ..._useConfig,\n                autoplay: false,\n            };\n\n            // handle configs with publicKey\n            if ('publicKey' in config && !!config.publicKey) {\n                if ('buildId' in config && !!config.buildId) {\n                    logger.warn(\n                        `Both \"buildId\" (\"${config.buildId}\") and \"publicKey\" (\"${config.publicKey}\") were defined in the test config. Using buildId.`\n                    );\n                    config.publicKey = config.buildId;\n                } else {\n                    config.buildId = config.publicKey;\n                }\n            }\n\n            await use(config);\n        },\n        { auto: true },\n    ],\n\n    async page({ context, config, baseURL }, use, testInfo) {\n        if (isAppetize(testInfo)) {\n            appetizePage ??= await setupAppetizePage(context, config, baseURL);\n            const session = await setupSession(appetizePage, config);\n            if (session.config.platform !== 'android') {\n                throw new Error(\n                    'Appetize browser tests are currently only supported on Android devices.'\n                );\n            }\n            const { page, browserContext, device } =\n                await createAndroidDeviceBrowserPage(session, testInfo);\n            try {\n                await use(page);\n                await browserContext.close();\n            } finally {\n                await disconnectAndroidDevice(device);\n            }\n            return;\n        }\n        const newPage = await context.newPage();\n        await use(newPage);\n    },\n\n    async appetizePage({ context, config, baseURL }, use, testInfo) {\n        if (!isAppetize(testInfo)) {\n            throw new Error(\n                'Appetize config not found in test. Either define it in the Playwright project or with test.use({ config: { ... } })'\n            );\n        }\n\n        if (appetizePage) {\n            const { session, page } = appetizePage;\n            if (session) {\n                let shouldClose = false;\n                if (lastConfig) {\n                    for (const key in config) {\n                        if (\n                            JSON.stringify(lastConfig[key]) !==\n                            JSON.stringify(config[key])\n                        ) {\n                            shouldClose = true;\n                            break;\n                        }\n                    }\n                } else {\n                    shouldClose = true;\n                }\n\n                if (shouldClose) {\n                    if (session) {\n                        await session.end().catch(() => {});\n                    }\n                    await page.close();\n                    appetizePage = null;\n                }\n            }\n        }\n\n        if (!appetizePage) {\n            appetizePage = await setupAppetizePage(context, config, baseURL);\n        }\n\n        lastConfig = config;\n        await use(appetizePage);\n    },\n    async session({ appetizePage, config, _doSetupAndTeardown }, use) {\n        // referencing this in the fixture will trigger\n        // our setup and teardown behavior\n        // for both passes and fails\n        _doSetupAndTeardown;\n        const session = await setupSession(appetizePage, config);\n        await use(session);\n    },\n    async client({ appetizePage }, use) {\n        await use(appetizePage.client);\n    },\n\n    // test.use({ config }) will write to this\n    _useConfig: [{}, { option: true }],\n\n    // trim platform (of computer) from snapshot suffix\n    _autoSnapshotSuffix: [\n        async ({}, use, testInfo) => {\n            testInfo.snapshotSuffix = '';\n            await use();\n        },\n        { auto: true },\n    ],\n\n    _doSetupAndTeardown: [\n        async ({ appetizePage }, use, testInfo) => {\n            logger.clearLogHistory();\n\n            if (appetizePage) {\n                appetizePage.onTestStart();\n            }\n\n            await use();\n\n            try {\n                // incase test.afterEach() wasn't called because user never made a test.afterEach()\n                await saveAttachmentsOnFail({ appetizePage, testInfo });\n            } catch (e) {\n                logger.error(`Failed to save attachments`, e);\n            }\n\n            if (testInfo.status === 'timedOut') {\n                if (appetizePage.queueTime) {\n                    logger.error(\n                        `Test timed out while in queue for a device. You may increase your test timeout to account for higher queue times.`\n                    );\n                }\n            }\n\n            try {\n                removeHiddenSteps(testInfo);\n            } catch (e) {\n                // no-op if this breaks\n            }\n        },\n        { auto: false },\n    ],\n    context: [\n        async ({ _browserContext, video, contextOptions }, use) => {\n            // warn about video recording\n            if (video && video !== 'off') {\n                logger.warn.once(\n                    `Video recording is not yet supported with @appetize/playwright. Use tracing instead to view recordings of your tests https://docs.appetize.io/javascript-sdk/playwright/trace-viewer`\n                );\n            }\n\n            // warn about context options\n            if (Object.keys(contextOptions).length) {\n                logger.warn.once(\n                    `contextOptions are not supported with @appetize/playwright`\n                );\n            }\n\n            await use(_browserContext);\n        },\n        {\n            scope: 'test',\n        },\n    ],\n    // we want the context to last across all tests\n    _browserContext: [\n        async ({ browser }, use) => {\n            const context = await browser.newContext();\n            await use(context);\n            await context.close();\n        },\n        {\n            scope: 'worker',\n        },\n    ],\n});\n\n// maps test.use({ config: ... }) to write to _useConfig, which will get merged with project.use.config\n// output as config in the test args\nconst makeUse = (test: TestType<TestArgs, WorkerArgs>) => {\n    const use = test.use;\n    return (options: AppetizeTestOptions) => {\n        const { config, ...rest } = options;\n        return use({\n            ...rest,\n            // @ts-ignore\n            _useConfig: config,\n        });\n    };\n};\n\n// when a test fails, we want to immediately gather data (screenshots, video, etc)\n// from the session. afterEach() will always run *after* fixture teardowns, so we need\n// to insert our own. (see https://playwright.dev/docs/test-fixtures#execution-order)\nconst makeAfterEach = (test: TestType<TestArgs, WorkerArgs>) => {\n    const afterEach = test.afterEach;\n    return (fn: any) => {\n        afterEach(async ({ appetizePage }, testInfo) => {\n            if (appetizePage) {\n                try {\n                    await saveAttachmentsOnFail({ appetizePage, testInfo });\n                } catch (e) {\n                    logger.error(`Failed to save attachments`, e);\n                }\n            }\n        });\n\n        return afterEach(fn);\n    };\n};\n\nconst makeExtend = (test: TestType<TestArgs, WorkerArgs>) => {\n    const extend = test.extend;\n    return (options: any) => {\n        const extended = extend(options);\n\n        // we need to re-wrap the extended fixture\n        extended.afterEach = makeAfterEach(extended).bind(extended);\n        extended.use = makeUse(extended).bind(extended);\n        extended.extend = makeExtend(extended).bind(extended) as any;\n\n        return extended;\n    };\n};\n\nObject.assign(_test, {\n    use: makeUse(_test),\n    afterEach: makeAfterEach(_test),\n    extend: makeExtend(_test),\n    setup(\n        this: TestType<TestArgs, WorkerArgs>,\n        options: AppetizeTestOptions['config']\n    ) {\n        if (!process.env.__APPETIZE__SETUP_WARNED) {\n            logger.warn(\n                `test.setup() is deprecated and will be removed in a future release. Use test.use({ config: {...} }) instead`\n            );\n            process.env.__APPETIZE__SETUP_WARNED = 'true';\n        }\n\n        return test.use({ config: options });\n    },\n});\n\nexport const test = _test as TestType<TestArgs, WorkerArgs>;\n\nexport type AppetizeTestFixture = typeof test;\n\nconst outputCache = new WeakMap();\n\nasync function saveAttachmentsOnFail(args: {\n    appetizePage: AppetizePage;\n    testInfo: TestInfo;\n}) {\n    const { appetizePage, testInfo } = args;\n\n    const session = appetizePage.session;\n\n    const shouldSaveOutput =\n        testInfo.status === 'failed' ||\n        testInfo.status === 'timedOut' ||\n        testInfo.status === 'interrupted';\n\n    // i don't know why, but fixture teardowns will run after beforeAll with testInfo.status = 'pass'\n    // so return early if we're not in a failed state (we only want the output data on fail anyway)\n    if (!shouldSaveOutput) return;\n\n    // this may get called multiple times, bail if we've already saved output\n    if (outputCache.get(testInfo.fn)) return;\n    outputCache.set(testInfo.fn, true);\n\n    const tmpDir = path.join(\n        os.tmpdir(),\n        `appetize-playwright-${testInfo.testId}-${testInfo.workerIndex}`\n    );\n\n    const removeTmpDir = async () => {\n        if (fs.existsSync(tmpDir)) {\n            await fs.promises\n                .rm(tmpDir, {\n                    recursive: true,\n                    force: true,\n                })\n                .catch(() => {\n                    // noop\n                });\n        }\n    };\n\n    try {\n        // remove dir if it already exists\n        await removeTmpDir();\n\n        await fs.promises.mkdir(tmpDir);\n        const actionLogs = appetizePage.sessionDebugInfo.playedActions;\n\n        const saveScreenshot = async () => {\n            try {\n                if (session) {\n                    const screenshot = await session.screenshot('buffer');\n                    const screenshotPath = path.join(tmpDir, 'screenshot.png');\n                    await fs.promises.writeFile(\n                        screenshotPath,\n                        Buffer.from(screenshot.data)\n                    );\n                    await testInfo.attach('screenshot', {\n                        path: screenshotPath,\n                        contentType: 'image/png',\n                    });\n                }\n            } catch (e) {\n                logger.error(\n                    `Failed to attach screenshot.png`,\n                    e instanceof Error ? e.message : undefined\n                );\n            }\n        };\n\n        const saveActions = async () => {\n            try {\n                const actions = actionLogs.map((log) => {\n                    if ('screenshot' in log) {\n                        const { screenshot, ...r } = log;\n                        return r;\n                    }\n\n                    return log;\n                });\n\n                if (!actions.length) {\n                    return;\n                }\n\n                const content = JSON.stringify(actions, null, 2);\n                const actionsPath = path.join(tmpDir, 'actions.json');\n\n                await fs.promises.writeFile(actionsPath, content);\n                await testInfo.attach('actions', {\n                    path: actionsPath,\n                    contentType: 'application/json',\n                });\n            } catch (e) {\n                logger.error(\n                    `Failed to attach actions.json`,\n                    e instanceof Error ? e.message : undefined\n                );\n            }\n        };\n\n        const saveH264Video = async () => {\n            try {\n                // NOTE: we currently cannot mux in audio due to lack of timestamps, the tracks wouldnt be in sync\n                const { videoFrames } = appetizePage.sessionDebugInfo;\n\n                if (\n                    videoFrames.length === 0 ||\n                    videoFrames.some((f) => f.codec !== 'h264')\n                ) {\n                    return;\n                }\n\n                const mode = 'video';\n\n                const jmuxer = new JMuxer(\n                    // @ts-expect-error - bad 3rd party types\n                    {\n                        mode,\n                        fps: 15,\n                    }\n                );\n\n                const mp4 = await new Promise<Buffer>((res, rej) => {\n                    const tm = setTimeout(() => {\n                        rej(new Error('Timed out muxing session video'));\n                    }, 30000);\n\n                    const reader = new Readable({\n                        objectMode: true,\n                        read() {},\n                    });\n\n                    const video = Buffer.concat(\n                        videoFrames.map((frame) => Buffer.from(frame.buffer))\n                    );\n\n                    reader.push({ video });\n                    reader.push(null);\n\n                    let mp4 = Buffer.from([]);\n\n                    reader\n                        .pipe(jmuxer.createStream())\n                        .on('data', (d) => {\n                            mp4 = Buffer.concat([mp4, d]);\n                        })\n                        .on('error', (e) => {\n                            clearTimeout(tm);\n                            rej(e);\n                        })\n                        .on('end', () => {\n                            clearTimeout(tm);\n                            res(mp4);\n                        });\n                });\n\n                const mp4Path = path.join(tmpDir, 'video.mp4');\n\n                await fs.promises.writeFile(mp4Path, mp4);\n\n                await testInfo.attach('video.mp4', {\n                    path: mp4Path,\n                    contentType: 'video/mp4',\n                });\n            } catch (e) {\n                logger.error(\n                    `Failed to attach video.mp4`,\n                    e instanceof Error ? e.message : undefined\n                );\n            }\n        };\n\n        const saveSDKLogs = async () => {\n            if (!logger.logHistory.length) {\n                return;\n            }\n\n            try {\n                const content = `${logger.logHistory\n                    .map(\n                        (log) =>\n                            `[${log.method}] ${JSON.stringify(log.data).slice(\n                                2,\n                                -2\n                            )}`\n                    )\n                    .join('\\n')}`;\n\n                const logsPath = path.join(tmpDir, 'sdk-logs.txt');\n\n                await fs.promises.writeFile(logsPath, content);\n                await testInfo.attach('sdk-logs', {\n                    path: logsPath,\n                    contentType: 'application/text',\n                });\n            } catch (e) {\n                logger.error(`Failed to attach sdk-logs.txt`, e);\n            }\n        };\n\n        const saveDebugLogs = async () => {\n            const { debugLogs } = appetizePage.sessionDebugInfo;\n            if (debugLogs.length > 0) {\n                try {\n                    const content = debugLogs.join(''); // logs include \\n already\n\n                    const logsPath = path.join(tmpDir, 'debug-logs.txt');\n\n                    await fs.promises.writeFile(logsPath, content);\n                    await testInfo.attach('debug-logs', {\n                        path: logsPath,\n                        contentType: 'application/text',\n                    });\n                } catch (e) {\n                    logger.error(`Failed to attach debug-logs.txt`, e);\n                }\n            }\n        };\n\n        const saveSession = async () => {\n            try {\n                if (appetizePage.session) {\n                    const infoPath = path.join(tmpDir, 'session.json');\n                    const content = JSON.stringify(\n                        {\n                            path: appetizePage.session.path,\n                            token: appetizePage.session.token,\n                            config: appetizePage.session.config,\n                        },\n                        null,\n                        2\n                    );\n\n                    await fs.promises.writeFile(infoPath, content);\n                    await testInfo.attach('session', {\n                        path: infoPath,\n                        contentType: 'application/json',\n                    });\n                }\n            } catch (e) {\n                logger.error(`Failed to attach session.json`, e);\n            }\n        };\n\n        await Promise.all([\n            saveScreenshot(),\n            saveActions(),\n            saveH264Video(),\n            saveDebugLogs(),\n            saveSession(),\n        ]);\n\n        // make sure we save sdk logs last, so we can capture any error messages from the above\n        await saveSDKLogs();\n    } finally {\n        await removeTmpDir();\n    }\n}\n\n/**\n * Remove hidden steps from the test info object\n *\n * Playwright does not support hidden steps so we use empty titles to mark a hidden step. This\n * is mainly used for socket messages (sent using page.evaluate) that aren't relevant to the test (requestKeyFrame, etc)\n */\nfunction removeHiddenSteps(parent) {\n    const steps = parent.steps || parent._steps;\n\n    if (!steps) {\n        return;\n    }\n\n    steps.forEach((step, i) => {\n        if (step.title === '') {\n            steps.splice(i, 1);\n        }\n        removeHiddenSteps(step);\n    });\n}\n\n/**\n * Check if the project is using Appetize\n * @param testInfo The test info object\n */\nfunction isAppetize(testInfo: TestInfo): boolean {\n    return !!(testInfo.project.use as AppetizeTestOptions).config;\n}\n\nasync function setupAppetizePage(\n    context: BrowserContext,\n    config: Partial<PlaywrightSessionConfig>,\n    baseURL: string | undefined\n) {\n    if (!config.buildId) {\n        throw new Error(\n            'Appetize buildId not set. Make sure you have set it with `test.use({ config: { buildId: \"...\" } })` or in your Playwright config file.'\n        );\n    }\n\n    const appetizePage = new AppetizePage({\n        page: await context.newPage(),\n        testFixture: test,\n        config,\n        baseURL,\n    });\n\n    await appetizePage.init();\n    return appetizePage;\n}\n\nasync function setupSession(\n    appetizePage: AppetizePage,\n    config: Partial<PlaywrightSessionConfig>\n) {\n    let session = appetizePage.session;\n    if (!session) {\n        session = await test.step(\n            'Start Appetize session',\n            async () => {\n                await appetizePage.start({ config });\n\n                if (appetizePage.queueTime) {\n                    test.info().annotations.push({\n                        type: 'queueTime',\n                        description: `${appetizePage.queueTime}ms`,\n                    });\n                }\n\n                if (!appetizePage.session) {\n                    throw new Error('Appetize session failed to start');\n                }\n\n                return appetizePage.session;\n            },\n            { box: true }\n        );\n\n        test.info().annotations.push({\n            type: 'Appetize Documentation',\n            description: 'https://docs.appetize.io/testing',\n        });\n    }\n\n    session.testFixture = test;\n    return session;\n}\n"],"names":["BaseEventEmitter","bounds","attributes","accessibilityElements","_a","logger","window","path","data","line","value","VERSION","channel","resolve","reject","waitForResponse","type","args","android","device","base","appetizePage","test","mp4"],"mappings":"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"}