import { Page } from '@playwright/test';
import type { Action, ElementSelector, PlayActionErrorResponse, PlayActionOptions, PlayActionResult, RecordedAction } from '../../core/api/types/recorder';
import { FindElementsAction } from '../../core/api/types/recorder/internal';
import { Session, SessionArgs, SessionConfig, SessionEvents } from '../../core/session';
import { WaitForEventOptionsOrPredicate } from '../../core/waitFor';
import { AppetizeWindow } from './socket';
import { AllUI } from '../../core/api/types/recorder/public';
import { AppetizeTestFixture } from './fixture';
interface ActionLog {
    action: Action | RecordedAction;
    result?: PlayActionResult;
    payload?: any;
    error?: PlayActionErrorResponse;
    ui?: AllUI;
}
export interface PlaywrightSessionEvents extends SessionEvents {
}
export interface PlaywrightSessionConfig extends SessionConfig {
    buildId?: string;
    publicKey?: string;
}
export declare class PlaywrightSession extends Session {
    page: Page;
    window: AppetizeWindow;
    testFixture: AppetizeTestFixture;
    config: SessionConfig;
    protected actionLogs: Array<ActionLog>;
    constructor({ page, config, window, testFixture, ...args }: Omit<SessionArgs, 'socket' | 'logger'> & {
        page: Page;
        config: SessionConfig;
        window: AppetizeWindow;
        testFixture: AppetizeTestFixture;
    });
    protected addActionLog(log: ActionLog): Promise<void>;
    rotate(direction: 'left' | 'right'): Promise<"portrait" | "landscape">;
    record(): Promise<void>;
    waitForEvent<K extends keyof SessionEvents>(event: K, options?: WaitForEventOptionsOrPredicate<SessionEvents[K]>): Promise<SessionEvents[K]>;
    waitForTimeout(ms: number): Promise<unknown>;
    waitForElement(element: ElementSelector, options?: PlayActionOptions<FindElementsAction> & {
        matches?: number;
    }): Promise<import("../../core/api/types/recorder").Element[]>;
    on<K extends keyof SessionEvents>(event: K, listener: (value: SessionEvents[K]) => void): this;
    once<K extends keyof SessionEvents>(event: K, listener: (value: SessionEvents[K]) => void): this;
    getVideoFrames(): Promise<never[]>;
    getAudioFrames(): Promise<never[]>;
    private wrapAsStep;
}
export {};
