{"version":3,"file":"index.umd.js","sources":["../src/expect.ts","../../core/util.ts","../../core/logger.ts","../../core/EventEmitter.ts","../../core/errors.ts","../../core/api/parser.ts","../../core/api/mappers/element.ts","../../core/api/mappers/action.ts","../../core/api/mappers/event.ts","../../core/api/mappers/client-socket.ts","../../core/client/client.ts","../../core/waitFor.ts","../../core/config.ts","../../core/client/headful-client.ts","../src/logger.ts","../../core/buffer.ts","../../core/builders/swipe-gesture.ts","../../core/api/mappers/session-socket.ts","../../core/session/session.ts","../src/codegen/pause.ts","../../core/keys.ts","../src/codegen/index.ts","../../core/constants.ts","../src/socket.ts","../src/session.ts","../src/client.ts","../src/appetize-page.ts","../src/device-browser-page.ts","../src/fixture.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-namespace */\nimport { expect } from '@playwright/test';\nimport {\n    Element,\n    ElementSelector,\n    FindElementsAction,\n    PlayActionOptions,\n} from '../../core/api/types/recorder';\nimport { PlaywrightSession } from './session';\n\ndeclare global {\n    namespace PlaywrightTest {\n        interface Matchers<R> {\n            toHaveElement(\n                selector: ElementSelector,\n                options?: ToHaveElementOptions\n            ): Promise<R>;\n        }\n    }\n}\n\ninterface ToHaveElementOptions extends PlayActionOptions<FindElementsAction> {\n    /**\n     * The number of elements for this selector that should be returned\n     */\n    matches?: number;\n}\n\nexpect.extend({\n    toHaveElement: async (\n        session: PlaywrightSession,\n        element: Element,\n        options: ToHaveElementOptions = {}\n    ) => {\n        try {\n            const elements = await session.findElements(element, options);\n\n            const pass =\n                typeof options.matches === 'number'\n                    ? elements.length === options.matches\n                    : elements.length > 0;\n\n            return {\n                pass,\n                message: () =>\n                    `Element not found:\\n${JSON.stringify(element, null, 2)}`,\n            };\n        } catch (e) {\n            return {\n                pass: false,\n                message: () => (e as Error).message,\n            };\n        }\n    },\n});\n","export async function retry<T>(\n    fn: () => T | Promise<T>,\n    {\n        retries = 3,\n        timeout = 1000,\n        predicate = () => true,\n    }: {\n        retries?: number;\n        timeout?: number;\n        predicate?: (e: unknown, attempt: number) => boolean | undefined;\n    }\n): Promise<T> {\n    for (let i = 1; i <= retries; i++) {\n        try {\n            return await fn();\n        } catch (e) {\n            if (i === retries || !predicate(e, i)) {\n                throw e;\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, timeout));\n        }\n    }\n\n    // unreachable, satisifies typescript return type\n    throw null;\n}\n\nexport function clamp(value: number, min: number, max: number) {\n    return Math.min(Math.max(value, min), max);\n}\n\nexport function uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\n\nexport function queryString(params: Record<string, any>) {\n    return Object.entries(params)\n        .map(([key, value]) => {\n            if (typeof value !== 'undefined') {\n                return `${key}=${encodeURIComponent(value)}`;\n            }\n\n            return '';\n        })\n        .join('&');\n}\n\nexport interface DeferredPromise<T> {\n    promise: Promise<T>;\n    resolve: (value: T) => void;\n    reject: (error: any) => void;\n    resolved?: T;\n    rejected?: unknown;\n}\nexport function createDeferredPromise<T = void>(): DeferredPromise<T> {\n    let resolved: T;\n    let rejected: unknown;\n    let resolve: (value: T) => void;\n    let reject: (error: any) => void;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = (value: T) => {\n            resolved = value;\n            res(value);\n        };\n        reject = (err) => {\n            resolved = err;\n            rej(err);\n        };\n    });\n\n    return {\n        promise,\n        resolve: resolve!,\n        reject: reject!,\n        resolved: resolved!,\n        rejected: rejected!,\n    };\n}\n\ntype CleanedObject<T> = {\n    [P in keyof T]: T[P] extends object ? CleanedObject<T[P]> : T[P];\n};\n\n/**\n * Remove undefined and null recursively\n */\nexport function cleanObject<T>(obj: T): CleanedObject<T> {\n    if (Array.isArray(obj)) {\n        return (obj as unknown as any[])\n            .map(cleanObject)\n            .filter(\n                (item) => item !== null && item !== undefined\n            ) as CleanedObject<T>;\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n        return Object.entries(obj).reduce((acc, [key, value]) => {\n            const cleanedValue = cleanObject(value);\n            if (cleanedValue !== null && cleanedValue !== undefined) {\n                acc[key] = cleanedValue;\n            }\n            return acc;\n        }, {} as CleanedObject<T>);\n    }\n\n    return obj as CleanedObject<T>;\n}\n\nexport function parseOsVersion(version: string) {\n    const [major, minor, patch] = version.split('.');\n    return {\n        major: major ? parseInt(major) : 0,\n        minor: minor ? parseInt(minor) : 0,\n        patch: patch ? parseInt(patch) : 0,\n    };\n}\n\ntype UnionKeys<T> = T extends T ? keyof T : never;\ntype StrictUnionHelper<T, TAll> = T extends any\n    ? T & Partial<Record<Exclude<UnionKeys<TAll>, keyof T>, never>>\n    : never;\n\nexport type StrictUnion<T> = StrictUnionHelper<T, T>;\n\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-471566609\nexport type LiteralUnion<T extends U, U = string> =\n    | T\n    | (U & { zz_IGNORE_ME?: never });\n\n/**\n * Omit without breaking union types\n */\nexport type OmitUnion<T, K extends keyof any> = T extends any\n    ? Omit<T, K>\n    : never;\n","export class Logger {\n    log = this.createLogFn('log');\n    warn = this.createLogFn('warn');\n    error = this.createLogFn('error');\n    debug = this.createLogFn('log');\n\n    private createLogFn(type: 'log' | 'warn' | 'error') {\n        const loggedMessages = new Set<string>();\n        const context = '[Appetize]';\n\n        // preserves the original console context\n        const fn: LogFn = Function.prototype.bind.call(\n            console[type],\n            console,\n            context\n        );\n\n        // logs message only once, but we do lose the console context with this implementation\n        fn.once = (msg: string) => {\n            if (loggedMessages.has(msg)) {\n                return;\n            } else {\n                loggedMessages.add(msg);\n            }\n\n            return fn.call(console, msg);\n        };\n\n        return fn;\n    }\n}\n\nexport interface LogFn {\n    (message: string, ...data: any[]): void;\n    once: (message: string, ...data: any[]) => void;\n}\n","import { EventEmitter as BaseEventEmitter } from 'events';\n\nexport class EventEmitter extends BaseEventEmitter {\n    constructor() {\n        super();\n\n        // EventEmitter will throw 'error' events if there are no listeners. We do not\n        // want that behaviuor, so we seutp a no-op listener.\n        this.on('error', () => {});\n    }\n}\n","import { PlayActionErrorResponse } from './api/types/recorder';\n\nexport function captureStackTrace(targetObject, constructorOpt) {\n    if ('captureStackTrace' in Error) {\n        Error.captureStackTrace(targetObject, constructorOpt);\n    } else {\n        // @ts-ignore\n        const container = new Error();\n\n        Object.defineProperty(targetObject, 'stack', {\n            configurable: true,\n            get() {\n                const { stack } = container;\n                Object.defineProperty(this, 'stack', { value: stack });\n                return stack;\n            },\n        });\n    }\n}\n\n/**\n * Captures the stack trace of an operational error so that when the error is logged to the user,\n * the stack points to the given method instead of the method that threw the error.\n *\n * i.e\n *\n * ```bash\n *  TimeoutError: Timed out after 60 seconds waiting for element\n *  await session.tap({ element: { text: 'hello' } });\n *  ^\n * ```\n */\nexport async function captureOperationalError(e: unknown, constructorOpt: any) {\n    if (e instanceof OperationalError) {\n        captureStackTrace(e, constructorOpt);\n    }\n}\n\nexport class OperationalError extends Error {\n    /**\n     * Whether the error is operational or not.\n     * Operational errors are errors that are expected to happen\n     * (such as the failed result of an action playback, or timeout error).\n     */\n    isOperational: boolean;\n\n    constructor(message: string) {\n        super(message);\n        this.name = 'Error';\n        this.isOperational = true;\n        captureStackTrace(this, this.constructor);\n    }\n}\n\nexport class ActionError extends OperationalError {\n    errorId: PlayActionErrorResponse['errorId'];\n    playback: PlayActionErrorResponse['playback'];\n\n    constructor(error: PlayActionErrorResponse, message?: string) {\n        super(message ?? error.message);\n        this.errorId = error.errorId;\n        this.playback = error.playback;\n    }\n}\n\nexport class ActionElementNotFoundError extends ActionError {\n    constructor(error: PlayActionErrorResponse & { errorId: 'notFound' }) {\n        super(\n            error,\n            `No element found for selector\\n${JSON.stringify(\n                error.playback.action.element,\n                null,\n                2\n            )}`\n        );\n    }\n}\n\nexport class ActionAmbiguousElementError extends ActionError {\n    constructor(\n        error: PlayActionErrorResponse & { errorId: 'ambiguousMatch' }\n    ) {\n        super(\n            error,\n            `Action requires 1 unique element but the selector returned ${\n                error.matchedElements.length\n            }. Provide a \\`matchIndex\\` to pick an element below or add additional attributes to your selector.\\n\\n${formatAmbiguousElements(\n                error.matchedElements\n            )}`\n        );\n    }\n}\n\nexport class ActionInvalidArgumentError extends ActionError {\n    constructor(\n        error: PlayActionErrorResponse & { errorId: 'invalidArgument' }\n    ) {\n        let msg = error.message;\n        if (error.message.match('outside the screen bounds')) {\n            const { action } = error.playback;\n            if ('localPosition' in action && action.localPosition) {\n                msg = `localPosition (${action.localPosition.x}, ${action.localPosition.y}) for the element evaluates to a coordinate outside of screen bounds.`;\n            } else {\n                msg = `Element is outside of screen bounds.`;\n            }\n        }\n\n        super(error, msg);\n    }\n}\n\nexport class ActionInternalError extends ActionError {\n    constructor(error: PlayActionErrorResponse & { errorId: 'internalError' }) {\n        super(\n            error,\n            `An internal error has occurred for the action:\\n${JSON.stringify(\n                error.playback.action,\n                null,\n                2\n            )}`\n        );\n    }\n}\n\nexport class TimeoutError extends OperationalError {}\n\nexport class ActionTimeoutError extends OperationalError {\n    playback: PlayActionErrorResponse['playback'];\n\n    constructor(playback: PlayActionErrorResponse['playback'], msg: string) {\n        super(msg);\n        this.playback = playback;\n    }\n}\n\nexport class RecorderRequiredError extends OperationalError {\n    constructor(feature: string) {\n        super(\n            `App Recorder must be enabled to use ${feature}. Please set \"record\" to true in the config.`\n        );\n    }\n}\n\nexport function formatAmbiguousElements(elements: any[]): string {\n    const maxElements = 5;\n    const truncatedElements = elements.slice(0, maxElements);\n    const truncated = elements.length > maxElements;\n\n    const formatted = truncatedElements.map(\n        (e, index) => `// ${index}\\n${JSON.stringify(e, null, 2)}`\n    );\n\n    return `${formatted.join('\\n\\n')}${\n        truncated ? `\\n\\n...and ${elements.length - maxElements} more` : ''\n    }`;\n}\n\n// gets the current line:column from stack trace\nexport function captureLocationFromError(e: Error) {\n    const stack = e.stack;\n    if (!stack) return;\n    const lines = stack.split('\\n');\n    const line = lines[2];\n    const match = line.match(/at (.*)$/);\n    if (!match) return;\n    const location = match[1];\n    return {\n        file: location.split(':')[0],\n        line: location.split(':')[1],\n        column: location.split(':')[2],\n    };\n}\n","import { Coordinates } from './types/recorder';\nimport * as InternalRecorderAPI from './types/recorder/internal';\nimport * as PublicRecorderAPI from './types/recorder/public';\n\nexport class DataValidator {\n    /**\n     * Helper error message to help migrate from old element format to new element format.\n     */\n    static isValidElementSelector(element: PublicRecorderAPI.ElementSelector) {\n        if (typeof element !== 'object' || Array.isArray(element)) {\n            throw new Error('Element must be an object');\n        }\n\n        const rootKeys = Object.keys(element);\n        const knownAttributeFields = [\n            'text',\n            'accessibilityIdentifier',\n            'accessibilityLabel',\n            'resource-id',\n            'content-desc',\n            'class',\n            'baseClass',\n        ];\n\n        const rootAttributes = intersect(rootKeys, knownAttributeFields);\n\n        if (rootAttributes.length > 0) {\n            const list = rootAttributes.map((v) => `'${v}'`).join(', ');\n            throw new Error(\n                `Element has invalid properties: ${list}. Did you mean to put these under 'attributes'?`\n            );\n        }\n\n        return element;\n    }\n\n    static isCoordinatesWithinBounds(\n        coordinates: Coordinates,\n        bounds: { width: number; height: number }\n    ) {\n        if (coordinates.x < 0 || coordinates.x > bounds.width) {\n            return false;\n        }\n\n        if (coordinates.y < 0 || coordinates.y > bounds.height) {\n            return false;\n        }\n\n        return true;\n    }\n\n    static isPositionWithinBounds(\n        position: InternalRecorderAPI.Position | PublicRecorderAPI.Position\n    ) {\n        const x = DataParser.toPositionValue(position.x);\n        const y = DataParser.toPositionValue(position.y);\n\n        if (x < 0 || x > 1) {\n            return false;\n        }\n\n        if (y < 0 || y > 1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    static isValidNumber(value: number) {\n        if (typeof value !== 'number') {\n            return false;\n        }\n\n        if (isNaN(value)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nexport class DataParser {\n    static toBoolean(value: number | null | undefined) {\n        return value === 1 ? true : false;\n    }\n\n    static toNumber(\n        value:\n            | boolean\n            | string\n            | number\n            | InternalRecorderAPI.ObjCNumber\n            | undefined\n    ) {\n        if (typeof value === 'number') {\n            return value;\n        }\n\n        if (typeof value === 'boolean' || value === undefined) {\n            return value ? 1 : 0;\n        }\n\n        // handle obj-c number\n        if (value === 'inf') {\n            return Infinity;\n        } else if (value === '-inf') {\n            return -Infinity;\n        }\n\n        return parseFloat(value);\n    }\n\n    static toObjCNumber(value: number): InternalRecorderAPI.ObjCNumber {\n        if (value === Infinity) {\n            return 'inf';\n        }\n\n        if (value === -Infinity) {\n            return '-inf';\n        }\n\n        return value;\n    }\n\n    /**\n     * If value is a string ending with %, return the value as a number between 0 and 1.\n     *\n     * If value is a number betwen 0 and 1, return the value.\n     */\n    static toPositionValue(value: string | number): number {\n        if (typeof value === 'string') {\n            if (value.endsWith('%')) {\n                return parseInt(value, 10) / 100;\n            } else {\n                throw new Error(\n                    `Invalid position value: ${value}. Must be a number between 0 and 1, or a string ending with %`\n                );\n            }\n        }\n\n        return value;\n    }\n}\n\nfunction intersect(a: any[], b: any[]) {\n    return a.filter((v) => b.includes(v));\n}\n","import { cleanObject } from '../../util';\nimport { DataParser } from '../parser';\nimport { Platform, ScreenBounds } from '../types/recorder/common';\nimport * as InternalRecorderAPI from '../types/recorder/internal';\nimport * as PublicRecorderAPI from '../types/recorder/public';\n\nexport class ElementMapper {\n    platform: Platform;\n    screen: ScreenBounds;\n\n    constructor({\n        platform,\n        screen,\n    }: {\n        platform: Platform;\n        screen: ScreenBounds;\n    }) {\n        this.platform = platform;\n        this.screen = screen;\n    }\n\n    private pixelToDip(value: number) {\n        return value / (this.screen.devicePixelRatio || 1);\n    }\n\n    private dipToPixel(value: number) {\n        return value * (this.screen.devicePixelRatio || 1);\n    }\n\n    toInternal<\n        T extends PublicRecorderAPI.Element | PublicRecorderAPI.ElementSelector\n    >(\n        element: T\n    ): T extends PublicRecorderAPI.Element\n        ? InternalRecorderAPI.Element\n        : InternalRecorderAPI.ElementSelector {\n        const { attributes, bounds, ...rest } = element;\n\n        const mapBounds = () => {\n            if (bounds) {\n                const { x, y, width, height } = bounds;\n                if (this.platform === 'android') {\n                    return {\n                        x: this.dipToPixel(x),\n                        y: this.dipToPixel(y),\n                        width: this.dipToPixel(width),\n                        height: this.dipToPixel(height),\n                    };\n                } else {\n                    return {\n                        x: DataParser.toObjCNumber(x),\n                        y: DataParser.toObjCNumber(y),\n                        width: DataParser.toObjCNumber(width),\n                        height: DataParser.toObjCNumber(height),\n                    };\n                }\n            }\n        };\n\n        const mapAttributes = () => {\n            if (attributes) {\n                return Object.keys(attributes).reduce((acc, key) => {\n                    if (this.platform === 'ios') {\n                        switch (key) {\n                            // convert boolean to '1' or '0'\n                            case 'userInteractionEnabled':\n                            case 'isHidden':\n                                return {\n                                    ...acc,\n                                    [key]: attributes[key]\n                                        ? '1'\n                                        : ('0' as InternalRecorderAPI.BooleanString),\n                                };\n                        }\n                    } else if (this.platform === 'android') {\n                        // nothing yet\n                    }\n\n                    return {\n                        ...acc,\n                        [key]: attributes[key],\n                    };\n                }, {}) as InternalRecorderAPI.Element['attributes'];\n            }\n        };\n\n        return cleanObject({\n            ...rest,\n            bounds: mapBounds(),\n            attributes: mapAttributes(),\n            // internal does not use accessibilityElements for playback, so just remove it\n            accessibilityElements: undefined,\n        }) as T extends PublicRecorderAPI.Element\n            ? InternalRecorderAPI.Element\n            : InternalRecorderAPI.ElementSelector;\n    }\n\n    toPublic<\n        T extends\n            | InternalRecorderAPI.Element\n            | InternalRecorderAPI.ElementSelector\n    >(\n        element: T\n    ): T extends InternalRecorderAPI.Element\n        ? PublicRecorderAPI.Element\n        : PublicRecorderAPI.ElementSelector {\n        const { attributes, bounds, accessibilityElements, ...rest } = element;\n\n        const mapBounds = (bounds: InternalRecorderAPI.ElementBounds) => {\n            if (this.platform === 'android') {\n                return {\n                    x: this.pixelToDip(bounds.x as number),\n                    y: this.pixelToDip(bounds.y as number),\n                    width: this.pixelToDip(bounds.width as number),\n                    height: this.pixelToDip(bounds.height as number),\n                };\n            } else {\n                return {\n                    x: DataParser.toNumber(bounds.x),\n                    y: DataParser.toNumber(bounds.y),\n                    width: DataParser.toNumber(bounds.width),\n                    height: DataParser.toNumber(bounds.height),\n                };\n            }\n        };\n\n        const mapAttributes = (\n            attributes:\n                | InternalRecorderAPI.IOSElementAttributes\n                | InternalRecorderAPI.IOSAccessibilityAttributes\n        ) => {\n            return Object.keys(attributes).reduce((acc, key) => {\n                switch (key) {\n                    // convert boolean to '1' or '0'\n                    case 'userInteractionEnabled':\n                    case 'isHidden':\n                        return {\n                            ...acc,\n                            [key]: attributes[key] === '1' ? true : false,\n                        };\n                    default:\n                        return {\n                            ...acc,\n                            [key]: attributes[key],\n                        };\n                }\n            }, {}) as PublicRecorderAPI.Element['attributes'];\n        };\n\n        const mapAccessibilityElements = (\n            accessibilityElements: InternalRecorderAPI.IOSAccessibilityElement[]\n        ) => {\n            return accessibilityElements.map((accessibilityEl) => {\n                const { accessibilityFrame } = accessibilityEl;\n                return {\n                    ...mapAttributes(accessibilityEl),\n                    accessibilityFrame: accessibilityFrame\n                        ? mapBounds(accessibilityFrame)\n                        : undefined,\n                };\n            });\n        };\n\n        return cleanObject({\n            ...rest,\n            bounds: bounds ? mapBounds(bounds) : undefined,\n            attributes: attributes ? mapAttributes(attributes) : undefined,\n            accessibilityElements: accessibilityElements\n                ? mapAccessibilityElements(accessibilityElements)\n                : undefined,\n        }) as T extends InternalRecorderAPI.Element\n            ? PublicRecorderAPI.Element\n            : PublicRecorderAPI.ElementSelector;\n    }\n}\n\n// prevents accidentally using window.screen that instead of this.screen\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ndeclare let screen: never;\n","import { OperationalError } from '../../errors';\nimport { cleanObject } from '../../util';\nimport { DataParser, DataValidator } from '../parser';\nimport { Coordinates, Platform, ScreenBounds } from '../types/recorder/common';\nimport * as InternalRecorderAPI from '../types/recorder/internal';\nimport * as PublicRecorderAPI from '../types/recorder/public';\n\nimport { ElementMapper } from './element';\n\nexport class ActionMapper {\n    platform: Platform;\n    screen: ScreenBounds;\n\n    elementMapper: ElementMapper;\n    constructor({\n        platform,\n        screen,\n    }: {\n        platform: Platform;\n        screen: ScreenBounds;\n    }) {\n        this.platform = platform;\n        this.screen = screen;\n\n        this.elementMapper = new ElementMapper({\n            platform,\n            screen,\n        });\n    }\n\n    private pixelToDip(value: number) {\n        return value / (this.screen.devicePixelRatio || 1);\n    }\n\n    private dipToPixel(value: number) {\n        return value * (this.screen.devicePixelRatio || 1);\n    }\n\n    private getCoordinates(\n        position: PublicRecorderAPI.Position,\n        bounds: { width: number; height: number }\n    ) {\n        const x = DataParser.toPositionValue(position.x);\n        const y = DataParser.toPositionValue(position.y);\n\n        return {\n            x: x * bounds.width,\n            y: y * bounds.height,\n        };\n    }\n\n    private getPosition(\n        coordinates: Coordinates,\n        bounds: { width: number; height: number }\n    ) {\n        return {\n            x: coordinates.x / bounds.width,\n            y: coordinates.y / bounds.height,\n        };\n    }\n\n    private toInternalKey(value?: string) {\n        switch (value) {\n            case 'HOME':\n                return 'home';\n            case 'VOLUME_UP':\n                return 'volumeUp';\n            case 'VOLUME_DOWN':\n                return 'volumeDown';\n        }\n\n        return value;\n    }\n\n    private toPublicKey(value?: string) {\n        switch (value) {\n            case 'home':\n                return 'HOME';\n            case 'volumeUp':\n                return 'VOLUME_UP';\n            case 'volumeDown':\n                return 'VOLUME_DOWN';\n        }\n\n        return value;\n    }\n\n    toInternal(\n        action: PublicRecorderAPI.Action | PublicRecorderAPI.RecordedAction\n    ) {\n        const map = () => {\n            action = cleanObject(action);\n\n            let element:\n                | InternalRecorderAPI.Element\n                | InternalRecorderAPI.ElementSelector\n                | undefined;\n            let coordinates: Coordinates | undefined;\n            let localPosition: InternalRecorderAPI.Position | undefined;\n\n            if ('element' in action && action.element) {\n                element = this.elementMapper.toInternal(action.element);\n            }\n\n            if ('position' in action && action.position) {\n                const x = DataParser.toPositionValue(action.position.x);\n                const y = DataParser.toPositionValue(action.position.y);\n\n                if (\n                    !DataValidator.isValidNumber(x) ||\n                    !DataValidator.isValidNumber(y)\n                ) {\n                    throw new OperationalError(\n                        `Invalid position: (${action.position.x}, ${action.position.y}). Values must be a number or a percentage`\n                    );\n                }\n\n                if (!DataValidator.isPositionWithinBounds(action.position)) {\n                    if (typeof action.position.x === 'string') {\n                        throw new Error(\n                            `Invalid position: (${action.position.x}, ${action.position.y}) must be within (0%, 0%) and (100%, 100%)`\n                        );\n                    } else {\n                        throw new Error(\n                            `Invalid position: (${action.position.x}, ${action.position.y}) must be within (0, 0) and (1, 1)`\n                        );\n                    }\n                }\n\n                if (this.platform === 'android') {\n                    coordinates = this.getCoordinates(action.position, {\n                        width: this.dipToPixel(this.screen.width) - 1,\n                        height: this.dipToPixel(this.screen.height) - 1,\n                    });\n                } else {\n                    coordinates = this.getCoordinates(action.position, {\n                        width: this.screen.width - 1,\n                        height: this.screen.height - 1,\n                    });\n                }\n            } else if ('coordinates' in action && action.coordinates) {\n                if (\n                    !DataValidator.isValidNumber(action.coordinates.x) ||\n                    !DataValidator.isValidNumber(action.coordinates.y)\n                ) {\n                    throw new OperationalError(\n                        `Invalid coordinates: (${action.coordinates.x}, ${action.coordinates.y}). Values must be a number`\n                    );\n                }\n\n                if (\n                    !DataValidator.isCoordinatesWithinBounds(\n                        action.coordinates,\n                        {\n                            width: this.screen.width - 1,\n                            height: this.screen.height - 1,\n                        }\n                    )\n                ) {\n                    throw new OperationalError(\n                        `Invalid coordinates: (${action.coordinates.x}, ${\n                            action.coordinates.y\n                        }) exceed screen bounds (${this.screen.width - 1}, ${\n                            this.screen.height - 1\n                        })`\n                    );\n                }\n\n                if (this.platform === 'android') {\n                    coordinates = {\n                        x: this.dipToPixel(action.coordinates.x),\n                        y: this.dipToPixel(action.coordinates.y),\n                    };\n                } else {\n                    coordinates = action.coordinates;\n                }\n            }\n\n            if ('localPosition' in action && action.localPosition) {\n                const x = DataParser.toPositionValue(action.localPosition.x);\n                const y = DataParser.toPositionValue(action.localPosition.y);\n\n                if (\n                    !DataValidator.isValidNumber(x) ||\n                    !DataValidator.isValidNumber(y)\n                ) {\n                    throw new OperationalError(\n                        `Invalid localPosition: (${action.localPosition.x}, ${action.localPosition.y}). Values must be a number or a percentage`\n                    );\n                }\n\n                // iOS sometimes reports localPosition values out of bounds. for the time being\n                // we will disable this check.\n                // if (!Validator.isPositionWithinBounds(action.localPosition)) {\n                //     if (typeof action.localPosition.x === 'string') {\n                //         throw new Error(\n                //             `Invalid localPosition: (${action.localPosition.x}, ${action.localPosition.y}) must be within (0%, 0%) and (100%, 100%)`\n                //         );\n                //     } else {\n                //         throw new Error(\n                //             `Invalid localPosition: (${action.localPosition.x}, ${action.localPosition.y}) must be within (0, 0) and (1, 1)`\n                //         );\n                //     }\n                // }\n\n                localPosition = {\n                    x,\n                    y,\n                };\n            } else {\n                if (element) {\n                    localPosition = { x: 0.5, y: 0.5 };\n                }\n            }\n\n            if ('duration' in action && action.duration) {\n                if (!DataValidator.isValidNumber(action.duration)) {\n                    throw new OperationalError(\n                        `Invalid duration: ${action.duration}. Value must be a number`\n                    );\n                }\n            }\n\n            switch (action.type) {\n                case 'tap': {\n                    const { position, ...rest } = action;\n\n                    return {\n                        ...rest,\n                        element,\n                        localPosition,\n                        coordinates,\n                    } as InternalRecorderAPI.TapAction;\n                }\n                case 'swipe': {\n                    const { position, ...rest } = action;\n\n                    return {\n                        ...rest,\n                        element,\n                        localPosition,\n                        coordinates,\n                        moves: action.moves.map((move) => {\n                            if (this.platform === 'android') {\n                                const { x, y } = this.getCoordinates(move, {\n                                    width:\n                                        this.dipToPixel(this.screen.width) - 1,\n                                    height:\n                                        this.dipToPixel(this.screen.height) - 1,\n                                });\n                                return {\n                                    ...move,\n                                    x,\n                                    y,\n                                };\n                            } else {\n                                const { x, y } = this.getCoordinates(move, {\n                                    width: this.screen.width - 1,\n                                    height: this.screen.height - 1,\n                                });\n                                return {\n                                    ...move,\n                                    x,\n                                    y,\n                                };\n                            }\n                        }),\n                    } as InternalRecorderAPI.SwipeAction;\n                }\n                case 'keypress': {\n                    const key = this.toInternalKey(action.key);\n                    const character = this.toInternalKey(action.character);\n\n                    return {\n                        ...action,\n                        key,\n                        character,\n                        shiftKey:\n                            this.platform === 'ios'\n                                ? DataParser.toNumber(action.shiftKey)\n                                : action.shiftKey,\n                    } as InternalRecorderAPI.KeypressAction;\n                }\n                case 'findElements': {\n                    return {\n                        ...action,\n                        element,\n                    } as InternalRecorderAPI.FindElementsAction;\n                }\n            }\n            return action;\n        };\n\n        return cleanObject(map());\n    }\n\n    toPublic(\n        action: InternalRecorderAPI.Action | InternalRecorderAPI.RecordedAction\n    ): PublicRecorderAPI.Action | PublicRecorderAPI.RecordedAction {\n        const map = () => {\n            let element:\n                | PublicRecorderAPI.Element\n                | PublicRecorderAPI.ElementSelector\n                | undefined;\n            let coordinates: Coordinates | undefined;\n            let position: PublicRecorderAPI.Position | undefined;\n            let localPosition: PublicRecorderAPI.Position | undefined =\n                // if this is a playback result payload, localPosition may be defined\n                'localPosition' in action ? action.localPosition : undefined;\n\n            if ('coordinates' in action && action.coordinates) {\n                coordinates = {\n                    x: this.pixelToDip(action.coordinates.x),\n                    y: this.pixelToDip(action.coordinates.y),\n                };\n\n                position = this.getPosition(coordinates, {\n                    width: this.screen.width - 1,\n                    height: this.screen.height - 1,\n                });\n            }\n\n            if ('element' in action && action.element) {\n                element = this.elementMapper.toPublic(action.element);\n\n                if (coordinates && element.bounds) {\n                    localPosition = this.getPosition(\n                        {\n                            x: coordinates.x - element.bounds.x,\n                            y: coordinates.y - element.bounds.y,\n                        },\n                        {\n                            width: element.bounds.width,\n                            height: element.bounds.height,\n                        }\n                    );\n                }\n            }\n\n            switch (action.type) {\n                case 'tap': {\n                    return {\n                        ...action,\n                        coordinates,\n                        element,\n                        position,\n                        localPosition,\n                    } as PublicRecorderAPI.TapAction;\n                }\n                case 'swipe': {\n                    return {\n                        ...action,\n                        coordinates,\n                        element,\n                        position,\n                        localPosition,\n                        moves: action.moves.map((move) => {\n                            const { x, y } = this.getPosition(\n                                {\n                                    x: this.pixelToDip(move.x),\n                                    y: this.pixelToDip(move.y),\n                                },\n                                {\n                                    width: this.screen.width - 1,\n                                    height: this.screen.height - 1,\n                                }\n                            );\n\n                            return {\n                                x,\n                                y,\n                                t: move.t,\n                            };\n                        }),\n                    } as PublicRecorderAPI.SwipeAction;\n                }\n\n                case 'keypress': {\n                    const key = this.toPublicKey(action.key);\n                    const character = this.toPublicKey(action.character);\n\n                    return {\n                        ...action,\n                        key,\n                        character,\n                        shiftKey:\n                            typeof action.shiftKey === 'number'\n                                ? DataParser.toBoolean(action.shiftKey)\n                                : Boolean(action.shiftKey),\n                    } as PublicRecorderAPI.KeypressAction;\n                }\n                case 'findElements': {\n                    return {\n                        ...action,\n                        element,\n                    } as PublicRecorderAPI.FindElementsAction;\n                }\n            }\n\n            return action;\n        };\n\n        return cleanObject(map());\n    }\n}\n\n// prevents accidentally using window.screen that instead of this.screen\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ndeclare let screen: never;\n","import { Platform, ScreenBounds } from '../types/recorder/common';\nimport * as InternalRecorderAPI from '../types/recorder/internal';\nimport * as PublicRecorderAPI from '../types/recorder/public';\nimport { AppetizeApp } from '../types/app';\n\nimport { ActionMapper } from './action';\nimport { ElementMapper } from './element';\n\nexport class SessionEventMapper {\n    platform?: Platform;\n    screen?: ScreenBounds;\n    app?: AppetizeApp;\n\n    actionMapper: ActionMapper;\n    elementMapper: ElementMapper;\n\n    constructor({\n        platform,\n        screen,\n        app,\n    }: {\n        platform: Platform;\n        screen: ScreenBounds;\n        app?: AppetizeApp;\n    }) {\n        this.app = app;\n        this.platform = platform;\n        this.screen = screen;\n\n        this.actionMapper = new ActionMapper({\n            platform,\n            screen,\n        });\n\n        this.elementMapper = new ElementMapper({\n            platform,\n            screen,\n        });\n    }\n\n    public toInternal(type: string, value: any) {\n        switch (type) {\n            case 'playAction': {\n                const payload = value as {\n                    id: string;\n                    action: PublicRecorderAPI.Action;\n                    timeout?: number;\n                };\n                const noMap = value.__noMap__; // for internal debug, not a public option\n\n                const mappedAction = noMap\n                    ? value.action\n                    : this.actionMapper.toInternal(payload.action);\n\n                return {\n                    type,\n                    value: {\n                        ...payload,\n                        action: mappedAction,\n                    },\n                };\n            }\n        }\n\n        return { type, value };\n    }\n\n    public toPublic(type: string, value: any) {\n        switch (type) {\n            case 'debug':\n                return {\n                    type: 'log',\n                    value: value,\n                };\n            case 'interceptResponse':\n                return {\n                    type: 'network',\n                    value: {\n                        type: 'response',\n                        ...value,\n                    },\n                };\n            case 'interceptRequest':\n                return {\n                    type: 'network',\n                    value: {\n                        type: 'request',\n                        ...value,\n                    },\n                };\n\n            case 'interceptError':\n                return {\n                    type: 'network',\n                    value: {\n                        type: 'error',\n                        ...value,\n                    },\n                };\n\n            case 'userError':\n                return {\n                    type: 'error',\n                    value: value,\n                };\n            case 'userInteractionReceived':\n                return {\n                    type: 'interaction',\n                    value: value,\n                };\n            case 'countdownWarning':\n                return {\n                    type: 'inactivityWarning',\n                    value: value,\n                };\n            case 'h264Data':\n                return {\n                    type: 'video',\n                    value: {\n                        ...value,\n                        codec: 'h264',\n                    },\n                };\n\n            case 'frameData':\n                return {\n                    type: 'video',\n                    value: {\n                        ...value,\n                        codec: 'jpeg',\n                    },\n                };\n            case 'audioData': {\n                return {\n                    type: 'audio',\n                    value: {\n                        ...value,\n                        codec: 'aac',\n                    },\n                };\n            }\n\n            case 'concurrentQueue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'concurrent',\n                        name: value.name,\n                        position: value.position,\n                    },\n                };\n            case 'queue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'session',\n                        position: value.position,\n                    },\n                };\n\n            // xdoc events\n            case 'orientationChanged':\n                return {\n                    type,\n                    value,\n                };\n            case 'chromeDevToolsUrl':\n                return {\n                    type: 'networkInspectorUrl',\n                    value,\n                };\n\n            // app recorder\n            case 'recordedAction': {\n                return {\n                    type: 'action',\n                    value: this.actionMapper.toPublic(value),\n                };\n            }\n            case 'playbackFoundAndSent': {\n                const v = value as InternalRecorderAPI.PlayActionResult;\n\n                return {\n                    type: 'playbackFoundAndSent',\n                    value: {\n                        ...v,\n                        playback: {\n                            ...v.playback,\n                            action: v.playback?.action\n                                ? this.actionMapper.toPublic(v.playback.action)\n                                : undefined,\n                        },\n                        matchedElements: v.matchedElements?.map((e) => {\n                            if (e) {\n                                return this.elementMapper!.toPublic(e);\n                            }\n                        }),\n                    },\n                } as {\n                    type: string;\n                    value: PublicRecorderAPI.PlayActionResult;\n                };\n            }\n            case 'playbackError': {\n                const v = value as InternalRecorderAPI.PlayActionResult;\n\n                return {\n                    type: 'playbackError',\n                    value: {\n                        ...v,\n                        playback: {\n                            ...v.playback,\n                            action: v.playback?.action\n                                ? this.actionMapper.toPublic(v.playback.action)\n                                : undefined,\n                        },\n                        matchedElements: v.matchedElements?.map((e) => {\n                            if (e) {\n                                return this.elementMapper!.toPublic(e);\n                            }\n                        }),\n                    },\n                } as {\n                    type: string;\n                    value: PublicRecorderAPI.PlayActionErrorResponse;\n                };\n            }\n            case 'uiDump': {\n                const appUi = value.ui ?? value.result;\n                const springboardUi = value.springboard;\n\n                const mapRecursive = (\n                    element: InternalRecorderAPI.FullElement\n                ): PublicRecorderAPI.FullElement => {\n                    return {\n                        ...this.elementMapper!.toPublic(element),\n                        children: element.children?.map(mapRecursive),\n                    };\n                };\n\n                const result: PublicRecorderAPI.AllUI = [];\n\n                if (appUi) {\n                    if (this.platform === 'ios') {\n                        result.push({\n                            type: 'app',\n                            appId: this.app?.bundle,\n                            children: appUi.map(mapRecursive),\n                        });\n                    } else {\n                        // on android, everything is one tree. in the future they will separate.\n                        result.push({\n                            type: 'app',\n                            children: appUi.map(mapRecursive),\n                        });\n                    }\n                }\n\n                if (springboardUi) {\n                    result.push({\n                        type: 'app',\n                        appId: 'com.apple.springboard',\n                        children: springboardUi.map(mapRecursive),\n                    });\n                }\n\n                return {\n                    type: 'uiDump',\n                    value: result,\n                };\n            }\n            // suppressed events\n            case 'deleteEvent':\n                return null;\n        }\n\n        return {\n            type,\n            value,\n        };\n    }\n}\n\nexport class ClientEventMapper {\n    public toInternal(type: string, value: any) {\n        return { type, value };\n    }\n\n    public toPublic(type: string, value: any) {\n        switch (type) {\n            case 'userError':\n                return {\n                    type: 'error',\n                    value: value,\n                };\n            case 'concurrentQueue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'concurrent',\n                        name: value.name,\n                        position: value.position,\n                    },\n                };\n            case 'queue':\n                return {\n                    type: 'queue',\n                    value: {\n                        type: 'session',\n                        position: value.position,\n                    },\n                };\n\n            // xdoc events\n            case 'deviceInfo':\n            case 'sessionInfo':\n            case 'sessionRequested':\n                return {\n                    type,\n                    value,\n                };\n        }\n\n        return {\n            type,\n            value,\n        };\n    }\n}\n\n// prevents accidentally using window.screen that instead of this.screen\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ndeclare let screen: never;\n","import { EventEmitter } from '../../EventEmitter';\nimport { SocketProtocol } from '../types/socket';\nimport { ClientEventMapper } from './event';\n\nexport class ClientSocketMapper extends EventEmitter implements SocketProtocol {\n    private _socket: SocketProtocol;\n    private eventMapper = new ClientEventMapper();\n\n    constructor({ socket }: { socket: SocketProtocol }) {\n        super();\n        this._socket = socket;\n\n        socket.on('*', ({ type, value }) => {\n            const mapped = this.mapEmit(type, value);\n            const suppressed = mapped === null;\n\n            if (!suppressed) {\n                this.emit(mapped.type, mapped.value);\n                this.emit('*', mapped);\n            }\n        });\n    }\n\n    private mapEmit(type: string, value: any) {\n        return this.eventMapper.toPublic(type, value);\n    }\n\n    private mapSend(type: string, value: any) {\n        return this.eventMapper.toInternal(type, value);\n    }\n\n    send(event: string, data?: any): Promise<void> {\n        const mapped = this.mapSend(event, data);\n\n        return this._socket.send(mapped.type, mapped.value);\n    }\n\n    disconnect(): Promise<void> {\n        return this._socket.disconnect();\n    }\n}\n","import {\n    Session,\n    SessionConfig,\n    SessionEvents,\n    UserSessionConfig,\n} from '../session';\nimport { SocketProtocol } from '../api/types/socket';\nimport { Logger } from '../logger';\nimport { EventEmitter } from '../EventEmitter';\nimport { ClientSocketMapper } from '../api/mappers/client-socket';\n\nexport class Client<\n    TSocket extends SocketProtocol,\n    TEvents extends ClientEvents,\n    TSession extends Session<SessionEvents>\n> extends EventEmitter {\n    socket: TSocket;\n    logger: Logger;\n\n    // needed for swipes, but it's currently only possible to get from the embed page\n    // TODO: for headless, we need this to be receivable from appetizer socket\n    device!: DeviceInfo;\n    protected _config: SessionConfig | undefined;\n\n    queue?: ClientEvents['queue'];\n\n    constructor({\n        socket,\n        logger = new Logger(),\n    }: {\n        socket: TSocket;\n        logger?: Logger;\n    }) {\n        super();\n        this.logger = logger;\n        this.socket = new ClientSocketMapper({ socket }) as any as TSocket;\n        this.socket.on('*', ({ type, value }) => {\n            // don't forward socket newSession, we emit a 'session' event\n            // with the session instance instead\n            if (type === 'newSession') {\n                return;\n            }\n\n            this.emit(type, value);\n            this.emit('*', { type, value });\n        });\n\n        this.socket.on('newSession', () => {\n            if (this.queue) {\n                this.emit('queueEnd');\n                this.queue = undefined;\n            }\n        });\n\n        this.on('queue' as any, (queue: ClientEvents['queue']) => {\n            this.queue = queue;\n        });\n    }\n\n    on<K extends Extract<keyof TEvents, string>>(\n        event: K,\n        listener: (value: TEvents[K]) => void\n    ): this {\n        return super.on(event, listener);\n    }\n\n    // implementation of this method depends on the class\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async startSession(config?: Partial<UserSessionConfig>): Promise<TSession> {\n        throw new Error('Not implemented');\n    }\n\n    // implementation of this method depends on the class\n    async setConfig(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        config: Partial<UserSessionConfig>\n    ): Promise<SessionConfig> {\n        throw new Error('Not implemented');\n    }\n\n    getConfig() {\n        return this._config;\n    }\n\n    protected async waitForSessionStart(session: TSession) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            const handleDisconnect = () => {\n                reject(new Error('Session disconnected before it was ready'));\n            };\n\n            const handleSessionError = (ev: any) => {\n                reject(\n                    new Error(\n                        `Session failed to start - ${\n                            typeof ev.message === 'object'\n                                ? JSON.stringify(ev.message)\n                                : ev.message\n                        }`\n                    )\n                );\n            };\n\n            // at this point we have the session, but just incase an error comes through on client we'll\n            // reject the promise too\n            const handleClientError = (ev: { message: string }) => {\n                reject(\n                    new Error(\n                        `Session failed to start - ${\n                            ev?.message ?? 'Unknown error'\n                        }`\n                    )\n                );\n            };\n\n            try {\n                this.on('error' as any, handleClientError);\n                session.on('disconnect', handleDisconnect);\n                session.on('error', handleSessionError);\n\n                await session.waitUntilReady();\n            } catch (e) {\n                reject(e);\n            } finally {\n                this.off('error', handleClientError);\n                session.off('disconnect', handleDisconnect);\n                session.off('error', handleSessionError);\n            }\n\n            resolve(session);\n        });\n    }\n}\n\nexport interface ClientEvents {\n    queue:\n        | { type: 'session'; position: number }\n        | { type: 'concurrent'; name: string; position: number };\n    queueEnd: void;\n    error: { message: string };\n    session: Session;\n}\n\nexport interface DeviceInfo {\n    type: string;\n    name: string;\n    osVersion: string;\n    orientation: 'portrait' | 'landscape';\n    screen: {\n        width: number;\n        height: number;\n        devicePixelRatio?: number;\n    };\n}\n","import { EventEmitter } from 'events';\nimport { TimeoutError } from './errors';\n\n/**\n * Waits for the function to succeed without an error. If the function throws an error, it will retry until it succeeds or the timeout is reached.\n * Alternatively, you can call the `bail` function to throw an error and stop retrying.\n */\nexport async function waitFor<T>(\n    fn: (bail: (error: Error) => void) => T | Promise<T>,\n    timeout: number | null = 5000\n): Promise<T> {\n    const start = Date.now();\n\n    let bail = false;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            const result = await fn((error) => {\n                if (error) {\n                    bail = true;\n                    throw error;\n                }\n            });\n\n            return result;\n        } catch (e) {\n            await new Promise((resolve) => setTimeout(resolve, 100));\n            if (bail || (timeout !== null && Date.now() - start > timeout)) {\n                throw e;\n            }\n        }\n    }\n}\n\nexport async function waitForTimeout(ms: number) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport interface WaitForEventOptions<T> {\n    timeout?: number | null;\n    predicate?: (data: T) => boolean;\n}\n\nexport type WaitForEventOptionsOrPredicate<T> =\n    | WaitForEventOptions<T>\n    | ((data: T) => boolean | undefined);\n\n/**\n * Waits for the event to fire on the emitter and resolves with the value\n */\nexport async function waitForEvent<T>(\n    emitter: EventEmitter,\n    event: string,\n    optionsOrPredicate?: WaitForEventOptionsOrPredicate<T>\n): Promise<T> {\n    const options =\n        typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate;\n    const predicate =\n        typeof optionsOrPredicate === 'function'\n            ? optionsOrPredicate\n            : optionsOrPredicate?.predicate;\n\n    const timeout =\n        typeof options?.timeout !== 'undefined' ? options.timeout : 10000;\n\n    return new Promise((resolve, reject) => {\n        const listener = (data) => {\n            if (!predicate || predicate(data)) {\n                emitter.off(event, listener);\n                resolve(data);\n            }\n        };\n        emitter.on(event, listener);\n\n        if (timeout !== null) {\n            setTimeout(() => {\n                emitter.off(event, listener);\n                reject(\n                    new TimeoutError(\n                        `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`\n                    )\n                );\n            }, timeout);\n        }\n    });\n}\n","import { UserSessionConfig } from './session';\nimport { cleanObject } from './util';\n\n/**\n * Parses user config and does any necessary transformations\n */\nexport function parseConfig(config?: UserSessionConfig) {\n    if (!config) {\n        return {};\n    }\n\n    return {\n        ...cleanObject(config),\n        device: (config as any).deviceType || config.device,\n    };\n}\n","import { AppetizeApp } from '../api/types/app';\nimport { Client, ClientEvents, DeviceInfo } from './client';\nimport { Logger } from '../logger';\nimport {\n    Session,\n    SessionConfig,\n    SessionEvents,\n    SessionInfo,\n    UserSessionConfig,\n} from '../session';\nimport { SocketProtocol } from '../api/types/socket';\nimport { waitFor } from '../waitFor';\nimport { AppetizeWindowProtocol } from '../window';\nimport { parseConfig } from '../config';\n\n/**\n * Any client that interacts with the /embed Appetize.io page (embed, playwright)\n */\nexport class HeadfulClient<\n    TSocket extends SocketProtocol,\n    TEvents extends HeadfulClientEvents<TSession>,\n    TSession extends Session<SessionEvents>\n> extends Client<TSocket, TEvents, TSession> {\n    device!: HeadfulDeviceInfo;\n    app?: AppetizeApp;\n\n    /**\n     * an embed can only have 1 session at a time\n     * but it can be started either by user clicking on the iframe,\n     * or by calling client.startSession(). for either case,\n     * we store that session reference here\n     */\n    protected session: TSession | undefined;\n    protected window: AppetizeWindowProtocol;\n    protected ready = false;\n\n    /**\n     * True if the client is currently requesting a session (in queue / waiting for connection)\n     */\n    protected isRequestingSession = false;\n\n    private _lastSetConfigCallId: string | null = null;\n\n    constructor({\n        socket,\n        window,\n        logger = new Logger(),\n        config,\n        autoInit = true,\n    }: {\n        autoInit?: boolean;\n        socket: TSocket;\n        window: AppetizeWindowProtocol;\n        logger?: Logger;\n        config?: SessionConfig;\n    }) {\n        super({ socket, logger });\n        this.window = window;\n\n        if (config) {\n            this.assignConfig(config);\n        }\n\n        this.window.on('*', async ({ type, value }) => {\n            if (this.ready) {\n                switch (type) {\n                    case 'app':\n                        this.app = value;\n                        this.emit(type, value);\n                        break;\n                    case 'deviceInfo':\n                        this.device = value;\n                        this.emit(type, value);\n                        break;\n                    case 'config':\n                        this.assignConfig(value);\n                        break;\n                }\n            }\n        });\n\n        this.window.on('reinit', () => {\n            this.ready = false;\n            this.session = undefined;\n\n            this.init({ isReinit: true });\n        });\n\n        this.socket.on('*', async ({ type, value }) => {\n            if (this.ready) {\n                switch (type) {\n                    // when newSession is received, create the session instance\n                    case 'newSession': {\n                        try {\n                            this.isRequestingSession = false;\n                            this.session = this.createSession(this._config!, {\n                                path: value.path,\n                                token: value.sessionToken,\n                            });\n                            await this.waitForSessionStart(this.session);\n                            this.emit('session', this.session);\n                        } catch (e) {\n                            this.session = undefined;\n                            this.emit('sessionError', e);\n                        }\n                    }\n                }\n            }\n        });\n\n        if (autoInit !== false) {\n            this.init();\n        }\n    }\n\n    protected async init(\n        args: {\n            isReinit?: boolean;\n        } = { isReinit: false }\n    ) {\n        await this.window.waitUntilReady();\n\n        const setConfig = async () => {\n            if (args.isReinit) {\n                const oldConfig = this._config;\n\n                // get the new config from the window\n                const newConfig = await this.setConfig({});\n\n                // shallowly merge the old config with the new config\n                return this.setConfig({\n                    record: true,\n                    ...oldConfig,\n                    ...newConfig,\n                });\n            } else {\n                return this.setConfig({\n                    // always set record config unless explicitly set to false\n                    record: true,\n                    ...this._config,\n                });\n            }\n        };\n        const [app, deviceInfo] = await Promise.all([\n            this.window.postMessage({ type: 'getApp' }, true),\n            this.window.postMessage<HeadfulDeviceInfo>(\n                { type: 'getDeviceInfo' },\n                true\n            ),\n            setConfig(),\n        ]);\n\n        this.app = app;\n        this.device = deviceInfo;\n        // this.setConfig already sets this._config\n\n        this.ready = true;\n    }\n\n    async waitUntilReady() {\n        if (this.ready) {\n            return;\n        }\n\n        return waitFor(async () => {\n            if (!this.ready) {\n                throw new Error('Timed out waiting for client to be ready');\n            }\n        }, 30000);\n    }\n\n    async startSession(config?: Partial<UserSessionConfig>) {\n        const wasRequestingSession = this.isRequestingSession;\n\n        // startSession can be cancelled at any point by calling endSession, so whenever we await we'll\n        // need to check if we're still requesting a session\n        const wasCancelled = () => this.isRequestingSession === false;\n        this.isRequestingSession = true;\n\n        try {\n            // wait until client is ready\n            try {\n                await this.waitUntilReady();\n            } catch (e) {\n                const message = e instanceof Error ? e.message : e;\n                throw new Error(`Failed to start session. ${message}`);\n            }\n\n            if (!wasCancelled()) {\n                if (this.session) {\n                    await this.session.end();\n                } else if (wasRequestingSession) {\n                    await this.cancelSessionRequest();\n\n                    // cancelSessionRequest will set this to false so we need to set to true again\n                    this.isRequestingSession = true;\n                }\n            }\n\n            // send through config\n            if (!wasCancelled()) {\n                await this.setConfig(config ?? {});\n            }\n\n            // wait for session to be requested and received\n            if (!wasCancelled()) {\n                // request session and wait for `session` event to be emitted off self, then resolve\n                const [session] = await Promise.all([\n                    new Promise<TSession>((resolve, reject) => {\n                        const handleResolve = (data: TSession) => {\n                            this.off('session' as any, handleResolve);\n                            this.off('sessionError' as any, handleReject);\n                            this.off('error' as any, handleReject);\n                            resolve(data);\n                        };\n\n                        const handleReject = (data: any) => {\n                            this.off('session' as any, handleResolve);\n                            this.off('sessionError' as any, handleReject);\n                            this.off('error' as any, handleReject);\n\n                            if (data instanceof Error) {\n                                reject(data);\n                            } else if (\n                                data &&\n                                typeof data.message === 'string'\n                            ) {\n                                reject(\n                                    new Error(\n                                        `Session failed to start - ${data.message}`\n                                    )\n                                );\n                            } else {\n                                reject(data);\n                            }\n                        };\n\n                        this.on('session' as any, handleResolve);\n                        this.on('sessionError' as any, handleReject);\n                        this.on('error' as any, handleReject);\n                    }),\n                    this.window.postMessage({ type: 'requestSession' }, true),\n                ]);\n\n                return session;\n            } else {\n                throw new Error('Session request was cancelled');\n            }\n        } finally {\n            this.isRequestingSession = false;\n        }\n    }\n\n    async endSession() {\n        if (this.session) {\n            await this.session.end();\n        } else if (this.isRequestingSession) {\n            await this.cancelSessionRequest();\n        }\n    }\n\n    /**\n     * @deprecated Use client.setConfig()\n     */\n    async config(args: Partial<UserSessionConfig>): Promise<UserSessionConfig> {\n        // TODO: remove in v2\n        this.logger.warn(\n            `client.config() is deprecated and will be removed in a future major release. Use client.setConfig() instead.`\n        );\n        return this.setConfig(args);\n    }\n\n    async setConfig({\n        // buildId & publicKey are not part of config object but we accept them\n        // as parameters so we can load a new app & set config in one call\n        buildId,\n        publicKey,\n        ...config\n    }: Partial<UserSessionConfig>): Promise<SessionConfig> {\n        this._lastSetConfigCallId = Math.random().toString(36);\n        const currentSetConfigCallId = this._lastSetConfigCallId;\n\n        if (!buildId && publicKey) {\n            // TODO: we are just going to silently support publicKey since 100% of projects are going to be\n            // using it. After a month or so (?) of v2, we'll enable this warning.\n            // this.logger.warn.once(\n            //     `'publicKey' is deprecated and will be removed in a future release. Please rename 'publicKey' to 'buildId'. \\n More info: https://docs.appetize.io/platform/embedding-apps`\n            // );\n            buildId = publicKey;\n        }\n\n        if (buildId) {\n            const response = await this.window.postMessage<\n                AppetizeApp | { error: string }\n            >(\n                {\n                    type: 'loadApp',\n                    value: buildId,\n                },\n                true\n            );\n\n            if (response && 'error' in response) {\n                // loadApp was cancelled from consecutive setConfig({ buildId }) calls before the app was loaded.\n                // silently return the current config as we can expect another setConfig call to be in-progress\n                if (response.error === 'cancelled') {\n                    return this._config!;\n                }\n\n                throw new Error(response.error);\n            }\n\n            // additional check for multiple setConfig calls, can be removed once frontend responds with 'cancelled' error\n            if (currentSetConfigCallId !== this._lastSetConfigCallId) {\n                return this._config!;\n            }\n        }\n\n        const validatedConfig = await this.window.postMessage<SessionConfig>(\n            {\n                type: 'setConfig',\n                value: this.validateConfig({\n                    ...config,\n                    // embed takes publicKey for this payload still\n                    ...(buildId ? { publicKey: buildId } : {}),\n                }),\n            },\n            true\n        );\n\n        return this.assignConfig(validatedConfig);\n    }\n\n    /**\n     * Updates internal _config and carries over buildId/publicKey from previous config if not defined in new config\n     *\n     * We carry it over because buildId/publicKey is not part of the config as far as the embed is concerned,\n     * so the relayed response won't contain it. The SDK keeps it in the config as a convention for the user.\n     * Eventually, we should have the embed reflect this behaviour as well.\n     */\n    protected assignConfig(config: UserSessionConfig) {\n        if (config.autoplay === true) {\n            this.logger.warn.once(\n                'autoplay=true may cause the session to start before the SDK is ready. You should start the session programmatically using client.startSession() instead.'\n            );\n        }\n\n        this._config = parseConfig(config);\n\n        return this._config;\n    }\n\n    /**\n     * Runs during this.setConfig() before sending config options to the embed. Override this\n     * to add default or validate config values\n     */\n    protected validateConfig(config: Partial<UserSessionConfig>) {\n        return config;\n    }\n\n    private async cancelSessionRequest() {\n        if (this.isRequestingSession) {\n            this.isRequestingSession = false;\n            await this.window.postMessage('endSession');\n            this.emit('sessionEnded');\n        }\n    }\n\n    /**\n     * Called by either client.startSession() or when user starts a session manually.\n     * This should simply assign this.session to a new Session instance\n     */\n    protected createSession(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        config: SessionConfig,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        info: SessionInfo\n    ): TSession {\n        throw new Error('Not implemented');\n    }\n}\n\nexport interface HeadfulClientEvents<TSession extends Session>\n    extends ClientEvents {\n    session: TSession;\n    app: AppetizeApp;\n    deviceInfo: HeadfulDeviceInfo;\n    sessionRequested: void;\n    sessionEnded: void;\n}\n\nexport interface HeadfulDeviceInfo extends DeviceInfo {\n    embed: {\n        width: number;\n        height: number;\n        screen: {\n            width: number;\n            height: number;\n            offset: {\n                x: number;\n                y: number;\n            };\n        };\n    };\n}\n","import { LogFn, Logger } from '../../core/logger';\n\n/**\n * This logger will not print to the console when silent=true.\n *\n * This is good for CI to keep output clean and only print the logs\n * after a test fails. The fixture handles this logic, and by default\n * this logger is silent when process.env.CI is true.\n */\nexport class PlaywrightLogger extends Logger {\n    logHistory: Array<{\n        method: 'log' | 'warn' | 'error' | 'debug';\n        data: any[];\n    }> = [];\n\n    logLevel: 'verbose' | 'warnings-errors' | 'none' =\n        process.env.CI === 'true' ? 'warnings-errors' : 'verbose';\n\n    log = this.createPlaywrightLogFn('log', () => this.logLevel === 'verbose');\n\n    warn = this.createPlaywrightLogFn(\n        'warn',\n        () => this.logLevel === 'verbose' || this.logLevel === 'warnings-errors'\n    );\n\n    error = this.createPlaywrightLogFn(\n        'error',\n        () => this.logLevel === 'verbose' || this.logLevel === 'warnings-errors'\n    );\n\n    debug = this.createPlaywrightLogFn(\n        'debug',\n        () => this.logLevel === 'verbose'\n    );\n\n    clearLogHistory = () => {\n        this.logHistory = [];\n    };\n\n    private createPlaywrightLogFn(\n        type: 'log' | 'warn' | 'error' | 'debug',\n        print: () => boolean\n    ) {\n        const loggedMessages = new Set<string>();\n        const context = '[Appetize]';\n\n        // preserves the original console context\n        const fn: LogFn = (...data: any[]) => {\n            this.logHistory.push({\n                method: type,\n                data,\n            });\n\n            if (print()) {\n                console[type](context, ...data);\n            }\n        };\n\n        // logs message only once, but we do lose the console context with this implementation\n        fn.once = (msg: string) => {\n            if (loggedMessages.has(msg)) {\n                return;\n            } else {\n                loggedMessages.add(msg);\n            }\n\n            return fn.call(console, msg);\n        };\n\n        return fn;\n    }\n}\n\nexport const logger = new PlaywrightLogger();\n","export function uint8ArrayToString(uint8Arr: Uint8Array) {\n    const length = uint8Arr.length;\n    let result = '';\n    for (let i = 0; i < length; i += 65535) {\n        let addition = 65535;\n        if (i + 65535 > length) {\n            addition = length - i;\n        }\n        result += String.fromCharCode.apply(\n            null,\n            uint8Arr.subarray(i, i + addition) as unknown as number[]\n        );\n    }\n    return result;\n}\n\nexport function uint8ArrayToBase64(uint8Arr: Uint8Array, mimeType: string) {\n    // if we're in node, use Buffer.from for faster conversion\n    if (typeof window === 'undefined' && typeof Buffer !== 'undefined') {\n        const str = Buffer.from(uint8Arr).toString('base64');\n        return `data:${mimeType};base64,` + str;\n    } else {\n        const str = uint8ArrayToString(uint8Arr);\n        const base64String = btoa(str);\n        return `data:${mimeType};base64,` + base64String;\n    }\n}\n","import { OperationalError } from '../errors';\nimport { SwipeMove } from '../api/types/recorder';\n\nexport interface SwipeGestureArgs {\n    duration?: number;\n    stepDuration?: number;\n}\n\nexport class SwipeGesture {\n    private moves: Movement[] = [];\n    private duration?: number;\n    private stepDuration: number;\n\n    constructor({ duration, stepDuration }: SwipeGestureArgs) {\n        this.duration = duration;\n        this.stepDuration = stepDuration ?? 16;\n\n        this.moves = [{ x: 0, y: 0 }];\n    }\n\n    to(x: string, y: string) {\n        if (typeof x !== 'string' || typeof y !== 'string') {\n            throw new OperationalError(\n                'x and y must be strings and in percentages (e.g. \"50%\")'\n            );\n        }\n\n        if (!x.endsWith('%') || !y.endsWith('%')) {\n            throw new OperationalError(\n                'x and y must be in percentages (e.g. \"50%\")'\n            );\n        }\n\n        this.moves.push({\n            x: parseFloat(x) / 100,\n            y: parseFloat(y) / 100,\n        });\n\n        return this;\n    }\n\n    // undecided if we want to support this\n    // move(x: string, y: string) {\n    //     if (typeof x !== 'string' || typeof y !== 'string') {\n    //         throw new Error(\n    //             'x and y must be strings and in percentages (e.g. \"50%\")'\n    //         );\n    //     }\n\n    //     if (!x.endsWith('%') || !y.endsWith('%')) {\n    //         throw new Error('x and y must be in percentages (e.g. \"50%\")');\n    //     }\n\n    //     const previous = this.moves[this.moves.length - 1];\n\n    //     this.moves.push({\n    //         x: (previous?.x ?? 0) + parseFloat(x) / 100,\n    //         y: (previous?.y ?? 0) + parseFloat(y) / 100,\n    //     });\n\n    //     return this;\n    // }\n\n    wait(duration: number) {\n        const previous = this.moves[this.moves.length - 1];\n        if (previous) {\n            previous.wait = duration + (previous.wait ?? 0);\n        }\n\n        return this;\n    }\n\n    build() {\n        const stepDuration = this.stepDuration;\n\n        const duration =\n            this.duration ??\n            Math.max(500, stepDuration * (this.moves.length - 1));\n\n        const totalSteps = Math.floor(duration / stepDuration);\n        const stepsPerSegment = Math.floor(\n            totalSteps / (this.moves.length - 1)\n        );\n\n        const result: SwipeMove[] = [];\n        let accruedWaitTime = 0;\n\n        if (stepsPerSegment === 0) {\n            const requiredDuration = (this.moves.length - 1) * stepDuration;\n\n            throw new Error(\n                `Duration is too short for ${\n                    this.moves.length - 1\n                } moves, please set duration to at least ${requiredDuration}ms`\n            );\n        }\n\n        for (let i = 0; i < this.moves.length - 1; i++) {\n            const lowerCoord = this.moves[i];\n            const upperCoord = this.moves[i + 1];\n            const isLastPair = i === this.moves.length - 2;\n\n            for (let step = 0; step <= stepsPerSegment; step++) {\n                // Skip the last step for all pairs except the final one to prevent duplicates\n                if (!isLastPair && step === stepsPerSegment) continue;\n\n                const progress = step / stepsPerSegment;\n                const interpolatedX =\n                    lowerCoord.x + progress * (upperCoord.x - lowerCoord.x);\n                const interpolatedY =\n                    lowerCoord.y + progress * (upperCoord.y - lowerCoord.y);\n                const t =\n                    ((i * stepsPerSegment + step) * stepDuration +\n                        accruedWaitTime) /\n                    1000;\n\n                result.push({ x: interpolatedX, y: interpolatedY, t });\n\n                // If the current pair has a wait time, add duplicate point\n                // with extended ts\n                if (step === 0 && lowerCoord.wait) {\n                    result.push({\n                        x: interpolatedX,\n                        y: interpolatedY,\n                        t: t + lowerCoord.wait / 1000,\n                    });\n                    accruedWaitTime += lowerCoord.wait;\n                }\n            }\n\n            // if the last move was a wait, duplicate the last point and extend the ts\n            if (i === this.moves.length - 2 && upperCoord.wait) {\n                const lastResult = result[result.length - 1];\n                result.push({\n                    x: lastResult.x,\n                    y: lastResult.y,\n                    t: lastResult.t + upperCoord.wait / 1000,\n                });\n            }\n        }\n        return result;\n    }\n\n    up(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to('0%', `-${value}%`);\n    }\n\n    down(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to('0%', `${value}%`);\n    }\n\n    left(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to(`-${value}%`, '0%');\n    }\n\n    right(distance = '50%') {\n        const value = parseFloat(distance);\n        return this.to(`${value}%`, '0%');\n    }\n}\n\ninterface Movement {\n    x: number;\n    y: number;\n    wait?: number;\n}\n","import { EventEmitter } from '../../EventEmitter';\nimport { Platform, ScreenBounds } from '../types/recorder/common';\nimport { AppetizeApp } from '../types/app';\nimport { DeviceInfo } from '../../client';\nimport { SessionConfig } from '../../session';\nimport { SocketProtocol } from '../types/socket';\nimport { SessionEventMapper } from './event';\n\n/**\n * Wraps an Appetize socket and maps payloads to and from the public API.\n */\nexport class SessionSocketMapper\n    extends EventEmitter\n    implements SocketProtocol\n{\n    platform: Platform;\n    screen: ScreenBounds;\n    app?: AppetizeApp;\n    private _socket: SocketProtocol;\n\n    constructor({\n        socket,\n        platform,\n        screen,\n        app,\n    }: {\n        socket: SocketProtocol;\n        platform: Platform;\n        screen: ScreenBounds;\n        app?: AppetizeApp;\n    }) {\n        super();\n        this._socket = socket;\n        this.platform = platform;\n        this.screen = screen;\n        this.app = app;\n\n        socket.on('*', ({ type, value }) => {\n            const mapped = this.mapEmit(type, value);\n            const suppressed = mapped === null;\n\n            if (!suppressed) {\n                this.handleEvent(mapped.type, mapped.value);\n                this.emit(mapped.type, mapped.value);\n                this.emit('*', mapped);\n            }\n        });\n    }\n\n    send(event: string, data?: any): Promise<void> {\n        const mapped = this.mapSend(event, data);\n        return this._socket.send(mapped.type, mapped.value);\n    }\n\n    disconnect(): Promise<void> {\n        return this._socket.disconnect();\n    }\n\n    private handleEvent(type: string, value: any) {\n        // update app, screen, platform for mappers\n        switch (type) {\n            case 'app':\n                this.app = value;\n                break;\n            case 'deviceInfo': {\n                const deviceInfo = value as DeviceInfo;\n                if (deviceInfo?.screen) {\n                    this.screen = deviceInfo.screen;\n                }\n                break;\n            }\n            case 'config': {\n                const config = value as SessionConfig;\n                if (config.platform) {\n                    this.platform = config.platform;\n                }\n                break;\n            }\n        }\n    }\n\n    private mapEmit(type: string, value: any) {\n        const eventMapper = new SessionEventMapper({\n            platform: this.platform,\n            screen: this.screen,\n            app: this.app,\n        });\n\n        return eventMapper.toPublic(type, value);\n    }\n\n    private mapSend(type: string, value: any) {\n        const eventMapper = new SessionEventMapper({\n            platform: this.platform,\n            screen: this.screen,\n            app: this.app,\n        });\n\n        return eventMapper.toInternal(type, value);\n    }\n}\n","import {\n    LiteralUnion,\n    OmitUnion,\n    createDeferredPromise,\n    uuid,\n} from '../../core/util';\nimport {\n    WaitForEventOptions,\n    waitFor,\n    waitForEvent,\n    waitForTimeout,\n} from '../../core/waitFor';\nimport { EventEmitter } from '../EventEmitter';\n\nimport {\n    Action,\n    Element,\n    ElementSelector,\n    FindElementsAction,\n    PlayActionErrorResponse,\n    PlayActionOptions,\n    PlayActionResult,\n    RecordedAction,\n    SwipeAction,\n    TapAction,\n} from '../api/types/recorder';\nimport { AllUI } from '../api/types/recorder/public';\nimport { AppetizeApp } from '../api/types/app';\nimport { uint8ArrayToBase64 } from '../buffer';\nimport { SwipeGesture } from '../builders/swipe-gesture';\nimport { DeviceInfo } from '../client';\nimport {\n    ActionAmbiguousElementError,\n    ActionElementNotFoundError,\n    ActionError,\n    ActionInternalError,\n    ActionInvalidArgumentError,\n    ActionTimeoutError,\n    OperationalError,\n    RecorderRequiredError,\n    TimeoutError,\n    captureOperationalError,\n} from '../errors';\nimport { Logger } from '../logger';\nimport { SocketProtocol } from '../api/types/socket';\nimport { SessionSocketMapper } from '../api/mappers/session-socket';\nimport { DataValidator } from '../api/parser';\n\nexport interface SessionArgs {\n    path: string;\n    token: string;\n    socket: SocketProtocol;\n    config: SessionConfig;\n    device: DeviceInfo;\n    logger: Logger;\n    app?: AppetizeApp;\n}\nexport class Session<\n    Events extends SessionEvents = SessionEvents\n> extends EventEmitter {\n    socket: SocketProtocol;\n    logger: Logger;\n\n    path: string;\n    token: string;\n\n    app?: AppetizeApp;\n    device: DeviceInfo;\n    config: SessionConfig;\n    #adbConnection?: AdbConnectionInfo;\n    #networkInspectorUrl?: string;\n\n    /**\n     * Session is ending due to session.end()\n     */\n    protected isEndingManually = false;\n\n    /**\n     * Countdown warning due to inactivity has been received\n     */\n    protected countdownWarning = false;\n\n    protected ready = false;\n\n    private _waitForAnimationsPromises: Set<Promise<void>> = new Set();\n\n    constructor({\n        socket,\n        config,\n        path,\n        token,\n        app,\n        device,\n        logger = new Logger(),\n    }: SessionArgs) {\n        super();\n        this.config = config;\n        this.socket = new SessionSocketMapper({\n            socket,\n            app,\n            screen: device.screen,\n            platform: config.platform!,\n        });\n        this.device = device;\n        this.app = app;\n        this.path = path;\n        this.token = token;\n        this.logger = logger;\n\n        const handleSocketEvent = ({ type, value }) => {\n            switch (type) {\n                case 'ready':\n                    this.ready = true;\n                    break;\n                case 'adbOverTcp': {\n                    this.#adbConnection = {\n                        ...value,\n                        command: getAdbShellCommand(value),\n                    };\n                    break;\n                }\n                case 'networkInspectorUrl':\n                    this.#networkInspectorUrl = value;\n                    break;\n                case 'countdownWarning':\n                    this.countdownWarning = true;\n                    break;\n                case 'timeoutReset':\n                    this.countdownWarning = false;\n                    break;\n                case 'deviceInfo':\n                    this.device = value;\n                    break;\n                case 'disconnect':\n                    this.emit('end');\n                    this.emit('*', { type: 'end' });\n                    break;\n            }\n\n            this.emit(type, value);\n            this.emit('*', { type, value });\n        };\n\n        this.socket.on('*', handleSocketEvent);\n\n        /**\n         * remove socket event handler on disconnect\n         *\n         * this is important for embed/playwright, where the \"socket\" is\n         * a connection to the iframe. if the session ends, the iframe/page may still\n         * exist, so we need to \"disconnect\" this session instance from future postMessages.\n         * otherwise, event listeners on the \"old\" session will fire.\n         */\n        this.on('disconnect' as Extract<keyof Events, string>, () => {\n            this.socket.off('*', handleSocketEvent);\n\n            if (!this.isEndingManually) {\n                if (this.countdownWarning) {\n                    this.logger.warn(\n                        `Appetize session has ended due to inactivity`\n                    );\n                } else {\n                    this.logger.warn(`Session disconnected`);\n                }\n            }\n        });\n    }\n\n    on<K extends Extract<keyof Events, string>>(\n        event: K,\n        listener: (value: Events[K]) => void\n    ): this {\n        if (event === 'network' && this.config.proxy !== 'intercept') {\n            this.logger.warn(\n                'Session must be configured with `proxy: \"intercept\"` to listen to network events.'\n            );\n        }\n\n        if (event === 'log' && this.config.debug !== true) {\n            this.logger.warn(\n                'Session must be configured with `debug: true` to listen to log events.'\n            );\n        }\n\n        if (event === 'action' && this.config.record !== true) {\n            this.logger.warn(\n                'Session must configured with `record: true` to listen to action events.'\n            );\n        }\n\n        return super.on(event, listener);\n    }\n\n    async waitUntilReady() {\n        let isConnected = true;\n\n        // we would like certain properties to be defined on the session before we resolve,\n        // but we don't want to block the session from starting if not. so we wait a max of 3s\n        const waitForValue = async (cb: () => boolean) => {\n            return new Promise((res) => {\n                const interval = setInterval(() => {\n                    if (cb()) {\n                        res(undefined);\n                    }\n                }, 10);\n\n                setTimeout(() => {\n                    clearInterval(interval);\n                    res(undefined);\n                }, 3000);\n            });\n        };\n\n        const handleDisconnect = () => {\n            isConnected = false;\n        };\n\n        this.socket.once('disconnect', handleDisconnect);\n\n        // we could be at 'switching device' state, which if we're running against a single server\n        // can take a long time when it's under load, so we give it a generous timeout\n        try {\n            await waitFor((bail) => {\n                if (this.ready) {\n                    return;\n                }\n\n                if (isConnected) {\n                    throw new TimeoutError(\n                        'Timed out after 180s waiting for session to be ready'\n                    );\n                } else {\n                    bail(new Error('Session disconnected'));\n                }\n            }, 180000);\n        } finally {\n            this.socket.off('disconnect', handleDisconnect);\n        }\n\n        // wait for properties\n        await Promise.all([\n            this.config.proxy === 'intercept'\n                ? waitForValue(() => Boolean(this.#networkInspectorUrl))\n                : Promise.resolve(),\n            this.config.enableAdb\n                ? waitForValue(() => Boolean(this.#adbConnection))\n                : Promise.resolve(),\n        ]);\n    }\n\n    async waitForEvent<K extends keyof SessionEvents>(\n        event: K,\n        options?: WaitForEventOptions<SessionEvents[K]>\n    ) {\n        try {\n            return await waitForEvent(this, event, options);\n        } catch (e) {\n            captureOperationalError(e, this.waitForEvent);\n            throw e;\n        }\n    }\n\n    /**\n     * Ends the current session\n     */\n    async end() {\n        this.isEndingManually = true;\n        await this.socket.disconnect();\n    }\n\n    get networkInspectorUrl() {\n        if (this.config.proxy !== 'intercept') {\n            this.logger.warn(\n                'Session must be configured with `proxy: \"intercept\"` to use the network inspector'\n            );\n        }\n\n        return this.#networkInspectorUrl;\n    }\n\n    get adbConnection() {\n        if (this.config.platform && this.config.platform !== 'android') {\n            this.logger.warn(\n                'Session must be connected to an Android device to use adb'\n            );\n        }\n\n        if (!this.config.enableAdb) {\n            this.logger.warn(\n                'Session must be configured with `enableAdb: true` to use adb'\n            );\n        }\n\n        if (this.#adbConnection) {\n            return this.#adbConnection;\n        }\n    }\n\n    /**\n     * Rotates the device left or right by 90 degrees\n     */\n\n    async rotate(\n        direction: 'left' | 'right'\n    ): Promise<'portrait' | 'landscape'> {\n        try {\n            const [orientation] = await Promise.all([\n                this.waitForEvent('orientationChanged'),\n                this.socket.send('userInteraction', {\n                    type: 'keypress',\n                    key: direction === 'left' ? 'rotateLeft' : 'rotateRight',\n                    timeStamp: Date.now(),\n                }),\n            ]);\n\n            return orientation;\n        } catch (e) {\n            captureOperationalError(e, this.rotate);\n            throw e;\n        }\n    }\n\n    /**\n     * Takes a screenshot of the device. Format returned can be either 'buffer' or 'base64'.\n     *\n     * If buffer format is requested on browser and Buffer is not polyfilled the result will be a Uint8Array.\n     */\n    async screenshot<\n        T extends 'buffer' | 'base64',\n        Data = T extends 'buffer' ? Buffer : string\n    >(\n        format: T = 'buffer' as T\n    ): Promise<{\n        data: Data;\n        mimeType: string;\n    }> {\n        try {\n            this.socket.send('getScreenshot', {});\n\n            const result = await waitForEvent<{\n                data: Uint8Array;\n                success: boolean;\n                mimeType: string;\n                error?: string;\n            }>(this.socket, 'screenshot', { timeout: 60000 });\n\n            if (!result.success) {\n                throw new OperationalError(result.error ?? `Screenshot failed`);\n            }\n\n            // if on Node, convert to buffer. otherwise leave as Uint8Array\n            const toBuffer = (data: Uint8Array) => {\n                return typeof window === 'undefined' ? Buffer.from(data) : data;\n            };\n\n            const data =\n                format === 'buffer'\n                    ? (toBuffer(result.data) as unknown as Data)\n                    : (uint8ArrayToBase64(\n                          new Uint8Array(result.data),\n                          result.mimeType\n                      ) as unknown as Data);\n\n            return {\n                data,\n                mimeType: result.mimeType,\n            };\n        } catch (e) {\n            captureOperationalError(e, this.screenshot);\n            throw e;\n        }\n    }\n\n    /**\n     * Sends a heartbeat to the appetize server. This will reset the inactivity timer.\n     **/\n    async heartbeat() {\n        try {\n            return await this.socket.send('heartbeat');\n        } catch (e) {\n            captureOperationalError(e, this.heartbeat);\n            throw e;\n        }\n    }\n\n    /**\n     * Types the given text\n     */\n    async type(text: string) {\n        try {\n            // on both iOS and Android, if a type comes after a tap on an input,\n            // there seems to be a necessary delay for accurate typing.\n            // TODO: a better solution here would be to track whether or not a tap was\n            // the last action, and if so, do this wait.\n            await waitForTimeout(1000);\n\n            const result = await this.playAction({\n                type: 'typeText',\n                text: text,\n            });\n\n            // incase the user is tapping on an input next, wait an additional 500ms\n            await waitForTimeout(500);\n\n            return result;\n        } catch (e) {\n            captureOperationalError(e, this.type);\n            throw e;\n        }\n    }\n\n    /**\n     * Sends a keypress event to the device.\n     */\n    async keypress(key: KeyValue, options?: { shift?: boolean }) {\n        try {\n            // temporary, until backend can emit this as a keypress\n            if (key === 'ANDROID_KEYCODE_MENU') {\n                return await this.socket.send('androidKeycodeMenu');\n            }\n\n            // if shift, we need to use legacy keypress api\n            // character: 'HOME' not supported on android, will fix later.\n            if (options?.shift || key === 'HOME') {\n                switch (key) {\n                    case 'ArrowUp':\n                        key = 'arrowUp';\n                        break;\n                    case 'ArrowDown':\n                        key = 'arrowDown';\n                        break;\n                    case 'ArrowLeft':\n                        key = 'arrowLeft';\n                        break;\n                    case 'ArrowRight':\n                        key = 'arrowRight';\n                        break;\n                    case 'Enter':\n                        key = '\\r';\n                        break;\n                    case 'Tab':\n                        key = '\\t';\n                        break;\n                    case 'Backspace':\n                        key = '\\b';\n                        break;\n                }\n\n                return this.playAction({\n                    type: 'keypress',\n                    key,\n                    shiftKey: !!options?.shift,\n                });\n            } else {\n                return this.playAction({\n                    type: 'keypress',\n                    character: key,\n                });\n            }\n        } catch (e) {\n            captureOperationalError(e, this.keypress);\n            throw e;\n        }\n    }\n\n    /**\n     * Sets the language and restarts the app\n     */\n    async setLanguage(language: string) {\n        try {\n            this.config.language = language;\n            return await this.socket.send('setLanguage', {\n                language,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.setLanguage);\n            throw e;\n        }\n    }\n\n    /**\n     * Sets the location with the given latitude and longitude\n     */\n    async setLocation(latitude: number, longitude: number) {\n        try {\n            if (typeof latitude !== 'number' || typeof longitude !== 'number') {\n                throw new OperationalError(\n                    `setLocation requires latitude and longitude to be numbers`\n                );\n            }\n\n            const location = [latitude, longitude];\n            this.config.location = location;\n\n            return await this.socket.send('setLocation', {\n                location: location,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.setLocation);\n            throw e;\n        }\n    }\n\n    /**\n     * Opens a deep-link or regular URL\n     */\n    async openUrl(url: string) {\n        try {\n            return await this.socket.send('openUrl', {\n                url: url,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.openUrl);\n            throw e;\n        }\n    }\n\n    /**\n     * Launch an application by the app's ID.\n     * Android also accepts a format of <PACKAGE_NAME>/<ACTIVITY_NAME>\n     * Default activity name for Android will be resolved if it's not passed here\n     */\n    async launchApp(appId: string) {\n        try {\n            return await this.socket.send('launchApp', {\n                appId,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.launchApp);\n            throw e;\n        }\n    }\n\n    /**\n     * Sends shake gesture (iOS only)\n     */\n    async shake() {\n        try {\n            return await this.socket.send('shakeDevice');\n        } catch (e) {\n            captureOperationalError(e, this.swipe);\n            throw e;\n        }\n    }\n\n    async toggleSoftKeyboard() {\n        try {\n            if (this.config.platform !== 'ios') {\n                throw new Error(\n                    'toggleSoftKeyboard is only available on iOS devices'\n                );\n            }\n            return await this.socket.send('toggleSoftKeyboard');\n        } catch (e) {\n            captureOperationalError(e, this.toggleSoftKeyboard);\n            throw e;\n        }\n    }\n\n    /**\n     * Simulate a matching fingerprint (Android 8+ only)\n     */\n    async biometry({ match }: { match: boolean }) {\n        try {\n            return await this.socket.send(\n                match ? 'biometryMatch' : 'biometryNonMatch'\n            );\n        } catch (e) {\n            captureOperationalError(e, this.biometry);\n            throw e;\n        }\n    }\n\n    /**\n     * Upload media to the simulator.\n     * @param file The file we want to upload to the running device\n     */\n    async addMedia(file: File) {\n        if (file.size > 50 * 1024 * 1024) {\n            // client-side check file size <= 50 MB\n            throw new Error(\n                'Your proposed upload exceeds the maximum allowed size of 50MB'\n            );\n        }\n\n        try {\n            const endpoint = `${this.path}/session/${this.token}/addMedia`;\n            // Headers only support ISO-8859-1 characters\n            // eslint-disable-next-line no-control-regex\n            const invalidFileNameExpression = /[^\\u0000-\\u00ff]/g;\n            const filename = file.name.replace(invalidFileNameExpression, '-');\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                body: file,\n                headers: {\n                    'X-Appetize-File-Name': filename,\n                    'Content-Type': file.type,\n                },\n            });\n\n            if (!response.ok) {\n                const message = await response.text();\n                throw new Error(\n                    `Failed to upload media file. Received ${response.status} - ${message}`\n                );\n            }\n            return response;\n        } catch (error) {\n            captureOperationalError(error, this.addMedia);\n            throw error;\n        }\n    }\n\n    /**\n     * Sets biometry enrollment status (iOS only)\n     */\n    async biometryEnrollment(isEnrolled: boolean) {\n        try {\n            if (this.config.platform !== 'ios') {\n                throw new Error(\n                    'biometryEnrollment is only available on iOS devices'\n                );\n            }\n\n            return await this.socket.send('biometryEnrollment', { isEnrolled });\n        } catch (e) {\n            captureOperationalError(e, this.biometryEnrollment);\n            throw e;\n        }\n    }\n\n    /**\n     * Whether or not to allow interactions from the user on the device\n     */\n    async allowInteractions(allow: boolean): Promise<void> {\n        try {\n            return await this.socket.send(\n                allow ? 'enableInteractions' : 'disableInteractions'\n            );\n        } catch (e) {\n            captureOperationalError(e, this.allowInteractions);\n            throw e;\n        }\n    }\n\n    /**\n     * Restarts the app\n     */\n    async restartApp() {\n        try {\n            if (this.isStandalone) {\n                this.logger.warn('restartApp has no effect on a Standalone');\n            } else {\n                this.socket.send('restartApp');\n                await this.waitForEvent('appLaunch', { timeout: 60000 });\n            }\n        } catch (e) {\n            captureOperationalError(e, this.restartApp);\n            throw e;\n        }\n    }\n\n    /**\n     * Reinstalls the app\n     */\n    async reinstallApp() {\n        try {\n            if (this.isStandalone) {\n                this.logger.warn('reinstallApp has no effect on a Standalone');\n            } else {\n                this.socket.send('reinstallApp');\n                await this.waitForEvent('appLaunch', { timeout: 60000 });\n            }\n        } catch (e) {\n            captureOperationalError(e, this.reinstallApp);\n            throw e;\n        }\n    }\n\n    async adbShellCommand(command: string) {\n        if (this.config.platform !== 'android') {\n            throw new Error(\n                'adbShellCommand is only available on Android devices'\n            );\n        }\n\n        try {\n            return await this.socket.send('adbShellCommand', {\n                command,\n                timeStamp: Date.now(),\n            });\n        } catch (e) {\n            captureOperationalError(e, this.adbShellCommand);\n            throw e;\n        }\n    }\n\n    async playAction<T extends Action | RecordedAction>(\n        action: T,\n        options: PlayActionOptions<T> = {}\n    ): Promise<PlayActionResult<T>> {\n        const { timeout = 10000 } = options;\n\n        /**\n         *  appetizer has a max timeout of 10s per playAction\n         */\n        const MAX_APP_RECORDER_TIMEOUT = 10000;\n\n        /**\n         * the longest we'll wait for appetizer to respond before throwing a timeout error.\n         * this is to prevent the session from hanging if the server doesn't respond\n         * (it's possible the server is slow, so it's generous)\n         *\n         * this can cause playAction() to run for up to this value past options.timeout, but it's\n         * better than hanging forever or timing out too early.\n         */\n        const MAX_WAIT_FOR_RESPONSE = timeout + 30000;\n\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('playAction()');\n            }\n\n            if (isNaN(timeout)) {\n                throw new OperationalError(\n                    `Invalid timeout value: ${options.timeout}`\n                );\n            }\n\n            if (timeout < 0) {\n                throw new OperationalError(\n                    `Timeout value cannot be negative: ${options.timeout}`\n                );\n            }\n\n            if ('element' in action && action.element) {\n                DataValidator.isValidElementSelector(action.element);\n            }\n\n            const payload = {\n                id: uuid(),\n                action,\n                options: {\n                    ...options,\n                    timeout: Math.round(\n                        // appetizer has a max timeout of 10s per playAction event\n                        // (we will keep retrying until we use up the full timeout)\n                        Math.min(timeout, MAX_APP_RECORDER_TIMEOUT) / 1000\n                    ),\n                },\n            };\n\n            try {\n                const result = await new Promise<PlayActionResult<T>>(\n                    (resolve, reject) => {\n                        // set a hard timeout for incase the server doesn't respond within API_MAX_TIMEOUT\n                        const hardTimeout = setTimeout(() => {\n                            cleanup();\n                            reject(\n                                new ActionTimeoutError(\n                                    {\n                                        id: payload.id,\n                                        action: action as Action,\n                                        timeout: payload.options.timeout,\n                                    },\n                                    `Timed out waiting for response from device`\n                                )\n                            );\n                        }, MAX_WAIT_FOR_RESPONSE);\n\n                        const cleanup = () => {\n                            this.off('playbackFoundAndSent', handleSuccess);\n                            this.off('playbackError', handleError);\n                            clearTimeout(hardTimeout);\n                        };\n\n                        const handleSuccess = async (\n                            value: PlayActionResult<any>\n                        ) => {\n                            if (value.playback?.id !== payload.id) return;\n\n                            cleanup();\n                            resolve(value);\n                        };\n\n                        const handleError = async (\n                            error: PlayActionErrorResponse<Action>\n                        ) => {\n                            if (error.playback?.id !== payload.id) return;\n\n                            cleanup();\n\n                            switch (error.errorId) {\n                                case 'internalError':\n                                    reject(new ActionInternalError(error));\n                                    break;\n                                case 'notFound': {\n                                    reject(\n                                        new ActionElementNotFoundError(error)\n                                    );\n                                    break;\n                                }\n                                case 'ambiguousMatch':\n                                    reject(\n                                        new ActionAmbiguousElementError(error)\n                                    );\n                                    break;\n                                case 'invalidArgument': {\n                                    reject(\n                                        new ActionInvalidArgumentError(error)\n                                    );\n                                    break;\n                                }\n                                default:\n                                    reject(new ActionError(error));\n                                    break;\n                            }\n                        };\n\n                        this.on('playbackFoundAndSent' as any, handleSuccess);\n                        this.on('playbackError' as any, handleError);\n                        this.socket.send('playAction', payload);\n                    }\n                );\n\n                return result;\n            } catch (e) {\n                const remainingTimeout = Math.max(\n                    0,\n                    timeout - MAX_APP_RECORDER_TIMEOUT\n                );\n\n                // if not an internal or hard timeout error, try again until timeout elapsed\n                if (\n                    remainingTimeout > 0 &&\n                    !(e instanceof ActionTimeoutError) &&\n                    !(e instanceof ActionInternalError)\n                ) {\n                    return await this.playAction(action, {\n                        ...options,\n                        timeout: remainingTimeout,\n                    });\n                }\n\n                throw e;\n            }\n        } catch (e) {\n            captureOperationalError(e, this.playAction);\n            throw e;\n        }\n    }\n\n    async playActions<T extends Action | RecordedAction>(\n        actions: T[],\n        options: PlayActionOptions<any> = {}\n    ) {\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('playActions()');\n            }\n\n            const results: PlayActionResult<any>[] = [];\n\n            for (const action of actions) {\n                const result = await this.playAction(action, options);\n\n                results.push(result);\n\n                const nextAction = actions[actions.indexOf(action) + 1];\n\n                const isConsecutiveKeypress =\n                    nextAction &&\n                    nextAction.type === 'keypress' &&\n                    action.type === 'keypress';\n\n                // wait between each action unless we are playing back consecutive keypresses\n                if (!isConsecutiveKeypress) {\n                    // wait for animations to settle on screen for up to 2s\n                    await this.waitForAnimations({ timeout: 2000 }).catch(\n                        () => {\n                            // no-op - continue if animations haven't settled yet\n                        }\n                    );\n                }\n            }\n\n            return results;\n        } catch (e) {\n            captureOperationalError(e, this.playActions);\n            throw e;\n        }\n    }\n\n    async getUI({\n        timeout = 30000,\n    }: {\n        timeout?: number;\n    } = {}) {\n        try {\n            this.socket.send('dumpUi');\n\n            const data = await waitForEvent<AllUI>(this, 'uiDump', {\n                timeout,\n            });\n\n            return data;\n        } catch (e) {\n            captureOperationalError(e, this.getUI);\n            throw e;\n        }\n    }\n\n    async findElement(\n        element: ElementSelector,\n        options?: PlayActionOptions<FindElementsAction> &\n            Pick<FindElementsAction, 'appId'>\n    ): Promise<Element | undefined> {\n        try {\n            const result = await this.playAction(\n                {\n                    type: 'findElements',\n                    element,\n                    appId: options?.appId,\n                },\n                options\n            );\n\n            return result.matchedElements?.[0];\n        } catch (e) {\n            captureOperationalError(e, this.findElement);\n            throw e;\n        }\n    }\n\n    async findElements(\n        element: ElementSelector,\n        options?: PlayActionOptions<FindElementsAction> &\n            Pick<FindElementsAction, 'appId'>\n    ) {\n        try {\n            const result = await this.playAction(\n                {\n                    type: 'findElements',\n                    element,\n                    appId: options?.appId,\n                },\n                options\n            );\n\n            return result.matchedElements;\n        } catch (e) {\n            captureOperationalError(e, this.findElements);\n            throw e;\n        }\n    }\n\n    /**\n     * Taps on the screen\n     */\n    async tap(\n        args: OmitUnion<TapAction, 'type' | 'id'>,\n        options?: PlayActionOptions<TapAction>\n    ) {\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('tap()');\n            }\n            return await this.playAction(\n                {\n                    type: 'tap',\n                    ...args,\n                    duration: (args.duration ?? 0) / 1000,\n                },\n                options\n            );\n        } catch (e) {\n            captureOperationalError(e, this.tap);\n            throw e;\n        }\n    }\n\n    /**\n     * Swipes on the screen\n     */\n    async swipe(\n        { duration, gesture, ...args }: SwipeArgs,\n        options?: PlayActionOptions<SwipeAction>\n    ) {\n        try {\n            if (!this.config.record) {\n                throw new RecorderRequiredError('swipe()');\n            }\n\n            let action: SwipeAction;\n            const g = new SwipeGesture({\n                duration,\n                // @ts-expect-error - experimental api option\n                stepDuration: args.stepDuration,\n            });\n\n            if (typeof gesture === 'function') {\n                gesture(g);\n            } else {\n                switch (gesture) {\n                    case 'up':\n                        g.up();\n                        break;\n                    case 'down':\n                        g.down();\n                        break;\n                    case 'left':\n                        g.left();\n                        break;\n                    case 'right':\n                        g.right();\n                        break;\n                }\n            }\n\n            if ('element' in args) {\n                action = {\n                    type: 'swipe',\n                    element: args.element,\n                    localPosition: args.localPosition,\n                    moves: g.build(),\n                } as SwipeAction;\n            } else if ('position' in args) {\n                action = {\n                    type: 'swipe',\n                    position: args.position,\n                    moves: g.build(),\n                } as SwipeAction;\n            } else {\n                throw new Error('Either element or position must be specified');\n            }\n\n            return this.playAction(action, options);\n        } catch (e) {\n            captureOperationalError(e, this.swipe);\n            throw e;\n        }\n    }\n\n    /**\n     * Waits until the there are no ongoing animations the screen\n     * by waiting for the image to stabilize for at least 1 second\n     */\n    async waitForAnimations(\n        options: {\n            /**\n             * The threshold for the amount of pixels (in %) that can change between frames\n             * before the image is considered to be stable\n             *\n             * @default 0.01\n             */\n            imageThreshold?: number;\n\n            /**\n             * The maximum amount of time to wait for the image to stabilize\n             *\n             * @default 10000\n             */\n            timeout?: number;\n        } = {}\n    ) {\n        try {\n            const { imageThreshold = 0.001, timeout = 10000 } = options;\n\n            let imageThresholdDuration = 1000;\n            let lowestImageThreshold = 1;\n\n            // this is undocumented - we're not sure we want to expose this yet\n            if ((options as any).imageThresholdDuration) {\n                imageThresholdDuration = (options as any)\n                    .imageThresholdDuration;\n            }\n\n            const { promise, resolve, reject } = createDeferredPromise();\n\n            const timeoutId = setTimeout(() => {\n                let msg = `Timed out after ${timeout}ms waiting for animation to end.`;\n\n                if (imageThreshold < lowestImageThreshold) {\n                    msg += ` Waited for imageThreshold of ${imageThreshold} but lowest was ${\n                        Math.round(lowestImageThreshold * 10000) / 10000\n                    }`;\n                }\n\n                reject(new TimeoutError(msg));\n            }, timeout);\n\n            let lastTimeUnderThreshold: number | undefined;\n\n            const handlePixelsChanged = ({\n                percentage,\n                timestamp,\n            }: {\n                percentage: number;\n                timestamp: number;\n            }) => {\n                if (percentage < lowestImageThreshold) {\n                    lowestImageThreshold = percentage;\n                }\n\n                if (percentage <= imageThreshold) {\n                    if (!lastTimeUnderThreshold) {\n                        lastTimeUnderThreshold = timestamp;\n                    }\n\n                    if (\n                        lastTimeUnderThreshold &&\n                        timestamp - lastTimeUnderThreshold >=\n                            imageThresholdDuration\n                    ) {\n                        resolve();\n                    }\n                } else {\n                    lastTimeUnderThreshold = undefined;\n                }\n            };\n\n            this.socket.send('enablePixelChangeDetection');\n            this.socket.on('pixelsChanged', handlePixelsChanged);\n            this._waitForAnimationsPromises.add(promise);\n\n            return await promise.finally(() => {\n                clearTimeout(timeoutId);\n                this.socket.off('pixelsChanged', handlePixelsChanged);\n                this._waitForAnimationsPromises.delete(promise);\n\n                // only disable pixel change detection if there are no more active waitForAnimations\n                if (this._waitForAnimationsPromises.size === 0) {\n                    this.socket.send('disablePixelChangeDetection');\n                }\n            });\n        } catch (e) {\n            captureOperationalError(e, this.waitForAnimations);\n            throw e;\n        }\n    }\n\n    /* DEBUG METHODS */\n    /**\n     *\n     * @deprecated use `adbConnection` property instead\n     */\n    async getAdbInfo() {\n        this.logger.warn(\n            `getAdbInfo() is deprecated. Please use the \\`adbConnection\\` property instead.`\n        );\n        return Promise.resolve(this.#adbConnection);\n    }\n\n    /**\n     *\n     * @deprecated use `networkInspectorUrl` property instead\n     */\n    async getNetworkInspectorUrl() {\n        this.logger.warn(\n            `getNetworkInspectorUrl() is deprecated. Please use the \\`networkInspectorUrl\\` property instead.`\n        );\n        return Promise.resolve(this.#networkInspectorUrl);\n    }\n\n    /**\n     *\n     * @deprecated use `device` property instead\n     */\n    async getDeviceInfo() {\n        this.logger.warn(\n            `getDeviceInfo() is deprecated. Please use the \\`device\\` property instead.`\n        );\n        return Promise.resolve(this.device);\n    }\n\n    private get isStandalone() {\n        if (this.app?.buildId) {\n            return this.app.buildId.startsWith('standalone_');\n        }\n\n        return false;\n    }\n}\n\nexport interface SessionInfo {\n    path: string;\n    token: string;\n}\n\nfunction getAdbShellCommand(connectionInfo: AdbConnectionInfo) {\n    const template =\n        'ssh -fN -o StrictHostKeyChecking=no -oHostKeyAlgorithms=+ssh-rsa -p SERVER_PORT USERNAME@HOSTNAME -L6000:FORWARD_DESTINATION:FORWARD_PORT && adb connect localhost:6000';\n    if (!connectionInfo || !connectionInfo.forwards[0]) {\n        return undefined;\n    }\n    let returnValue = template;\n    returnValue = returnValue.replace(\n        /SERVER_PORT/,\n        connectionInfo.port.toString()\n    );\n    returnValue = returnValue.replace(/USERNAME/, connectionInfo.user);\n    returnValue = returnValue.replace(/HOSTNAME/, connectionInfo.hostname);\n    returnValue = returnValue.replace(\n        /FORWARD_DESTINATION/,\n        connectionInfo.forwards[0].destination\n    );\n    returnValue = returnValue.replace(\n        /FORWARD_PORT/,\n        connectionInfo.forwards[0].port.toString()\n    );\n    return returnValue;\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                    TYPES                                   */\n/* -------------------------------------------------------------------------- */\nexport interface SessionEvents {\n    log: { message: string };\n    network: NetworkRequest | NetworkResponse;\n    error: { message: string };\n    action: RecordedAction;\n\n    /**\n     * @deprecated use \"end\" event\n     */\n    disconnect: void;\n    end: void;\n\n    interaction: {\n        timeStamp: number;\n        type: string;\n        altKey?: boolean;\n        shiftKey?: boolean;\n        xPos?: number;\n        yPos?: number;\n    };\n    heartbeat: void;\n    orientationChanged: 'landscape' | 'portrait';\n    appLaunch: void;\n    firstFrameReceived: void;\n    inactivityWarning: { secondsRemaining: number };\n    ready: void;\n    video: {\n        buffer: Uint8Array;\n        width: number;\n        height: number;\n        codec: 'h264' | 'jpeg';\n    };\n    audio: {\n        buffer: Uint8Array;\n        codec: 'aac';\n        duration: number;\n    };\n\n    playbackFoundAndSent: PlayActionResult<Action>;\n    playbackError: PlayActionErrorResponse<Action>;\n}\n\nexport interface AdbConnectionInfo {\n    command: string;\n    forwards: Array<{ destination: string; port: number }>;\n    hash: string;\n    hostname: string;\n    port: number;\n    user: string;\n}\n\nexport interface SessionConfig {\n    device?: string;\n    osVersion?: string;\n    scale?: number | 'auto';\n    autoplay?: boolean;\n    adbShellCommand?: string;\n    androidPackageManager?: boolean;\n    appearance?: string;\n    audio?: boolean;\n    codec?: string;\n    debug?: boolean;\n    deviceColor?: string;\n    disableSessionStart?: boolean;\n    disableVirtualKeyboard?: boolean;\n    enableAdb?: boolean;\n    grantPermissions?: boolean;\n    hidePasswords?: boolean;\n    iosKeyboard?: string;\n    iosAutocorrect?: string;\n    language?: string;\n    launchUrl?: string;\n    launchArgs?: Array<string | number>;\n    locale?: string;\n    location?: number[];\n    loopback?: boolean;\n    noVideo?: boolean;\n    orientation?: string;\n    platform?: 'ios' | 'android';\n    payerCode?: string;\n    params?: Record<string, any>;\n    plistEdit?: Record<string, any>;\n    proxy?: string;\n    record?: boolean;\n    region?: string;\n    screenOnly?: boolean;\n    screenRecording?: boolean;\n    showRotateButtons?: boolean;\n    timezone?: string;\n    xdocMsg?: boolean;\n    endSessionRedirectUrl?: string;\n    userInteractionDisabled?: boolean;\n    volume?: number;\n    debugSession?: boolean;\n}\n\n// config that is specifiable by the user\nexport interface UserSessionConfig\n    extends Omit<SessionConfig, 'platform' | 'xdocMsg'> {\n    /**\n     * @deprecated use `buildId` instead\n     */\n    publicKey?: string;\n    buildId?: string;\n}\n\nexport interface NetworkRequest {\n    type: 'request';\n    serverIPAddress: string;\n    requestId: string;\n    request: {\n        method: string;\n        url: string;\n        httpVersion: string;\n        cookies: string[];\n        headers: Array<{ name: string; value: string }>;\n        queryString: string[];\n        headersSize: number;\n        bodySize: number;\n    };\n    cache: Record<string, any>;\n}\nexport interface NetworkResponse extends Omit<NetworkRequest, 'type'> {\n    type: 'response';\n    response: {\n        status: number;\n        statusText: string;\n        httpVersion: string;\n        cookies: string[];\n        headers: Array<{ name: string; value: string }>;\n        redirectURL: string;\n        headersSize: number;\n        bodySize: number;\n        content: {\n            size: number;\n            mimeType: string;\n            compression: number;\n            text: string;\n        };\n        postData?: {\n            mimeType: string;\n            text?: string;\n        };\n    };\n}\n\nexport type KeyValue = LiteralUnion<\n    'HOME' | 'VOLUME_UP' | 'VOLUME_DOWN' | 'ANDROID_KEYCODE_MENU',\n    string\n>;\n\ntype SimpleGesture = 'up' | 'down' | 'left' | 'right';\n\nexport type SwipeArgs = OmitUnion<SwipeAction, 'type' | 'moves'> & {\n    duration?: number;\n    gesture: SimpleGesture | ((gesture: SwipeGesture) => any);\n};\n","export default async function pause(page) {\n    /**\n     * Record your tests by interacting with your device! Once you are finished,\n     * press the \"Resume\" button at the top to continue.\n     */\n    await page.pause();\n}\n","import { KeypressAction } from './api/types/recorder';\n\nexport const controlKeys = [8, 9, 13, 16, 37, 38, 39, 40, null];\nexport const digitCharsWithShift = [\n    ')',\n    '!',\n    '@',\n    '#',\n    '$',\n    '%',\n    '^',\n    '&',\n    '*',\n    '(',\n];\nexport const charsWithShift = {\n    47: '?',\n    44: '<',\n    45: '_',\n    46: '>',\n    91: '{',\n    92: '|',\n    93: '}',\n    96: '~',\n    59: ':',\n    61: '+',\n    39: '\"',\n};\n\nexport const keysWithShift = {\n    191: '?',\n    188: '<',\n    189: '_',\n    190: '>',\n    219: '{',\n    220: '|',\n    221: '}',\n    192: '~',\n    186: ':',\n    187: '+',\n    222: '\"',\n};\n\nexport function convertCharToRawKey(key: string): {\n    key: string;\n    shiftKey: boolean;\n} {\n    let result;\n    for (const entry in charsWithShift) {\n        if (key === charsWithShift[entry]) {\n            result = {\n                // @ts-expect-error - copied from angular, entry should be a number but not sure if this works/is used\n                key: String.fromCharCode(entry),\n                shiftKey: 'true',\n            };\n            return result;\n        }\n    }\n    const indexInDigits = digitCharsWithShift.indexOf(key);\n    if (indexInDigits > -1) {\n        result = {\n            key: String.fromCharCode(indexInDigits + 48).toLowerCase(),\n            shiftKey: true,\n        };\n    } else if (key !== key.toLowerCase()) {\n        result = {\n            key: key.toLowerCase(),\n            shiftKey: true,\n        };\n    } else {\n        result = {\n            key: key,\n            shiftKey: false,\n        };\n    }\n    return result;\n}\n\nexport function getKeyFromKeypress(keypress: KeypressAction) {\n    if (keypress.character) {\n        return keypress.character;\n    }\n\n    // if no character, key must exist\n    const key = keypress.key!;\n\n    if (isSpecialKey(key)) {\n        return key;\n    }\n\n    return keypress.shiftKey ? key.toUpperCase() : key.toLowerCase();\n}\n\nexport function isSpecialKey(key: string) {\n    const pattern = /^[\\b\\t\\r]/;\n\n    return pattern.test(key);\n}\n\nexport function isSpecialChar(char: string) {\n    return char.length > 0;\n}\n/**\n * Converts legacy keycode to new keycode\n */\nexport function mapLegacyKeyCode(key: string) {\n    switch (key) {\n        case 'home':\n            return 'HOME';\n        case 'volumeUp':\n            return 'VOLUME_UP';\n        case 'volumeDown':\n            return 'VOLUME_DOWN';\n    }\n\n    return key;\n}\n\n/**\n * Converts new keycode to legacy keycode\n */\nexport function mapKeyCodeToLegacy(key: string) {\n    switch (key) {\n        case 'HOME':\n            return 'home';\n        case 'VOLUME_UP':\n            return 'volumeUp';\n        case 'VOLUME_DOWN':\n            return 'volumeDown';\n    }\n\n    return key;\n}\n","import { PlaywrightSession } from '../session';\nimport { TestInfo } from '@playwright/test';\nimport type {\n    RecordedAction,\n    TypeAction,\n} from '../../../core/api/types/recorder';\nimport fs from 'fs';\nimport { waitForTimeout } from '../../../core/waitFor';\nimport pause from './pause';\nimport { getKeyFromKeypress, isSpecialKey } from '../../../core/keys';\n\nexport class Codegen {\n    private session: PlaywrightSession;\n    private testInfo: TestInfo;\n    private currentRecord = 0;\n\n    constructor({\n        testInfo,\n        session,\n    }: {\n        testInfo: TestInfo;\n        session: PlaywrightSession;\n    }) {\n        this.session = session;\n        this.testInfo = testInfo;\n    }\n\n    async record() {\n        const file = this.testInfo.file;\n        const contents = await fs.promises.readFile(file, 'utf8');\n\n        // get session.record() statements for this test\n        const recordStatements = contents\n            .split('\\n')\n            // attach line numbers to each line\n            .map((line, num) => ({ line, num: num + 1 }))\n            // remove up to the current test() line #\n            .slice(this.testInfo.line)\n            // filter out lines that don't contain session.record()\n            .filter(({ line }) => line.includes('session.record()'));\n\n        const currentLine = recordStatements[this.currentRecord].num;\n\n        if (currentLine !== undefined) {\n            console.log(`🔴 Recording at line ${currentLine}`);\n\n            const actions: any[] = [];\n\n            const handleAction = (action: RecordedAction) => {\n                concatActions(actions, action);\n                console.log(describeAction(action));\n            };\n\n            this.session.on('action', handleAction);\n\n            // playwright shows the codecalling the pause, so we'll jump them\n            // to another file with some helpful comments\n            await pause(this.session.page);\n\n            // wait a few seconds to catch any other actions\n            await waitForTimeout(2000);\n\n            this.session.off('action', handleAction);\n\n            const newContents = contents.split('\\n').map((line, index) => {\n                if (index === currentLine - 1) {\n                    const tabs = line.match(/^\\s*/)?.[0] ?? 0;\n\n                    // generates a comment to summarize the recorded events\n                    const descriptions = actions\n                        .map((action) => {\n                            return describeAction(action);\n                        })\n                        .reduce(\n                            (acc, cur, i) => `${acc}\\n// ${i + 1}. ${cur}`,\n                            '// Recorded using session.record()'\n                        );\n\n                    return `${descriptions}\\nawait session.playActions(${JSON.stringify(\n                        actions,\n                        null,\n                        '\\t'\n                    )})`\n                        .split('\\n')\n                        .map((line) => tabs + line)\n                        .join('\\n');\n                }\n                return line;\n            });\n            await fs.promises.writeFile(file, newContents.join('\\n'));\n\n            console.log(`🟢 Finished`);\n            this.currentRecord += 1;\n        }\n    }\n}\n\n/**\n * Concatenates consecutive actions of the sam etype into single ones when applicable\n */\nfunction concatActions(\n    actions: Array<RecordedAction | TypeAction>,\n    action: RecordedAction\n) {\n    const lastAction = actions[actions.length - 1];\n\n    if (lastAction) {\n        switch (action.type) {\n            case 'keypress': {\n                // join consecutive keypress events into a single action\n                if (\n                    lastAction?.type === 'keypress' &&\n                    !isSpecialKey(action.key) &&\n                    !isSpecialKey(lastAction.key)\n                ) {\n                    actions.pop();\n\n                    actions.push({\n                        type: 'typeText',\n                        text:\n                            getKeyFromKeypress(lastAction) +\n                            getKeyFromKeypress(action),\n                    });\n                } else if (\n                    lastAction?.type === 'typeText' &&\n                    !isSpecialKey(action.key)\n                ) {\n                    actions.pop();\n\n                    actions.push({\n                        type: 'typeText',\n                        text: lastAction.text + getKeyFromKeypress(action),\n                    });\n                } else {\n                    actions.push(action);\n                }\n\n                break;\n            }\n            default:\n                actions.push(action);\n        }\n    } else {\n        actions.push(action);\n    }\n}\n\n/**\n * Describes the action in a human readable way\n */\nfunction describeAction(action: RecordedAction | TypeAction) {\n    let on = '';\n\n    switch (action.type) {\n        case 'swipe':\n        case 'tap': {\n            const element = action.element;\n\n            if (typeof element === 'string') {\n                on = ` on element \"${element}\"`;\n            } else {\n                if (element?.attributes?.accessibilityIdentifier) {\n                    on = `element with accessibilityIdentifier \"${element.attributes?.accessibilityIdentifier}\"`;\n                } else if (element?.attributes?.class) {\n                    on = `element with class \"${element.attributes?.class}\"`;\n                } else if (\n                    'position' in action &&\n                    action.position?.x &&\n                    action.position?.y\n                ) {\n                    on = `position ${Math.round(\n                        action.position.x * 100\n                    )}%, ${Math.round(action.position.y * 100)}%`;\n                }\n            }\n\n            if (on) {\n                return `${action.type} on ${on}`;\n            } else {\n                return action.type;\n            }\n        }\n        case 'keypress':\n            return `type \"${getKeyFromKeypress(action)}\"`;\n        case 'typeText':\n            return `type \"${action.text}\"`;\n    }\n}\n","import { version } from './package.json';\n\nexport const VERSION = version;\n","import { Page } from '@playwright/test';\nimport { SocketProtocol } from '../../core/api/types/socket';\nimport { waitFor, waitForEvent, WaitForEventOptions } from '../../core/waitFor';\nimport { VERSION } from '../../core/constants';\nimport { AppetizeWindowProtocol } from '../../core/window';\nimport { TimeoutError } from '../../core/errors';\nimport { EventEmitter } from '../../core/EventEmitter';\nimport { logger } from './logger';\nimport { AppetizeTestFixture } from './fixture';\n\n/**\n * Communicates with Appetize /embed page\n */\nexport class AppetizeWindow\n    extends EventEmitter\n    implements AppetizeWindowProtocol\n{\n    page: Page;\n    ready = false;\n    testFixture: AppetizeTestFixture;\n\n    constructor({\n        page,\n        testFixture,\n    }: {\n        page: Page;\n        testFixture: AppetizeTestFixture;\n    }) {\n        super();\n        this.page = page;\n        this.testFixture = testFixture;\n    }\n\n    async init() {\n        this.ready = false;\n\n        await this.testFixture.step('Connect to Appetize page', async () => {\n            // attach __appetize_on function\n            await this.page.exposeFunction('__appetize_on', (json) => {\n                const data = JSON.parse(json, function (key, value) {\n                    // look for typed array flags\n                    try {\n                        if ('flag' in value && value.flag === 'TYPED_ARRAY') {\n                            return global[value.constructor].from(\n                                value.data.split(',').map(Number)\n                            );\n                        }\n                    } catch (e) {\n                        // no-op\n                    }\n\n                    return value;\n                });\n\n                const type = data === 'string' ? data : data.type;\n                const value = data.value;\n\n                this.emit(type, value);\n                this.emit('*', { type, value });\n            });\n\n            await this.page.evaluate(\n                async ([VERSION]) => {\n                    return new Promise<boolean>((resolve, reject) => {\n                        const timeout = setTimeout(() => {\n                            clearInterval(interval);\n                            reject(\n                                new TimeoutError(\n                                    `Timed out after 60000ms waiting for connection to Appetize page`\n                                )\n                            );\n                        }, 60000);\n\n                        const interval = setInterval(() => {\n                            const channel = new MessageChannel();\n\n                            channel.port1.onmessage = () => {\n                                clearInterval(interval);\n                                clearTimeout(timeout);\n                                channel.port1.close();\n                                channel.port2.close();\n                                resolve(false);\n                            };\n                            window.postMessage(\n                                {\n                                    type: 'init',\n                                    appetizeClient: true,\n                                    version: VERSION,\n                                },\n                                '*',\n                                [channel.port2]\n                            );\n                            window.__appetize_postMessage = async (\n                                data,\n                                waitForResponse = false\n                            ) => {\n                                const channel = new MessageChannel();\n\n                                window.postMessage(data, '*', [channel.port2]);\n\n                                if (waitForResponse) {\n                                    return new Promise((resolve, reject) => {\n                                        const tm = setTimeout(() => {\n                                            reject(\n                                                new TimeoutError(\n                                                    'Timed out after 60000ms while waiting for postMessage response'\n                                                )\n                                            );\n                                        }, 60000);\n\n                                        channel.port1.onmessage = (ev) => {\n                                            clearTimeout(tm);\n                                            channel.port1.close();\n                                            channel.port2.close();\n                                            resolve(ev.data as any);\n                                        };\n                                    });\n                                } else {\n                                    channel.port1.close();\n                                    channel.port2.close();\n                                }\n                            };\n                        }, 100);\n                    });\n                },\n                [VERSION]\n            );\n\n            // call exposed function on client/session events\n            await this.page.evaluate(() => {\n                window.addEventListener('message', (event) => {\n                    if (event.source === window) {\n                        const eventType =\n                            typeof event.data === 'string'\n                                ? event.data\n                                : event.data?.type;\n\n                        switch (eventType) {\n                            // we'll get these from socket xdoc events directly.\n                            // save some bandwidth by not sending them twice\n                            case 'frameData':\n                            case 'recordedAction':\n                            case 'playbackFoundAndSent':\n                            case 'playbackNotFound':\n                            case 'debug':\n                            case 'interceptRequest':\n                            case 'interceptResponse':\n                            case 'interceptError':\n                            case 'uiDump':\n                                return;\n                        }\n\n                        window.__appetize_on(\n                            JSON.stringify(event.data, function (key, value) {\n                                // typed arrays will be serialized to normal arrays, so\n                                // we flag them as typed arrays for the parser to correctly convert them back\n                                // modified from https://gist.github.com/jonathanlurie/04fa6343e64f750d03072ac92584b5df\n                                if (\n                                    value instanceof Int8Array ||\n                                    value instanceof Uint8Array ||\n                                    value instanceof Uint8ClampedArray ||\n                                    value instanceof Int16Array ||\n                                    value instanceof Uint16Array ||\n                                    value instanceof Int32Array ||\n                                    value instanceof Uint32Array ||\n                                    value instanceof Float32Array ||\n                                    value instanceof Float64Array\n                                ) {\n                                    const replacement = {\n                                        constructor: value.constructor.name,\n                                        data: value.join(','),\n                                        flag: 'TYPED_ARRAY',\n                                    };\n                                    return replacement;\n                                }\n                                return value;\n                            })\n                        );\n                    }\n                });\n            }, []);\n        });\n\n        this.ready = true;\n    }\n\n    /**\n     * Waits for page to be loaded and ready for xdoc messages\n     */\n    async waitUntilReady() {\n        return waitFor(async () => {\n            if (!this.ready) {\n                throw new TimeoutError(\n                    `Timed out after 60000ms while waiting for Appetize window to be ready.`\n                );\n            }\n        }, 60000);\n    }\n\n    /**\n     * Sends a raw postMessage to the window\n     */\n    async postMessage<T>(data: any, waitForResponse = false) {\n        await this.waitUntilReady();\n        try {\n            return await this.testFixture.step('postMessage', async () =>\n                this.page.evaluate(\n                    async ([data, waitForResponse]) => {\n                        return window.__appetize_postMessage(\n                            data,\n                            waitForResponse\n                        ) as T;\n                    },\n                    [data, waitForResponse]\n                )\n            );\n        } catch (e) {\n            logger.error('Error sending postMessage: ', data);\n            throw e;\n        }\n    }\n}\n\nexport class PlaywrightSocket extends EventEmitter implements SocketProtocol {\n    page: Page;\n    type: 'webserver' | 'appetizer';\n    window: AppetizeWindow;\n\n    constructor({\n        page,\n        type,\n        window,\n    }: {\n        page: Page;\n        type: 'webserver' | 'appetizer';\n        window: AppetizeWindow;\n    }) {\n        super();\n        this.page = page;\n        this.type = type;\n        this.window = window;\n\n        this.window.on('*', ({ type, value }) => {\n            switch (type) {\n                case 'socketEvent':\n                    if (value.socket === this.type) {\n                        const socketEventType = value.type;\n                        const socketEventValue = value.value;\n\n                        this.emit(socketEventType, socketEventValue);\n                        this.emit('*', {\n                            type: socketEventType,\n                            value: socketEventValue,\n                        });\n                    }\n                    break;\n                case 'disconnect':\n                    this.emit('disconnect');\n                    this.emit('*', { type: 'disconnect' });\n                    break;\n\n                // map xdocs to appetizer events\n                case 'sessionInfo':\n                case 'chromeDevToolsUrl':\n                case 'orientationChanged':\n                case 'deviceInfo':\n                    if (this.type === 'appetizer') {\n                        this.emit(type, value);\n                        this.emit('*', { type, value });\n                    }\n                    break;\n\n                // map xdocs to client events\n                case 'sessionRequested':\n                    if (this.type === 'webserver') {\n                        this.emit(type, value);\n                        this.emit('*', { type, value });\n                    }\n                    break;\n            }\n        });\n    }\n\n    async send(event: string, data?: any) {\n        return this.window.postMessage<void>({\n            type: 'emitSocketEvent',\n            value: { type: event, value: data, socket: this.type },\n        });\n    }\n\n    async disconnect() {\n        await this.send('disconnect');\n    }\n\n    waitForEvent<T>(\n        event: string,\n        options: WaitForEventOptions<T>\n    ): Promise<T> {\n        return waitForEvent(this, event, options);\n    }\n}\n\ndeclare const window: Window & {\n    __appetize_postMessage: (\n        data: any,\n        waitForResponse?: boolean\n    ) => Promise<void>;\n    __appetize_on: (data: any) => void;\n};\n","import { Page } from '@playwright/test';\nimport type {\n    Action,\n    ElementSelector,\n    PlayActionErrorResponse,\n    PlayActionOptions,\n    PlayActionResult,\n    RecordedAction,\n} from '../../core/api/types/recorder';\nimport { FindElementsAction } from '../../core/api/types/recorder/internal';\nimport { OperationalError, captureOperationalError } from '../../core/errors';\nimport {\n    Session,\n    SessionArgs,\n    SessionConfig,\n    SessionEvents,\n} from '../../core/session';\nimport {\n    WaitForEventOptionsOrPredicate,\n    waitForEvent,\n    waitForTimeout,\n} from '../../core/waitFor';\nimport { Codegen } from './codegen';\nimport { logger } from './logger';\nimport { AppetizeWindow, PlaywrightSocket } from './socket';\nimport { AllUI } from '../../core/api/types/recorder/public';\nimport { AppetizeTestFixture } from './fixture';\n\ninterface ActionLog {\n    action: Action | RecordedAction;\n    result?: PlayActionResult;\n    payload?: any;\n    error?: PlayActionErrorResponse;\n    ui?: AllUI;\n}\n\nexport interface PlaywrightSessionEvents extends SessionEvents {}\n\nexport interface PlaywrightSessionConfig extends SessionConfig {\n    buildId?: string;\n\n    /**\n     * @deprecated use buildId instead\n     */\n    publicKey?: string;\n}\nexport class PlaywrightSession extends Session {\n    page: Page;\n    window: AppetizeWindow;\n    testFixture: AppetizeTestFixture;\n\n    config: SessionConfig;\n    protected actionLogs: Array<ActionLog> = [];\n\n    constructor({\n        page,\n        config,\n        window,\n        testFixture,\n        ...args\n    }: Omit<SessionArgs, 'socket' | 'logger'> & {\n        page: Page;\n        config: SessionConfig;\n        window: AppetizeWindow;\n        testFixture: AppetizeTestFixture;\n    }) {\n        const socket = new PlaywrightSocket({\n            page,\n            window,\n            type: 'appetizer',\n        });\n        super({ ...args, socket, config, logger });\n        this.window = window;\n        this.page = page;\n        this.config = config;\n        this.testFixture = testFixture;\n\n        // disconnect session on page navigation\n        // is there a better event to listen for? 'framenavigated' event fires too soon\n        this.page.on('load', () => {\n            this.emit('disconnect');\n        });\n\n        // Wrap our methods as steps to be shown in playwright trace\n        // with proper titles\n        this.adbShellCommand = this.wrapAsStep(this.adbShellCommand);\n        this.biometry = this.wrapAsStep(this.biometry);\n        this.findElement = this.wrapAsStep(this.findElement, {\n            subStepTitle: (selector) => JSON.stringify(selector),\n        });\n        this.findElements = this.wrapAsStep(this.findElements, {\n            subStepTitle: (selector) => JSON.stringify(selector),\n        });\n        this.getUI = this.wrapAsStep(this.getUI);\n        this.keypress = this.wrapAsStep(this.keypress, {\n            subStepTitle: (key) => JSON.stringify(key),\n        });\n        this.launchApp = this.wrapAsStep(this.launchApp, {\n            subStepTitle: (app) => JSON.stringify(app),\n        });\n        this.openUrl = this.wrapAsStep(this.openUrl, {\n            subStepTitle: (url) => JSON.stringify(url),\n        });\n        this.playAction = this.wrapAsStep(this.playAction, {\n            subStepTitle: (action) => JSON.stringify(action),\n        });\n        this.playActions = this.wrapAsStep(this.playActions, {\n            subStepTitle: (actions) => JSON.stringify(actions),\n        });\n        this.reinstallApp = this.wrapAsStep(this.reinstallApp);\n        this.restartApp = this.wrapAsStep(this.restartApp);\n        this.rotate = this.wrapAsStep(this.rotate, {\n            subStepTitle: (direction) => JSON.stringify(direction),\n        });\n        this.screenshot = this.wrapAsStep(this.screenshot);\n        this.setLanguage = this.wrapAsStep(this.setLanguage, {\n            subStepTitle: (language) => JSON.stringify(language),\n        });\n        this.setLocation = this.wrapAsStep(this.setLocation, {\n            subStepTitle: (location) => JSON.stringify(location),\n        });\n        this.shake = this.wrapAsStep(this.shake);\n        this.swipe = this.wrapAsStep(this.swipe, {\n            subStepTitle: (args) => JSON.stringify(args),\n        });\n        this.tap = this.wrapAsStep(this.tap, {\n            subStepTitle: (args) => JSON.stringify(args),\n        });\n        this.type = this.wrapAsStep(this.type, {\n            subStepTitle: (text) => JSON.stringify(text),\n        });\n        this.waitForAnimations = this.wrapAsStep(this.waitForAnimations);\n        this.waitForElement = this.wrapAsStep(this.waitForElement, {\n            subStepTitle: (selector) => JSON.stringify(selector),\n        });\n        this.waitForEvent = this.wrapAsStep(this.waitForEvent, {\n            title: (event) => `session.waitForEvent - ${JSON.stringify(event)}`,\n        });\n        this.waitForTimeout = this.wrapAsStep(this.waitForTimeout, {\n            title: (ms) => `session.waitForTimeout - ${JSON.stringify(ms)}`,\n        });\n    }\n\n    protected async addActionLog(log: ActionLog): Promise<void> {\n        if (log.error) {\n            const ui = await this.getUI().catch(this.logger.warn);\n\n            if (ui) {\n                log.ui = ui;\n            }\n        }\n\n        this.actionLogs.push(log);\n    }\n\n    async rotate(direction: 'left' | 'right') {\n        try {\n            const [orientation] = await Promise.all([\n                waitForEvent<'landscape' | 'portrait'>(\n                    this.window,\n                    'orientationChanged'\n                ),\n                // we need to use postmessage api so that embed knows which direction we rotated.\n                // otherwise, if we emit directly over the socket, frontend only knows that orientation changed\n                // from/to portrait/landscape, not the actual rotation in degrees\n                await this.window.postMessage(\n                    direction === 'left' ? 'rotateLeft' : 'rotateRight'\n                ),\n            ]);\n\n            this.window.page.waitForTimeout(1000);\n\n            return orientation;\n        } catch (e) {\n            captureOperationalError(e, this.rotate);\n            throw e;\n        }\n    }\n\n    async record() {\n        try {\n            if (!this.config.record) {\n                throw new OperationalError(\n                    'Recording is not enabled, please enable it by setting `record: true` in session config'\n                );\n            }\n\n            if (!this.testFixture) {\n                throw new OperationalError(\n                    'session.record() requires using `session` from the test() arguments'\n                );\n            }\n\n            const codegen = new Codegen({\n                session: this,\n                testInfo: this.testFixture.info(),\n            });\n\n            return codegen.record();\n        } catch (e) {\n            captureOperationalError(e, this.record);\n            throw e;\n        }\n    }\n\n    async waitForEvent<K extends keyof SessionEvents>(\n        event: K,\n        options?: WaitForEventOptionsOrPredicate<SessionEvents[K]>\n    ): Promise<SessionEvents[K]> {\n        try {\n            return await waitForEvent(this, event, options);\n        } catch (e) {\n            captureOperationalError(e, this.waitForEvent);\n            throw e;\n        }\n    }\n\n    async waitForTimeout(ms: number) {\n        try {\n            return await waitForTimeout(ms);\n        } catch (e) {\n            captureOperationalError(e, this.waitForTimeout);\n            throw e;\n        }\n    }\n\n    /**\n     * Waits for the element(s) to appear or else throws an error.\n     */\n    async waitForElement(\n        element: ElementSelector,\n        options?: PlayActionOptions<FindElementsAction> & {\n            /**\n             * The number of elements for this selector that should be returned\n             */\n            matches?: number;\n        }\n    ) {\n        try {\n            const elements = await this.findElements(element, options);\n\n            if (elements.length) {\n                if (options?.matches && elements.length !== options.matches) {\n                    throw new Error(\n                        `Expected ${options.matches} elements, found ${elements.length}`\n                    );\n                }\n\n                return elements;\n            } else {\n                throw new Error(\n                    `Element not found:\\n${JSON.stringify(element)}`\n                );\n            }\n        } catch (e) {\n            captureOperationalError(e, this.waitForElement);\n            throw e;\n        }\n    }\n\n    on<K extends keyof SessionEvents>(\n        event: K,\n        listener: (value: SessionEvents[K]) => void\n    ): this {\n        return super.on(event, listener);\n    }\n\n    once<K extends keyof SessionEvents>(\n        event: K,\n        listener: (value: SessionEvents[K]) => void\n    ): this {\n        return super.once(event, listener);\n    }\n\n    async getVideoFrames(): Promise<never[]> {\n        console.warn(\n            `getVideoFrames() is deprecated. Use session.on('video') event instead`\n        );\n        return [];\n    }\n\n    async getAudioFrames(): Promise<never[]> {\n        console.warn(\n            `getAudioFrames() is deprecated. Use session.on('audio') event instead`\n        );\n        return [];\n    }\n\n    // returns a bound version of the function that will run as a step\n    private wrapAsStep<T extends (...args: any[]) => any>(\n        fn: T,\n        options: {\n            title?: (...args: Parameters<T>) => string;\n\n            /**\n             * Playwright doesn't offer a great way to add additional detail like params,\n             * so we can add a substep title to provide more context when expanded and keep things clean.\n             */\n            subStepTitle?: (...args: Parameters<T>) => string;\n        } = {}\n    ) {\n        return (...args: Parameters<T>) => {\n            let title = `session.${fn.name}`;\n\n            if (options?.title) {\n                title = options.title(...args);\n            }\n\n            const subStepTitle = options?.subStepTitle?.(...args);\n\n            if (subStepTitle) {\n                return this.testFixture.step(\n                    title,\n                    () =>\n                        this.testFixture.step(subStepTitle, () =>\n                            fn.apply(this, args)\n                        ),\n                    { box: true }\n                );\n            } else {\n                return this.testFixture.step(\n                    title,\n                    () => fn.apply(this, args),\n                    { box: true }\n                );\n            }\n        };\n    }\n}\n","import { Page } from '@playwright/test';\nimport {\n    HeadfulClient,\n    HeadfulClientEvents,\n} from '../../core/client/headful-client';\nimport {\n    SessionConfig,\n    SessionInfo,\n    UserSessionConfig,\n} from '../../core/session';\nimport { logger } from './logger';\nimport { PlaywrightSession } from './session';\nimport { AppetizeWindow, PlaywrightSocket } from './socket';\nimport { AppetizeTestFixture } from './fixture';\n\n/**\n * AppetizeWindow can only be instantiated once per page,\n * so if a client is reinitialized a second time,\n * we need to reuse the window instance\n **/\nconst windows = new WeakMap<Page, AppetizeWindow>();\n\nexport class PlaywrightClient extends HeadfulClient<\n    PlaywrightSocket,\n    PlaywrightClientEvents,\n    PlaywrightSession\n> {\n    page: Page;\n    window!: AppetizeWindow;\n    testFixture: AppetizeTestFixture;\n\n    constructor({\n        page,\n        testFixture,\n    }: {\n        page: Page;\n        testFixture: AppetizeTestFixture;\n    }) {\n        const window =\n            windows.get(page) ?? new AppetizeWindow({ page, testFixture });\n        windows.set(page, window);\n\n        const socket = new PlaywrightSocket({\n            type: 'webserver',\n            page,\n            window,\n        });\n        super({ socket, window, logger, autoInit: false });\n        this.window = window;\n        this.page = page;\n        this.testFixture = testFixture;\n\n        let isInQueue = false;\n\n        this.on('queue', (queue) => {\n            if (!isInQueue) {\n                isInQueue = true;\n                if (queue.type === 'concurrent') {\n                    this.logger.log(\n                        `Entered ${queue.name}. Please wait until a slot becomes available.`\n                    );\n                } else {\n                    this.logger.log(\n                        `All devices are currently in use. Please wait until requested device becomes available.`\n                    );\n                }\n            }\n\n            if (queue.position > 0) {\n                if (queue.type === 'concurrent') {\n                    this.logger.log(\n                        `Position in ${queue.name}: ${queue.position}`\n                    );\n                } else {\n                    this.logger.log(`Position in queue: ${queue.position}`);\n                }\n            }\n        });\n\n        this.on('session', () => {\n            if (isInQueue) {\n                isInQueue = false;\n            }\n        });\n    }\n\n    async init() {\n        return this.testFixture.step('Initialize client', async () => {\n            await this.window.init();\n            await super.init();\n        });\n    }\n    protected validateConfig(config: UserSessionConfig) {\n        const browserType = this.page.context().browser()?.browserType().name();\n        return {\n            codec: browserType === 'chromium' ? 'jpeg' : 'h264',\n            ...config,\n        };\n    }\n\n    protected createSession(config: SessionConfig, sessionInfo: SessionInfo) {\n        this.session = new PlaywrightSession({\n            config,\n            page: this.page,\n            window: this.window,\n            path: sessionInfo.path,\n            token: sessionInfo.token,\n            device: this.device,\n            app: this.app,\n            testFixture: this.testFixture,\n        });\n\n        return this.session;\n    }\n}\n\nexport interface PlaywrightClientEvents\n    extends HeadfulClientEvents<PlaywrightSession> {}\n","import { Page } from '@playwright/test';\nimport { SessionConfig } from '../../core/session';\nimport { retry } from '../../core/util';\nimport { PlaywrightClient } from './client';\nimport { PlaywrightSession, PlaywrightSessionConfig } from './session';\nimport { queryString } from '../../core/util';\nimport { HeadfulDeviceInfo } from '../../core/client/headful-client';\nimport {\n    PlayActionResult,\n    PlayActionErrorResponse,\n} from '../../core/api/types/recorder';\nimport { AppetizeTestFixture } from './fixture';\n\nexport class AppetizePage {\n    readonly page: Page;\n    readonly testFixture: AppetizeTestFixture;\n\n    session?: PlaywrightSession;\n    client!: PlaywrightClient;\n    queueStart: number | null = null;\n    queueEnd: number | null = null;\n    config: PlaywrightSessionConfig;\n    baseURL = 'https://appetize.io';\n\n    sessionDebugInfo = {\n        playedActions: [] as ActionLog[],\n        videoFrames: [] as Array<{\n            buffer: Uint8Array;\n            codec: 'h264' | 'jpeg';\n        }>,\n        audioFrames: [] as Array<{ buffer: Uint8Array; codec: 'aac' }>,\n        debugLogs: [] as string[],\n    };\n\n    constructor(args: {\n        page: Page;\n        testFixture: AppetizeTestFixture;\n        config: PlaywrightSessionConfig;\n        baseURL?: string;\n    }) {\n        this.page = args.page;\n        this.testFixture = args.testFixture;\n        this.config = {\n            ...args.config,\n            buildId: args.config.buildId ?? args.config.publicKey,\n            // only define publicKey if it's set\n            ...(args.config.publicKey\n                ? { publicKey: args.config.publicKey }\n                : {}),\n        };\n\n        if (args.baseURL) {\n            this.baseURL = args.baseURL;\n        }\n    }\n\n    get queueTime() {\n        if (this.queueStart) {\n            return (this.queueEnd ?? Date.now()) - this.queueStart;\n        }\n\n        return null;\n    }\n\n    async init() {\n        const params = {};\n\n        for (const key in this.config) {\n            switch (key) {\n                case 'device':\n                case 'osVersion':\n                case 'scale':\n                case 'orientation':\n                    params[key] = this.config[key];\n                    break;\n            }\n        }\n\n        const pageRes = await this.page.goto(\n            `${this.baseURL}/embed/${this.config.buildId}?${queryString(\n                params\n            )}`\n        );\n\n        if (pageRes?.status() === 404) {\n            const label = this.config.publicKey ? 'publicKey' : 'buildId';\n            throw new Error(\n                `App not found for ${label} \"${\n                    this.config.publicKey ?? this.config.buildId\n                }\"`\n            );\n        }\n\n        this.client = new PlaywrightClient({\n            page: this.page,\n            testFixture: this.testFixture,\n        });\n\n        await this.client.init();\n    }\n\n    async start(args: { config: SessionConfig }) {\n        this.queueStart = null;\n        this.queueEnd = null;\n\n        this.client.on('queue', () => {\n            if (!this.queueStart) {\n                this.queueStart = Date.now();\n            }\n        });\n\n        this.client.on('queueEnd', () => {\n            if (this.queueStart) {\n                this.queueEnd = Date.now();\n            }\n        });\n\n        const resizeToDevice = async (info?: HeadfulDeviceInfo) => {\n            if (info?.embed) {\n                await this.page.setViewportSize({\n                    // add some padding to prevent scrollbars from showing on chromium\n                    width: info.embed.width + 8,\n                    height: info.embed.height + 8,\n                });\n            }\n        };\n        this.client.on('deviceInfo', resizeToDevice);\n\n        await this.client.waitUntilReady();\n\n        // set initial size\n        if (this.client.device) {\n            resizeToDevice(this.client.device);\n        }\n\n        const session = await retry(\n            () => this.client.startSession(args.config),\n            {\n                retries: 5,\n                timeout: 30000,\n                predicate: (e, attempt) => {\n                    if (\n                        e instanceof Error &&\n                        e.message.match(/too many requests/)\n                    ) {\n                        console.warn(\n                            `Too many session requests. Retrying in 30 seconds... (attempt #${attempt})`\n                        );\n                        return true;\n                    }\n\n                    return false;\n                },\n            }\n        );\n\n        this.config = session.config;\n\n        // startSession resolves slightly after stream has started, so request a keyframe\n        this.requestKeyFrame();\n\n        if (session.config.debug === true) {\n            session.on('log', (value) => {\n                this.sessionDebugInfo.debugLogs.push(value.message);\n            });\n        }\n\n        session.on('playbackFoundAndSent', (value) => {\n            this.sessionDebugInfo.playedActions.push(value);\n        });\n\n        session.on('playbackError', (value) => {\n            this.sessionDebugInfo.playedActions.push(value);\n        });\n\n        session.on('video', (frame) => {\n            this.sessionDebugInfo.videoFrames.push(frame);\n        });\n\n        session.on('audio', (frame) => {\n            this.sessionDebugInfo.audioFrames.push(frame);\n        });\n\n        session.on('end', () => {\n            this.session = undefined;\n        });\n\n        this.session = session;\n\n        return session;\n    }\n\n    onTestStart() {\n        this.clearSessionDebugInfo();\n        this.requestKeyFrame();\n    }\n\n    private clearSessionDebugInfo() {\n        this.sessionDebugInfo.playedActions = [];\n        this.sessionDebugInfo.videoFrames = [];\n        this.sessionDebugInfo.audioFrames = [];\n        this.sessionDebugInfo.debugLogs = [];\n    }\n\n    private requestKeyFrame() {\n        if (this.session) {\n            this.testFixture.step(/* hidden step */ '', async () => {\n                return (\n                    this.session?.socket\n                        .send('requestKeyFrame')\n                        // don't log error if this fails\n                        .catch(() => {})\n                );\n            });\n        }\n    }\n}\n\ntype ActionLog = PlayActionErrorResponse | PlayActionResult;\n","import { exec } from 'child_process';\nimport { _android as android } from 'playwright-core';\nimport { promisify } from 'util';\nimport { PlaywrightSession } from './session';\nimport { AndroidDevice, TestInfo } from '@playwright/test';\nimport fs from 'fs';\nimport { logger } from './logger';\n\nconst execAsync = promisify(exec);\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\n\n/**\n * Create a Chrome browser page on an Appetize Android device.\n * Pre-requisites:\n * - Session must be configured with `enableAdb: true`.\n * - Must have the [adb daemon](https://developer.android.com/studio/command-line/adb) installed & running.\n * - No other connected devices.\n *\n * @param session The Appetize Playwright session\n * @param testInfo The test info object\n * @returns the running Chrome Browser page, BrowserContext, and Android device.\n */\nexport async function createAndroidDeviceBrowserPage(\n    session: PlaywrightSession,\n    testInfo: TestInfo\n) {\n    const adbInfo = session.adbConnection;\n    const host = 'localhost';\n    const port = 6000;\n\n    if (!adbInfo) {\n        throw new Error(\n            'ADB connection info not found. Session must be configured with `enableAdb: true`'\n        );\n    }\n\n    await checkAdbInstalled();\n\n    // Disconnect any existing ADB connections\n    try {\n        await execAsync(`adb disconnect ${host}:${port}`);\n    } catch (e) {\n        // no-op\n    }\n\n    const sshCmd = `ssh -fN -o StrictHostKeyChecking=no -oHostKeyAlgorithms=+ssh-rsa -p ${adbInfo.port} ${adbInfo.user}@${adbInfo.hostname} -L${port}:${adbInfo.forwards[0].destination}:${adbInfo.forwards[0].port}`;\n    const sshOutput = await execAsync(sshCmd);\n\n    if (sshOutput.stdout) {\n        logger.error(sshOutput.stdout);\n    }\n\n    if (sshOutput.stderr) {\n        logger.error(sshOutput.stderr);\n    }\n\n    const adbCmd = `adb connect ${host}:${port}`;\n    const adbOutput = await execAsync(adbCmd);\n\n    if (adbOutput.stdout) {\n        logger.error(adbOutput.stdout);\n    }\n\n    if (adbOutput.stderr) {\n        logger.error(adbOutput.stderr);\n    }\n\n    // Connect to the Android device\n    const device = await android\n        .devices()\n        .then((devices) =>\n            devices.find((device) => device.serial() === `${host}:${port}`)\n        );\n\n    if (!device) {\n        throw new Error(`Device ${host}:${port} not found`);\n    }\n\n    logger.debug(\n        `Connected to device ${device.model()} with serial ${device.serial()}`\n    );\n\n    // launchBrowser overwrites the command line file, so we need to read\n    // what is there before launching the browser and pass it into the args option\n    const flags = await getExistingChromeCommandLineFlags(testInfo);\n\n    const browserContext = await device.launchBrowser({\n        args: flags,\n    });\n\n    // launchBrowser removes the cmd line file afterwards, so we want to restore our original incase\n    // the browser is restarted\n    await pushChromeCommandLine(testInfo, `chrome ${flags.join(' ')}`);\n\n    const pages = browserContext.pages();\n\n    // use existing page if available. it seems there is no difference in either using\n    // this page or calling newPage(), but sometimes newPage() throws an error which\n    // (might just be a playwright bug w/ android)\n    if (pages[0]) {\n        return {\n            page: pages[0],\n            browserContext,\n            device,\n        };\n    }\n\n    const page = await browserContext.newPage();\n    return { page, browserContext, device };\n}\n\n/**\n * Disconnects and closes the running Android device.\n * @param device Device to disconnect\n */\nexport async function disconnectAndroidDevice(device: AndroidDevice) {\n    await device.close();\n    await execAsync(`adb disconnect ${device.serial()}`);\n}\n\nasync function getExistingChromeCommandLineFlags(\n    testInfo: TestInfo\n): Promise<string[]> {\n    const testOutputDir = testInfo.outputPath();\n    const pulledPath = testInfo.outputPath('chrome-command-line');\n\n    const chromeCommandLinePath = '/data/local/tmp/chrome-command-line';\n\n    let flags: string[] = [];\n\n    // get the file if it exists\n    try {\n        await execAsync(`adb pull ${chromeCommandLinePath} ${testOutputDir}`);\n        const file = await readFileAsync(pulledPath, 'utf-8');\n\n        if (file) {\n            const flagsString = file.split('chrome ').at(1);\n\n            if (flagsString) {\n                flags = flagsString.split(' ') || [];\n            }\n        }\n\n        // the permissions for this file on our emulator will prevent playwright from writing to it,\n        // but we can work around it by pushing it and that will correct the permissions\n        await execAsync(`adb push ${pulledPath} ${chromeCommandLinePath}`);\n    } catch (e) {\n        // no-op\n    }\n\n    return flags;\n}\n\nasync function pushChromeCommandLine(testInfo: TestInfo, content: string) {\n    const pulledPath = testInfo.outputPath('chrome-command-line');\n\n    const chromeCommandLinePath = '/data/local/tmp/chrome-command-line';\n\n    try {\n        await writeFileAsync(pulledPath, content);\n        await execAsync(`adb push ${pulledPath} ${chromeCommandLinePath}`);\n    } catch (e) {\n        logger.error('Error pushing chrome-command-line file', e);\n    }\n}\n\nasync function checkAdbInstalled() {\n    try {\n        await execAsync('adb version');\n    } catch (e) {\n        throw new Error(\n            'ADB is not installed or not found in PATH. Please install ADB and ensure it is accessible.'\n        );\n    }\n}\n","import {\n    BrowserContext,\n    PlaywrightTestArgs,\n    PlaywrightTestOptions,\n    PlaywrightWorkerArgs,\n    PlaywrightWorkerOptions,\n    test as base,\n    TestInfo,\n    TestType,\n} from '@playwright/test';\nimport { PlaywrightClient } from './client';\nimport './expect';\nimport { PlaywrightSession, PlaywrightSessionConfig } from './session';\nimport { AppetizePage } from './appetize-page';\nimport { logger } from './logger';\nimport fs from 'fs';\nimport JMuxer from 'jmuxer';\nimport { Readable } from 'stream';\nimport os from 'os';\nimport path from 'path';\nimport {\n    createAndroidDeviceBrowserPage,\n    disconnectAndroidDevice,\n} from './device-browser-page';\n\nexport interface AppetizeTestOptions extends PlaywrightTestOptions {\n    /**\n     * The session config to use for the tests\n     */\n    config: Partial<PlaywrightSessionConfig>;\n}\n\ninterface TestArgs extends PlaywrightTestArgs, AppetizeTestOptions {\n    appetizePage: AppetizePage;\n    session: PlaywrightSession;\n    client: PlaywrightClient;\n}\n\ninterface WorkerArgs extends PlaywrightWorkerArgs, PlaywrightWorkerOptions {\n    _browserContext: BrowserContext;\n}\n\nlet appetizePage: AppetizePage | null = null;\nlet lastConfig: Partial<PlaywrightSessionConfig> | null = null;\n\nconst _test = base.extend<\n    TestArgs & {\n        _autoSnapshotSuffix: void;\n        _doSetupAndTeardown: void;\n        _useConfig: Partial<PlaywrightSessionConfig>;\n    },\n    WorkerArgs\n>({\n    // shallow merges _useConfig with project.use.config\n    config: [\n        async ({ _useConfig }, use, testInfo) => {\n            const config = {\n                ...(testInfo.project.use as AppetizeTestOptions).config,\n                ..._useConfig,\n                autoplay: false,\n            };\n\n            // handle configs with publicKey\n            if ('publicKey' in config && !!config.publicKey) {\n                if ('buildId' in config && !!config.buildId) {\n                    logger.warn(\n                        `Both \"buildId\" (\"${config.buildId}\") and \"publicKey\" (\"${config.publicKey}\") were defined in the test config. Using buildId.`\n                    );\n                    config.publicKey = config.buildId;\n                } else {\n                    config.buildId = config.publicKey;\n                }\n            }\n\n            await use(config);\n        },\n        { auto: true },\n    ],\n\n    async page({ context, config, baseURL }, use, testInfo) {\n        if (isAppetize(testInfo)) {\n            appetizePage ??= await setupAppetizePage(context, config, baseURL);\n            const session = await setupSession(appetizePage, config);\n            if (session.config.platform !== 'android') {\n                throw new Error(\n                    'Appetize browser tests are currently only supported on Android devices.'\n                );\n            }\n            const { page, browserContext, device } =\n                await createAndroidDeviceBrowserPage(session, testInfo);\n            try {\n                await use(page);\n                await browserContext.close();\n            } finally {\n                await disconnectAndroidDevice(device);\n            }\n            return;\n        }\n        const newPage = await context.newPage();\n        await use(newPage);\n    },\n\n    async appetizePage({ context, config, baseURL }, use, testInfo) {\n        if (!isAppetize(testInfo)) {\n            throw new Error(\n                'Appetize config not found in test. Either define it in the Playwright project or with test.use({ config: { ... } })'\n            );\n        }\n\n        if (appetizePage) {\n            const { session, page } = appetizePage;\n            if (session) {\n                let shouldClose = false;\n                if (lastConfig) {\n                    for (const key in config) {\n                        if (\n                            JSON.stringify(lastConfig[key]) !==\n                            JSON.stringify(config[key])\n                        ) {\n                            shouldClose = true;\n                            break;\n                        }\n                    }\n                } else {\n                    shouldClose = true;\n                }\n\n                if (shouldClose) {\n                    if (session) {\n                        await session.end().catch(() => {});\n                    }\n                    await page.close();\n                    appetizePage = null;\n                }\n            }\n        }\n\n        if (!appetizePage) {\n            appetizePage = await setupAppetizePage(context, config, baseURL);\n        }\n\n        lastConfig = config;\n        await use(appetizePage);\n    },\n    async session({ appetizePage, config, _doSetupAndTeardown }, use) {\n        // referencing this in the fixture will trigger\n        // our setup and teardown behavior\n        // for both passes and fails\n        _doSetupAndTeardown;\n        const session = await setupSession(appetizePage, config);\n        await use(session);\n    },\n    async client({ appetizePage }, use) {\n        await use(appetizePage.client);\n    },\n\n    // test.use({ config }) will write to this\n    _useConfig: [{}, { option: true }],\n\n    // trim platform (of computer) from snapshot suffix\n    _autoSnapshotSuffix: [\n        async ({}, use, testInfo) => {\n            testInfo.snapshotSuffix = '';\n            await use();\n        },\n        { auto: true },\n    ],\n\n    _doSetupAndTeardown: [\n        async ({ appetizePage }, use, testInfo) => {\n            logger.clearLogHistory();\n\n            if (appetizePage) {\n                appetizePage.onTestStart();\n            }\n\n            await use();\n\n            try {\n                // incase test.afterEach() wasn't called because user never made a test.afterEach()\n                await saveAttachmentsOnFail({ appetizePage, testInfo });\n            } catch (e) {\n                logger.error(`Failed to save attachments`, e);\n            }\n\n            if (testInfo.status === 'timedOut') {\n                if (appetizePage.queueTime) {\n                    logger.error(\n                        `Test timed out while in queue for a device. You may increase your test timeout to account for higher queue times.`\n                    );\n                }\n            }\n\n            try {\n                removeHiddenSteps(testInfo);\n            } catch (e) {\n                // no-op if this breaks\n            }\n        },\n        { auto: false },\n    ],\n    context: [\n        async ({ _browserContext, video, contextOptions }, use) => {\n            // warn about video recording\n            if (video && video !== 'off') {\n                logger.warn.once(\n                    `Video recording is not yet supported with @appetize/playwright. Use tracing instead to view recordings of your tests https://docs.appetize.io/javascript-sdk/playwright/trace-viewer`\n                );\n            }\n\n            // warn about context options\n            if (Object.keys(contextOptions).length) {\n                logger.warn.once(\n                    `contextOptions are not supported with @appetize/playwright`\n                );\n            }\n\n            await use(_browserContext);\n        },\n        {\n            scope: 'test',\n        },\n    ],\n    // we want the context to last across all tests\n    _browserContext: [\n        async ({ browser }, use) => {\n            const context = await browser.newContext();\n            await use(context);\n            await context.close();\n        },\n        {\n            scope: 'worker',\n        },\n    ],\n});\n\n// maps test.use({ config: ... }) to write to _useConfig, which will get merged with project.use.config\n// output as config in the test args\nconst makeUse = (test: TestType<TestArgs, WorkerArgs>) => {\n    const use = test.use;\n    return (options: AppetizeTestOptions) => {\n        const { config, ...rest } = options;\n        return use({\n            ...rest,\n            // @ts-ignore\n            _useConfig: config,\n        });\n    };\n};\n\n// when a test fails, we want to immediately gather data (screenshots, video, etc)\n// from the session. afterEach() will always run *after* fixture teardowns, so we need\n// to insert our own. (see https://playwright.dev/docs/test-fixtures#execution-order)\nconst makeAfterEach = (test: TestType<TestArgs, WorkerArgs>) => {\n    const afterEach = test.afterEach;\n    return (fn: any) => {\n        afterEach(async ({ appetizePage }, testInfo) => {\n            if (appetizePage) {\n                try {\n                    await saveAttachmentsOnFail({ appetizePage, testInfo });\n                } catch (e) {\n                    logger.error(`Failed to save attachments`, e);\n                }\n            }\n        });\n\n        return afterEach(fn);\n    };\n};\n\nconst makeExtend = (test: TestType<TestArgs, WorkerArgs>) => {\n    const extend = test.extend;\n    return (options: any) => {\n        const extended = extend(options);\n\n        // we need to re-wrap the extended fixture\n        extended.afterEach = makeAfterEach(extended).bind(extended);\n        extended.use = makeUse(extended).bind(extended);\n        extended.extend = makeExtend(extended).bind(extended) as any;\n\n        return extended;\n    };\n};\n\nObject.assign(_test, {\n    use: makeUse(_test),\n    afterEach: makeAfterEach(_test),\n    extend: makeExtend(_test),\n    setup(\n        this: TestType<TestArgs, WorkerArgs>,\n        options: AppetizeTestOptions['config']\n    ) {\n        if (!process.env.__APPETIZE__SETUP_WARNED) {\n            logger.warn(\n                `test.setup() is deprecated and will be removed in a future release. Use test.use({ config: {...} }) instead`\n            );\n            process.env.__APPETIZE__SETUP_WARNED = 'true';\n        }\n\n        return test.use({ config: options });\n    },\n});\n\nexport const test = _test as TestType<TestArgs, WorkerArgs>;\n\nexport type AppetizeTestFixture = typeof test;\n\nconst outputCache = new WeakMap();\n\nasync function saveAttachmentsOnFail(args: {\n    appetizePage: AppetizePage;\n    testInfo: TestInfo;\n}) {\n    const { appetizePage, testInfo } = args;\n\n    const session = appetizePage.session;\n\n    const shouldSaveOutput =\n        testInfo.status === 'failed' ||\n        testInfo.status === 'timedOut' ||\n        testInfo.status === 'interrupted';\n\n    // i don't know why, but fixture teardowns will run after beforeAll with testInfo.status = 'pass'\n    // so return early if we're not in a failed state (we only want the output data on fail anyway)\n    if (!shouldSaveOutput) return;\n\n    // this may get called multiple times, bail if we've already saved output\n    if (outputCache.get(testInfo.fn)) return;\n    outputCache.set(testInfo.fn, true);\n\n    const tmpDir = path.join(\n        os.tmpdir(),\n        `appetize-playwright-${testInfo.testId}-${testInfo.workerIndex}`\n    );\n\n    const removeTmpDir = async () => {\n        if (fs.existsSync(tmpDir)) {\n            await fs.promises\n                .rm(tmpDir, {\n                    recursive: true,\n                    force: true,\n                })\n                .catch(() => {\n                    // noop\n                });\n        }\n    };\n\n    try {\n        // remove dir if it already exists\n        await removeTmpDir();\n\n        await fs.promises.mkdir(tmpDir);\n        const actionLogs = appetizePage.sessionDebugInfo.playedActions;\n\n        const saveScreenshot = async () => {\n            try {\n                if (session) {\n                    const screenshot = await session.screenshot('buffer');\n                    const screenshotPath = path.join(tmpDir, 'screenshot.png');\n                    await fs.promises.writeFile(\n                        screenshotPath,\n                        Buffer.from(screenshot.data)\n                    );\n                    await testInfo.attach('screenshot', {\n                        path: screenshotPath,\n                        contentType: 'image/png',\n                    });\n                }\n            } catch (e) {\n                logger.error(\n                    `Failed to attach screenshot.png`,\n                    e instanceof Error ? e.message : undefined\n                );\n            }\n        };\n\n        const saveActions = async () => {\n            try {\n                const actions = actionLogs.map((log) => {\n                    if ('screenshot' in log) {\n                        const { screenshot, ...r } = log;\n                        return r;\n                    }\n\n                    return log;\n                });\n\n                if (!actions.length) {\n                    return;\n                }\n\n                const content = JSON.stringify(actions, null, 2);\n                const actionsPath = path.join(tmpDir, 'actions.json');\n\n                await fs.promises.writeFile(actionsPath, content);\n                await testInfo.attach('actions', {\n                    path: actionsPath,\n                    contentType: 'application/json',\n                });\n            } catch (e) {\n                logger.error(\n                    `Failed to attach actions.json`,\n                    e instanceof Error ? e.message : undefined\n                );\n            }\n        };\n\n        const saveH264Video = async () => {\n            try {\n                // NOTE: we currently cannot mux in audio due to lack of timestamps, the tracks wouldnt be in sync\n                const { videoFrames } = appetizePage.sessionDebugInfo;\n\n                if (\n                    videoFrames.length === 0 ||\n                    videoFrames.some((f) => f.codec !== 'h264')\n                ) {\n                    return;\n                }\n\n                const mode = 'video';\n\n                const jmuxer = new JMuxer(\n                    // @ts-expect-error - bad 3rd party types\n                    {\n                        mode,\n                        fps: 15,\n                    }\n                );\n\n                const mp4 = await new Promise<Buffer>((res, rej) => {\n                    const tm = setTimeout(() => {\n                        rej(new Error('Timed out muxing session video'));\n                    }, 30000);\n\n                    const reader = new Readable({\n                        objectMode: true,\n                        read() {},\n                    });\n\n                    const video = Buffer.concat(\n                        videoFrames.map((frame) => Buffer.from(frame.buffer))\n                    );\n\n                    reader.push({ video });\n                    reader.push(null);\n\n                    let mp4 = Buffer.from([]);\n\n                    reader\n                        .pipe(jmuxer.createStream())\n                        .on('data', (d) => {\n                            mp4 = Buffer.concat([mp4, d]);\n                        })\n                        .on('error', (e) => {\n                            clearTimeout(tm);\n                            rej(e);\n                        })\n                        .on('end', () => {\n                            clearTimeout(tm);\n                            res(mp4);\n                        });\n                });\n\n                const mp4Path = path.join(tmpDir, 'video.mp4');\n\n                await fs.promises.writeFile(mp4Path, mp4);\n\n                await testInfo.attach('video.mp4', {\n                    path: mp4Path,\n                    contentType: 'video/mp4',\n                });\n            } catch (e) {\n                logger.error(\n                    `Failed to attach video.mp4`,\n                    e instanceof Error ? e.message : undefined\n                );\n            }\n        };\n\n        const saveSDKLogs = async () => {\n            if (!logger.logHistory.length) {\n                return;\n            }\n\n            try {\n                const content = `${logger.logHistory\n                    .map(\n                        (log) =>\n                            `[${log.method}] ${JSON.stringify(log.data).slice(\n                                2,\n                                -2\n                            )}`\n                    )\n                    .join('\\n')}`;\n\n                const logsPath = path.join(tmpDir, 'sdk-logs.txt');\n\n                await fs.promises.writeFile(logsPath, content);\n                await testInfo.attach('sdk-logs', {\n                    path: logsPath,\n                    contentType: 'application/text',\n                });\n            } catch (e) {\n                logger.error(`Failed to attach sdk-logs.txt`, e);\n            }\n        };\n\n        const saveDebugLogs = async () => {\n            const { debugLogs } = appetizePage.sessionDebugInfo;\n            if (debugLogs.length > 0) {\n                try {\n                    const content = debugLogs.join(''); // logs include \\n already\n\n                    const logsPath = path.join(tmpDir, 'debug-logs.txt');\n\n                    await fs.promises.writeFile(logsPath, content);\n                    await testInfo.attach('debug-logs', {\n                        path: logsPath,\n                        contentType: 'application/text',\n                    });\n                } catch (e) {\n                    logger.error(`Failed to attach debug-logs.txt`, e);\n                }\n            }\n        };\n\n        const saveSession = async () => {\n            try {\n                if (appetizePage.session) {\n                    const infoPath = path.join(tmpDir, 'session.json');\n                    const content = JSON.stringify(\n                        {\n                            path: appetizePage.session.path,\n                            token: appetizePage.session.token,\n                            config: appetizePage.session.config,\n                        },\n                        null,\n                        2\n                    );\n\n                    await fs.promises.writeFile(infoPath, content);\n                    await testInfo.attach('session', {\n                        path: infoPath,\n                        contentType: 'application/json',\n                    });\n                }\n            } catch (e) {\n                logger.error(`Failed to attach session.json`, e);\n            }\n        };\n\n        await Promise.all([\n            saveScreenshot(),\n            saveActions(),\n            saveH264Video(),\n            saveDebugLogs(),\n            saveSession(),\n        ]);\n\n        // make sure we save sdk logs last, so we can capture any error messages from the above\n        await saveSDKLogs();\n    } finally {\n        await removeTmpDir();\n    }\n}\n\n/**\n * Remove hidden steps from the test info object\n *\n * Playwright does not support hidden steps so we use empty titles to mark a hidden step. This\n * is mainly used for socket messages (sent using page.evaluate) that aren't relevant to the test (requestKeyFrame, etc)\n */\nfunction removeHiddenSteps(parent) {\n    const steps = parent.steps || parent._steps;\n\n    if (!steps) {\n        return;\n    }\n\n    steps.forEach((step, i) => {\n        if (step.title === '') {\n            steps.splice(i, 1);\n        }\n        removeHiddenSteps(step);\n    });\n}\n\n/**\n * Check if the project is using Appetize\n * @param testInfo The test info object\n */\nfunction isAppetize(testInfo: TestInfo): boolean {\n    return !!(testInfo.project.use as AppetizeTestOptions).config;\n}\n\nasync function setupAppetizePage(\n    context: BrowserContext,\n    config: Partial<PlaywrightSessionConfig>,\n    baseURL: string | undefined\n) {\n    if (!config.buildId) {\n        throw new Error(\n            'Appetize buildId not set. Make sure you have set it with `test.use({ config: { buildId: \"...\" } })` or in your Playwright config file.'\n        );\n    }\n\n    const appetizePage = new AppetizePage({\n        page: await context.newPage(),\n        testFixture: test,\n        config,\n        baseURL,\n    });\n\n    await appetizePage.init();\n    return appetizePage;\n}\n\nasync function setupSession(\n    appetizePage: AppetizePage,\n    config: Partial<PlaywrightSessionConfig>\n) {\n    let session = appetizePage.session;\n    if (!session) {\n        session = await test.step(\n            'Start Appetize session',\n            async () => {\n                await appetizePage.start({ config });\n\n                if (appetizePage.queueTime) {\n                    test.info().annotations.push({\n                        type: 'queueTime',\n                        description: `${appetizePage.queueTime}ms`,\n                    });\n                }\n\n                if (!appetizePage.session) {\n                    throw new Error('Appetize session failed to start');\n                }\n\n                return appetizePage.session;\n            },\n            { box: true }\n        );\n\n        test.info().annotations.push({\n            type: 'Appetize Documentation',\n            description: 'https://docs.appetize.io/testing',\n        });\n    }\n\n    session.testFixture = test;\n    return session;\n}\n"],"names":["test$1","session","element","options","elements","e","retry","fn","retries","timeout","predicate","resolve","uuid","c","r","queryString","params","key","value","createDeferredPromise","resolved","rejected","reject","res","rej","err","cleanObject","obj","item","acc","cleanedValue","Logger","type","loggedMessages","context","msg","EventEmitter","BaseEventEmitter","captureStackTrace","targetObject","constructorOpt","container","stack","captureOperationalError","OperationalError","message","ActionError","error","ActionElementNotFoundError","ActionAmbiguousElementError","formatAmbiguousElements","ActionInvalidArgumentError","action","ActionInternalError","TimeoutError","ActionTimeoutError","playback","RecorderRequiredError","feature","truncatedElements","truncated","index","DataValidator","rootKeys","rootAttributes","intersect","list","v","coordinates","bounds","position","x","DataParser","y","a","b","ElementMapper","platform","screen","attributes","rest","mapBounds","width","height","mapAttributes","accessibilityElements","mapAccessibilityElements","accessibilityEl","accessibilityFrame","ActionMapper","localPosition","move","character","SessionEventMapper","app","payload","mappedAction","_a","_b","_c","_d","appUi","_e","springboardUi","mapRecursive","result","_f","ClientEventMapper","ClientSocketMapper","socket","mapped","event","data","Client","logger","queue","listener","config","handleDisconnect","handleSessionError","ev","handleClientError","waitFor","start","bail","waitForTimeout","ms","waitForEvent","emitter","optionsOrPredicate","parseConfig","HeadfulClient","window","autoInit","args","setConfig","oldConfig","newConfig","deviceInfo","wasRequestingSession","wasCancelled","handleResolve","handleReject","buildId","publicKey","currentSetConfigCallId","response","validatedConfig","info","PlaywrightLogger","print","uint8ArrayToString","uint8Arr","length","i","addition","uint8ArrayToBase64","mimeType","str","base64String","SwipeGesture","duration","stepDuration","previous","totalSteps","stepsPerSegment","accruedWaitTime","requiredDuration","lowerCoord","upperCoord","isLastPair","step","progress","interpolatedX","interpolatedY","t","lastResult","distance","SessionSocketMapper","Session","path","token","device","__privateAdd","_adbConnection","_networkInspectorUrl","handleSocketEvent","__privateSet","getAdbShellCommand","isConnected","waitForValue","cb","interval","__privateGet","direction","orientation","format","text","language","latitude","longitude","location","url","appId","match","file","endpoint","invalidFileNameExpression","filename","isEnrolled","allow","command","MAX_APP_RECORDER_TIMEOUT","MAX_WAIT_FOR_RESPONSE","hardTimeout","cleanup","handleSuccess","handleError","remainingTimeout","actions","results","nextAction","gesture","g","imageThreshold","imageThresholdDuration","lowestImageThreshold","promise","timeoutId","lastTimeUnderThreshold","handlePixelsChanged","percentage","timestamp","connectionInfo","template","returnValue","pause","page","getKeyFromKeypress","keypress","isSpecialKey","Codegen","testInfo","contents","fs","currentLine","line","num","handleAction","concatActions","describeAction","newContents","tabs","cur","lastAction","on","VERSION","AppetizeWindow","testFixture","json","channel","waitForResponse","tm","PlaywrightSocket","socketEventType","socketEventValue","PlaywrightSession","selector","log","ui","title","subStepTitle","windows","PlaywrightClient","isInQueue","sessionInfo","AppetizePage","pageRes","label","resizeToDevice","attempt","frame","execAsync","promisify","exec","readFileAsync","writeFileAsync","createAndroidDeviceBrowserPage","adbInfo","host","port","checkAdbInstalled","sshCmd","sshOutput","adbCmd","adbOutput","android","devices","flags","getExistingChromeCommandLineFlags","browserContext","pushChromeCommandLine","pages","disconnectAndroidDevice","testOutputDir","pulledPath","chromeCommandLinePath","flagsString","content","appetizePage","lastConfig","_test","base","_useConfig","use","baseURL","isAppetize","setupAppetizePage","setupSession","newPage","shouldClose","_doSetupAndTeardown","saveAttachmentsOnFail","removeHiddenSteps","_browserContext","video","contextOptions","browser","makeUse","test","makeAfterEach","afterEach","makeExtend","extend","extended","outputCache","tmpDir","os","removeTmpDir","actionLogs","saveScreenshot","screenshot","screenshotPath","saveActions","actionsPath","saveH264Video","videoFrames","f","mode","jmuxer","JMuxer","mp4","reader","Readable","d","mp4Path","saveSDKLogs","logsPath","saveDebugLogs","debugLogs","saveSession","infoPath","parent","steps"],"mappings":"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"}