export declare function retry<T>(fn: () => T | Promise<T>, { retries, timeout, predicate, }: {
    retries?: number;
    timeout?: number;
    predicate?: (e: unknown, attempt: number) => boolean | undefined;
}): Promise<T>;
export declare function clamp(value: number, min: number, max: number): number;
export declare function uuid(): string;
export declare function queryString(params: Record<string, any>): string;
export interface DeferredPromise<T> {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (error: any) => void;
    resolved?: T;
    rejected?: unknown;
}
export declare function createDeferredPromise<T = void>(): DeferredPromise<T>;
type CleanedObject<T> = {
    [P in keyof T]: T[P] extends object ? CleanedObject<T[P]> : T[P];
};
export declare function cleanObject<T>(obj: T): CleanedObject<T>;
export declare function parseOsVersion(version: string): {
    major: number;
    minor: number;
    patch: number;
};
type UnionKeys<T> = T extends T ? keyof T : never;
type StrictUnionHelper<T, TAll> = T extends any ? T & Partial<Record<Exclude<UnionKeys<TAll>, keyof T>, never>> : never;
export type StrictUnion<T> = StrictUnionHelper<T, T>;
export type LiteralUnion<T extends U, U = string> = T | (U & {
    zz_IGNORE_ME?: never;
});
export type OmitUnion<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
export {};
