var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _adbConnection, _networkInspectorUrl;
import { expect, test as test$1 } from "@playwright/test";
export { expect } from "@playwright/test";
import { EventEmitter as EventEmitter$1 } from "events";
import fs from "fs";
import JMuxer from "jmuxer";
import { Readable } from "stream";
import os from "os";
import path from "path";
import { exec } from "child_process";
import { _android } from "playwright-core";
import { promisify } from "util";
expect.extend({
  toHaveElement: async (session, element, options = {}) => {
    try {
      const elements = await session.findElements(element, options);
      const pass = typeof options.matches === "number" ? elements.length === options.matches : elements.length > 0;
      return {
        pass,
        message: () => `Element not found:
${JSON.stringify(element, null, 2)}`
      };
    } catch (e) {
      return {
        pass: false,
        message: () => e.message
      };
    }
  }
});
async function retry(fn, {
  retries = 3,
  timeout = 1e3,
  predicate = () => true
}) {
  for (let i = 1; i <= retries; i++) {
    try {
      return await fn();
    } catch (e) {
      if (i === retries || !predicate(e, i)) {
        throw e;
      }
      await new Promise((resolve) => setTimeout(resolve, timeout));
    }
  }
  throw null;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function queryString(params) {
  return Object.entries(params).map(([key, value]) => {
    if (typeof value !== "undefined") {
      return `${key}=${encodeURIComponent(value)}`;
    }
    return "";
  }).join("&");
}
function createDeferredPromise() {
  let resolved;
  let rejected;
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = (value) => {
      resolved = value;
      res(value);
    };
    reject = (err) => {
      resolved = err;
      rej(err);
    };
  });
  return {
    promise,
    resolve,
    reject,
    resolved,
    rejected
  };
}
function cleanObject(obj) {
  if (Array.isArray(obj)) {
    return obj.map(cleanObject).filter(
      (item) => item !== null && item !== void 0
    );
  }
  if (typeof obj === "object" && obj !== null) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      const cleanedValue = cleanObject(value);
      if (cleanedValue !== null && cleanedValue !== void 0) {
        acc[key] = cleanedValue;
      }
      return acc;
    }, {});
  }
  return obj;
}
class Logger {
  constructor() {
    this.log = this.createLogFn("log");
    this.warn = this.createLogFn("warn");
    this.error = this.createLogFn("error");
    this.debug = this.createLogFn("log");
  }
  createLogFn(type) {
    const loggedMessages = /* @__PURE__ */ new Set();
    const context = "[Appetize]";
    const fn = Function.prototype.bind.call(
      console[type],
      console,
      context
    );
    fn.once = (msg) => {
      if (loggedMessages.has(msg)) {
        return;
      } else {
        loggedMessages.add(msg);
      }
      return fn.call(console, msg);
    };
    return fn;
  }
}
class EventEmitter extends EventEmitter$1 {
  constructor() {
    super();
    this.on("error", () => {
    });
  }
}
function captureStackTrace(targetObject, constructorOpt) {
  if ("captureStackTrace" in Error) {
    Error.captureStackTrace(targetObject, constructorOpt);
  } else {
    const container = new Error();
    Object.defineProperty(targetObject, "stack", {
      configurable: true,
      get() {
        const { stack } = container;
        Object.defineProperty(this, "stack", { value: stack });
        return stack;
      }
    });
  }
}
async function captureOperationalError(e, constructorOpt) {
  if (e instanceof OperationalError) {
    captureStackTrace(e, constructorOpt);
  }
}
class OperationalError extends Error {
  constructor(message) {
    super(message);
    this.name = "Error";
    this.isOperational = true;
    captureStackTrace(this, this.constructor);
  }
}
class ActionError extends OperationalError {
  constructor(error, message) {
    super(message != null ? message : error.message);
    this.errorId = error.errorId;
    this.playback = error.playback;
  }
}
class ActionElementNotFoundError extends ActionError {
  constructor(error) {
    super(
      error,
      `No element found for selector
${JSON.stringify(
        error.playback.action.element,
        null,
        2
      )}`
    );
  }
}
class ActionAmbiguousElementError extends ActionError {
  constructor(error) {
    super(
      error,
      `Action requires 1 unique element but the selector returned ${error.matchedElements.length}. Provide a \`matchIndex\` to pick an element below or add additional attributes to your selector.

${formatAmbiguousElements(
        error.matchedElements
      )}`
    );
  }
}
class ActionInvalidArgumentError extends ActionError {
  constructor(error) {
    let msg = error.message;
    if (error.message.match("outside the screen bounds")) {
      const { action } = error.playback;
      if ("localPosition" in action && action.localPosition) {
        msg = `localPosition (${action.localPosition.x}, ${action.localPosition.y}) for the element evaluates to a coordinate outside of screen bounds.`;
      } else {
        msg = `Element is outside of screen bounds.`;
      }
    }
    super(error, msg);
  }
}
class ActionInternalError extends ActionError {
  constructor(error) {
    super(
      error,
      `An internal error has occurred for the action:
${JSON.stringify(
        error.playback.action,
        null,
        2
      )}`
    );
  }
}
class TimeoutError extends OperationalError {
}
class ActionTimeoutError extends OperationalError {
  constructor(playback, msg) {
    super(msg);
    this.playback = playback;
  }
}
class RecorderRequiredError extends OperationalError {
  constructor(feature) {
    super(
      `App Recorder must be enabled to use ${feature}. Please set "record" to true in the config.`
    );
  }
}
function formatAmbiguousElements(elements) {
  const maxElements = 5;
  const truncatedElements = elements.slice(0, maxElements);
  const truncated = elements.length > maxElements;
  const formatted = truncatedElements.map(
    (e, index) => `// ${index}
${JSON.stringify(e, null, 2)}`
  );
  return `${formatted.join("\n\n")}${truncated ? `

...and ${elements.length - maxElements} more` : ""}`;
}
class DataValidator {
  static isValidElementSelector(element) {
    if (typeof element !== "object" || Array.isArray(element)) {
      throw new Error("Element must be an object");
    }
    const rootKeys = Object.keys(element);
    const knownAttributeFields = [
      "text",
      "accessibilityIdentifier",
      "accessibilityLabel",
      "resource-id",
      "content-desc",
      "class",
      "baseClass"
    ];
    const rootAttributes = intersect(rootKeys, knownAttributeFields);
    if (rootAttributes.length > 0) {
      const list = rootAttributes.map((v) => `'${v}'`).join(", ");
      throw new Error(
        `Element has invalid properties: ${list}. Did you mean to put these under 'attributes'?`
      );
    }
    return element;
  }
  static isCoordinatesWithinBounds(coordinates, bounds) {
    if (coordinates.x < 0 || coordinates.x > bounds.width) {
      return false;
    }
    if (coordinates.y < 0 || coordinates.y > bounds.height) {
      return false;
    }
    return true;
  }
  static isPositionWithinBounds(position) {
    const x = DataParser.toPositionValue(position.x);
    const y = DataParser.toPositionValue(position.y);
    if (x < 0 || x > 1) {
      return false;
    }
    if (y < 0 || y > 1) {
      return false;
    }
    return true;
  }
  static isValidNumber(value) {
    if (typeof value !== "number") {
      return false;
    }
    if (isNaN(value)) {
      return false;
    }
    return true;
  }
}
class DataParser {
  static toBoolean(value) {
    return value === 1 ? true : false;
  }
  static toNumber(value) {
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "boolean" || value === void 0) {
      return value ? 1 : 0;
    }
    if (value === "inf") {
      return Infinity;
    } else if (value === "-inf") {
      return -Infinity;
    }
    return parseFloat(value);
  }
  static toObjCNumber(value) {
    if (value === Infinity) {
      return "inf";
    }
    if (value === -Infinity) {
      return "-inf";
    }
    return value;
  }
  static toPositionValue(value) {
    if (typeof value === "string") {
      if (value.endsWith("%")) {
        return parseInt(value, 10) / 100;
      } else {
        throw new Error(
          `Invalid position value: ${value}. Must be a number between 0 and 1, or a string ending with %`
        );
      }
    }
    return value;
  }
}
function intersect(a, b) {
  return a.filter((v) => b.includes(v));
}
class ElementMapper {
  constructor({
    platform,
    screen
  }) {
    this.platform = platform;
    this.screen = screen;
  }
  pixelToDip(value) {
    return value / (this.screen.devicePixelRatio || 1);
  }
  dipToPixel(value) {
    return value * (this.screen.devicePixelRatio || 1);
  }
  toInternal(element) {
    const { attributes, bounds, ...rest } = element;
    const mapBounds = () => {
      if (bounds) {
        const { x, y, width, height } = bounds;
        if (this.platform === "android") {
          return {
            x: this.dipToPixel(x),
            y: this.dipToPixel(y),
            width: this.dipToPixel(width),
            height: this.dipToPixel(height)
          };
        } else {
          return {
            x: DataParser.toObjCNumber(x),
            y: DataParser.toObjCNumber(y),
            width: DataParser.toObjCNumber(width),
            height: DataParser.toObjCNumber(height)
          };
        }
      }
    };
    const mapAttributes = () => {
      if (attributes) {
        return Object.keys(attributes).reduce((acc, key) => {
          if (this.platform === "ios") {
            switch (key) {
              case "userInteractionEnabled":
              case "isHidden":
                return {
                  ...acc,
                  [key]: attributes[key] ? "1" : "0"
                };
            }
          } else if (this.platform === "android")
            ;
          return {
            ...acc,
            [key]: attributes[key]
          };
        }, {});
      }
    };
    return cleanObject({
      ...rest,
      bounds: mapBounds(),
      attributes: mapAttributes(),
      accessibilityElements: void 0
    });
  }
  toPublic(element) {
    const { attributes, bounds, accessibilityElements, ...rest } = element;
    const mapBounds = (bounds2) => {
      if (this.platform === "android") {
        return {
          x: this.pixelToDip(bounds2.x),
          y: this.pixelToDip(bounds2.y),
          width: this.pixelToDip(bounds2.width),
          height: this.pixelToDip(bounds2.height)
        };
      } else {
        return {
          x: DataParser.toNumber(bounds2.x),
          y: DataParser.toNumber(bounds2.y),
          width: DataParser.toNumber(bounds2.width),
          height: DataParser.toNumber(bounds2.height)
        };
      }
    };
    const mapAttributes = (attributes2) => {
      return Object.keys(attributes2).reduce((acc, key) => {
        switch (key) {
          case "userInteractionEnabled":
          case "isHidden":
            return {
              ...acc,
              [key]: attributes2[key] === "1" ? true : false
            };
          default:
            return {
              ...acc,
              [key]: attributes2[key]
            };
        }
      }, {});
    };
    const mapAccessibilityElements = (accessibilityElements2) => {
      return accessibilityElements2.map((accessibilityEl) => {
        const { accessibilityFrame } = accessibilityEl;
        return {
          ...mapAttributes(accessibilityEl),
          accessibilityFrame: accessibilityFrame ? mapBounds(accessibilityFrame) : void 0
        };
      });
    };
    return cleanObject({
      ...rest,
      bounds: bounds ? mapBounds(bounds) : void 0,
      attributes: attributes ? mapAttributes(attributes) : void 0,
      accessibilityElements: accessibilityElements ? mapAccessibilityElements(accessibilityElements) : void 0
    });
  }
}
class ActionMapper {
  constructor({
    platform,
    screen
  }) {
    this.platform = platform;
    this.screen = screen;
    this.elementMapper = new ElementMapper({
      platform,
      screen
    });
  }
  pixelToDip(value) {
    return value / (this.screen.devicePixelRatio || 1);
  }
  dipToPixel(value) {
    return value * (this.screen.devicePixelRatio || 1);
  }
  getCoordinates(position, bounds) {
    const x = DataParser.toPositionValue(position.x);
    const y = DataParser.toPositionValue(position.y);
    return {
      x: x * bounds.width,
      y: y * bounds.height
    };
  }
  getPosition(coordinates, bounds) {
    return {
      x: coordinates.x / bounds.width,
      y: coordinates.y / bounds.height
    };
  }
  toInternalKey(value) {
    switch (value) {
      case "HOME":
        return "home";
      case "VOLUME_UP":
        return "volumeUp";
      case "VOLUME_DOWN":
        return "volumeDown";
    }
    return value;
  }
  toPublicKey(value) {
    switch (value) {
      case "home":
        return "HOME";
      case "volumeUp":
        return "VOLUME_UP";
      case "volumeDown":
        return "VOLUME_DOWN";
    }
    return value;
  }
  toInternal(action) {
    const map = () => {
      action = cleanObject(action);
      let element;
      let coordinates;
      let localPosition;
      if ("element" in action && action.element) {
        element = this.elementMapper.toInternal(action.element);
      }
      if ("position" in action && action.position) {
        const x = DataParser.toPositionValue(action.position.x);
        const y = DataParser.toPositionValue(action.position.y);
        if (!DataValidator.isValidNumber(x) || !DataValidator.isValidNumber(y)) {
          throw new OperationalError(
            `Invalid position: (${action.position.x}, ${action.position.y}). Values must be a number or a percentage`
          );
        }
        if (!DataValidator.isPositionWithinBounds(action.position)) {
          if (typeof action.position.x === "string") {
            throw new Error(
              `Invalid position: (${action.position.x}, ${action.position.y}) must be within (0%, 0%) and (100%, 100%)`
            );
          } else {
            throw new Error(
              `Invalid position: (${action.position.x}, ${action.position.y}) must be within (0, 0) and (1, 1)`
            );
          }
        }
        if (this.platform === "android") {
          coordinates = this.getCoordinates(action.position, {
            width: this.dipToPixel(this.screen.width) - 1,
            height: this.dipToPixel(this.screen.height) - 1
          });
        } else {
          coordinates = this.getCoordinates(action.position, {
            width: this.screen.width - 1,
            height: this.screen.height - 1
          });
        }
      } else if ("coordinates" in action && action.coordinates) {
        if (!DataValidator.isValidNumber(action.coordinates.x) || !DataValidator.isValidNumber(action.coordinates.y)) {
          throw new OperationalError(
            `Invalid coordinates: (${action.coordinates.x}, ${action.coordinates.y}). Values must be a number`
          );
        }
        if (!DataValidator.isCoordinatesWithinBounds(
          action.coordinates,
          {
            width: this.screen.width - 1,
            height: this.screen.height - 1
          }
        )) {
          throw new OperationalError(
            `Invalid coordinates: (${action.coordinates.x}, ${action.coordinates.y}) exceed screen bounds (${this.screen.width - 1}, ${this.screen.height - 1})`
          );
        }
        if (this.platform === "android") {
          coordinates = {
            x: this.dipToPixel(action.coordinates.x),
            y: this.dipToPixel(action.coordinates.y)
          };
        } else {
          coordinates = action.coordinates;
        }
      }
      if ("localPosition" in action && action.localPosition) {
        const x = DataParser.toPositionValue(action.localPosition.x);
        const y = DataParser.toPositionValue(action.localPosition.y);
        if (!DataValidator.isValidNumber(x) || !DataValidator.isValidNumber(y)) {
          throw new OperationalError(
            `Invalid localPosition: (${action.localPosition.x}, ${action.localPosition.y}). Values must be a number or a percentage`
          );
        }
        localPosition = {
          x,
          y
        };
      } else {
        if (element) {
          localPosition = { x: 0.5, y: 0.5 };
        }
      }
      if ("duration" in action && action.duration) {
        if (!DataValidator.isValidNumber(action.duration)) {
          throw new OperationalError(
            `Invalid duration: ${action.duration}. Value must be a number`
          );
        }
      }
      switch (action.type) {
        case "tap": {
          const { position, ...rest } = action;
          return {
            ...rest,
            element,
            localPosition,
            coordinates
          };
        }
        case "swipe": {
          const { position, ...rest } = action;
          return {
            ...rest,
            element,
            localPosition,
            coordinates,
            moves: action.moves.map((move) => {
              if (this.platform === "android") {
                const { x, y } = this.getCoordinates(move, {
                  width: this.dipToPixel(this.screen.width) - 1,
                  height: this.dipToPixel(this.screen.height) - 1
                });
                return {
                  ...move,
                  x,
                  y
                };
              } else {
                const { x, y } = this.getCoordinates(move, {
                  width: this.screen.width - 1,
                  height: this.screen.height - 1
                });
                return {
                  ...move,
                  x,
                  y
                };
              }
            })
          };
        }
        case "keypress": {
          const key = this.toInternalKey(action.key);
          const character = this.toInternalKey(action.character);
          return {
            ...action,
            key,
            character,
            shiftKey: this.platform === "ios" ? DataParser.toNumber(action.shiftKey) : action.shiftKey
          };
        }
        case "findElements": {
          return {
            ...action,
            element
          };
        }
      }
      return action;
    };
    return cleanObject(map());
  }
  toPublic(action) {
    const map = () => {
      let element;
      let coordinates;
      let position;
      let localPosition = "localPosition" in action ? action.localPosition : void 0;
      if ("coordinates" in action && action.coordinates) {
        coordinates = {
          x: this.pixelToDip(action.coordinates.x),
          y: this.pixelToDip(action.coordinates.y)
        };
        position = this.getPosition(coordinates, {
          width: this.screen.width - 1,
          height: this.screen.height - 1
        });
      }
      if ("element" in action && action.element) {
        element = this.elementMapper.toPublic(action.element);
        if (coordinates && element.bounds) {
          localPosition = this.getPosition(
            {
              x: coordinates.x - element.bounds.x,
              y: coordinates.y - element.bounds.y
            },
            {
              width: element.bounds.width,
              height: element.bounds.height
            }
          );
        }
      }
      switch (action.type) {
        case "tap": {
          return {
            ...action,
            coordinates,
            element,
            position,
            localPosition
          };
        }
        case "swipe": {
          return {
            ...action,
            coordinates,
            element,
            position,
            localPosition,
            moves: action.moves.map((move) => {
              const { x, y } = this.getPosition(
                {
                  x: this.pixelToDip(move.x),
                  y: this.pixelToDip(move.y)
                },
                {
                  width: this.screen.width - 1,
                  height: this.screen.height - 1
                }
              );
              return {
                x,
                y,
                t: move.t
              };
            })
          };
        }
        case "keypress": {
          const key = this.toPublicKey(action.key);
          const character = this.toPublicKey(action.character);
          return {
            ...action,
            key,
            character,
            shiftKey: typeof action.shiftKey === "number" ? DataParser.toBoolean(action.shiftKey) : Boolean(action.shiftKey)
          };
        }
        case "findElements": {
          return {
            ...action,
            element
          };
        }
      }
      return action;
    };
    return cleanObject(map());
  }
}
class SessionEventMapper {
  constructor({
    platform,
    screen,
    app
  }) {
    this.app = app;
    this.platform = platform;
    this.screen = screen;
    this.actionMapper = new ActionMapper({
      platform,
      screen
    });
    this.elementMapper = new ElementMapper({
      platform,
      screen
    });
  }
  toInternal(type, value) {
    switch (type) {
      case "playAction": {
        const payload = value;
        const noMap = value.__noMap__;
        const mappedAction = noMap ? value.action : this.actionMapper.toInternal(payload.action);
        return {
          type,
          value: {
            ...payload,
            action: mappedAction
          }
        };
      }
    }
    return { type, value };
  }
  toPublic(type, value) {
    var _a, _b, _c, _d, _e, _f;
    switch (type) {
      case "debug":
        return {
          type: "log",
          value
        };
      case "interceptResponse":
        return {
          type: "network",
          value: {
            type: "response",
            ...value
          }
        };
      case "interceptRequest":
        return {
          type: "network",
          value: {
            type: "request",
            ...value
          }
        };
      case "interceptError":
        return {
          type: "network",
          value: {
            type: "error",
            ...value
          }
        };
      case "userError":
        return {
          type: "error",
          value
        };
      case "userInteractionReceived":
        return {
          type: "interaction",
          value
        };
      case "countdownWarning":
        return {
          type: "inactivityWarning",
          value
        };
      case "h264Data":
        return {
          type: "video",
          value: {
            ...value,
            codec: "h264"
          }
        };
      case "frameData":
        return {
          type: "video",
          value: {
            ...value,
            codec: "jpeg"
          }
        };
      case "audioData": {
        return {
          type: "audio",
          value: {
            ...value,
            codec: "aac"
          }
        };
      }
      case "concurrentQueue":
        return {
          type: "queue",
          value: {
            type: "concurrent",
            name: value.name,
            position: value.position
          }
        };
      case "queue":
        return {
          type: "queue",
          value: {
            type: "session",
            position: value.position
          }
        };
      case "orientationChanged":
        return {
          type,
          value
        };
      case "chromeDevToolsUrl":
        return {
          type: "networkInspectorUrl",
          value
        };
      case "recordedAction": {
        return {
          type: "action",
          value: this.actionMapper.toPublic(value)
        };
      }
      case "playbackFoundAndSent": {
        const v = value;
        return {
          type: "playbackFoundAndSent",
          value: {
            ...v,
            playback: {
              ...v.playback,
              action: ((_a = v.playback) == null ? void 0 : _a.action) ? this.actionMapper.toPublic(v.playback.action) : void 0
            },
            matchedElements: (_b = v.matchedElements) == null ? void 0 : _b.map((e) => {
              if (e) {
                return this.elementMapper.toPublic(e);
              }
            })
          }
        };
      }
      case "playbackError": {
        const v = value;
        return {
          type: "playbackError",
          value: {
            ...v,
            playback: {
              ...v.playback,
              action: ((_c = v.playback) == null ? void 0 : _c.action) ? this.actionMapper.toPublic(v.playback.action) : void 0
            },
            matchedElements: (_d = v.matchedElements) == null ? void 0 : _d.map((e) => {
              if (e) {
                return this.elementMapper.toPublic(e);
              }
            })
          }
        };
      }
      case "uiDump": {
        const appUi = (_e = value.ui) != null ? _e : value.result;
        const springboardUi = value.springboard;
        const mapRecursive = (element) => {
          var _a2;
          return {
            ...this.elementMapper.toPublic(element),
            children: (_a2 = element.children) == null ? void 0 : _a2.map(mapRecursive)
          };
        };
        const result = [];
        if (appUi) {
          if (this.platform === "ios") {
            result.push({
              type: "app",
              appId: (_f = this.app) == null ? void 0 : _f.bundle,
              children: appUi.map(mapRecursive)
            });
          } else {
            result.push({
              type: "app",
              children: appUi.map(mapRecursive)
            });
          }
        }
        if (springboardUi) {
          result.push({
            type: "app",
            appId: "com.apple.springboard",
            children: springboardUi.map(mapRecursive)
          });
        }
        return {
          type: "uiDump",
          value: result
        };
      }
      case "deleteEvent":
        return null;
    }
    return {
      type,
      value
    };
  }
}
class ClientEventMapper {
  toInternal(type, value) {
    return { type, value };
  }
  toPublic(type, value) {
    switch (type) {
      case "userError":
        return {
          type: "error",
          value
        };
      case "concurrentQueue":
        return {
          type: "queue",
          value: {
            type: "concurrent",
            name: value.name,
            position: value.position
          }
        };
      case "queue":
        return {
          type: "queue",
          value: {
            type: "session",
            position: value.position
          }
        };
      case "deviceInfo":
      case "sessionInfo":
      case "sessionRequested":
        return {
          type,
          value
        };
    }
    return {
      type,
      value
    };
  }
}
class ClientSocketMapper extends EventEmitter {
  constructor({ socket }) {
    super();
    this.eventMapper = new ClientEventMapper();
    this._socket = socket;
    socket.on("*", ({ type, value }) => {
      const mapped = this.mapEmit(type, value);
      const suppressed = mapped === null;
      if (!suppressed) {
        this.emit(mapped.type, mapped.value);
        this.emit("*", mapped);
      }
    });
  }
  mapEmit(type, value) {
    return this.eventMapper.toPublic(type, value);
  }
  mapSend(type, value) {
    return this.eventMapper.toInternal(type, value);
  }
  send(event, data) {
    const mapped = this.mapSend(event, data);
    return this._socket.send(mapped.type, mapped.value);
  }
  disconnect() {
    return this._socket.disconnect();
  }
}
class Client extends EventEmitter {
  constructor({
    socket,
    logger: logger2 = new Logger()
  }) {
    super();
    this.logger = logger2;
    this.socket = new ClientSocketMapper({ socket });
    this.socket.on("*", ({ type, value }) => {
      if (type === "newSession") {
        return;
      }
      this.emit(type, value);
      this.emit("*", { type, value });
    });
    this.socket.on("newSession", () => {
      if (this.queue) {
        this.emit("queueEnd");
        this.queue = void 0;
      }
    });
    this.on("queue", (queue) => {
      this.queue = queue;
    });
  }
  on(event, listener) {
    return super.on(event, listener);
  }
  async startSession(config) {
    throw new Error("Not implemented");
  }
  async setConfig(config) {
    throw new Error("Not implemented");
  }
  getConfig() {
    return this._config;
  }
  async waitForSessionStart(session) {
    return new Promise(async (resolve, reject) => {
      const handleDisconnect = () => {
        reject(new Error("Session disconnected before it was ready"));
      };
      const handleSessionError = (ev) => {
        reject(
          new Error(
            `Session failed to start - ${typeof ev.message === "object" ? JSON.stringify(ev.message) : ev.message}`
          )
        );
      };
      const handleClientError = (ev) => {
        var _a;
        reject(
          new Error(
            `Session failed to start - ${(_a = ev == null ? void 0 : ev.message) != null ? _a : "Unknown error"}`
          )
        );
      };
      try {
        this.on("error", handleClientError);
        session.on("disconnect", handleDisconnect);
        session.on("error", handleSessionError);
        await session.waitUntilReady();
      } catch (e) {
        reject(e);
      } finally {
        this.off("error", handleClientError);
        session.off("disconnect", handleDisconnect);
        session.off("error", handleSessionError);
      }
      resolve(session);
    });
  }
}
async function waitFor(fn, timeout = 5e3) {
  const start = Date.now();
  let bail = false;
  while (true) {
    try {
      const result = await fn((error) => {
        if (error) {
          bail = true;
          throw error;
        }
      });
      return result;
    } catch (e) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      if (bail || timeout !== null && Date.now() - start > timeout) {
        throw e;
      }
    }
  }
}
async function waitForTimeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function waitForEvent(emitter, event, optionsOrPredicate) {
  const options = typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate;
  const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate == null ? void 0 : optionsOrPredicate.predicate;
  const timeout = typeof (options == null ? void 0 : options.timeout) !== "undefined" ? options.timeout : 1e4;
  return new Promise((resolve, reject) => {
    const listener = (data) => {
      if (!predicate || predicate(data)) {
        emitter.off(event, listener);
        resolve(data);
      }
    };
    emitter.on(event, listener);
    if (timeout !== null) {
      setTimeout(() => {
        emitter.off(event, listener);
        reject(
          new TimeoutError(
            `Timeout ${timeout}ms exceeded while waiting for event "${event}"`
          )
        );
      }, timeout);
    }
  });
}
function parseConfig(config) {
  if (!config) {
    return {};
  }
  return {
    ...cleanObject(config),
    device: config.deviceType || config.device
  };
}
class HeadfulClient extends Client {
  constructor({
    socket,
    window: window2,
    logger: logger2 = new Logger(),
    config,
    autoInit = true
  }) {
    super({ socket, logger: logger2 });
    this.ready = false;
    this.isRequestingSession = false;
    this._lastSetConfigCallId = null;
    this.window = window2;
    if (config) {
      this.assignConfig(config);
    }
    this.window.on("*", async ({ type, value }) => {
      if (this.ready) {
        switch (type) {
          case "app":
            this.app = value;
            this.emit(type, value);
            break;
          case "deviceInfo":
            this.device = value;
            this.emit(type, value);
            break;
          case "config":
            this.assignConfig(value);
            break;
        }
      }
    });
    this.window.on("reinit", () => {
      this.ready = false;
      this.session = void 0;
      this.init({ isReinit: true });
    });
    this.socket.on("*", async ({ type, value }) => {
      if (this.ready) {
        switch (type) {
          case "newSession": {
            try {
              this.isRequestingSession = false;
              this.session = this.createSession(this._config, {
                path: value.path,
                token: value.sessionToken
              });
              await this.waitForSessionStart(this.session);
              this.emit("session", this.session);
            } catch (e) {
              this.session = void 0;
              this.emit("sessionError", e);
            }
          }
        }
      }
    });
    if (autoInit !== false) {
      this.init();
    }
  }
  async init(args = { isReinit: false }) {
    await this.window.waitUntilReady();
    const setConfig = async () => {
      if (args.isReinit) {
        const oldConfig = this._config;
        const newConfig = await this.setConfig({});
        return this.setConfig({
          record: true,
          ...oldConfig,
          ...newConfig
        });
      } else {
        return this.setConfig({
          record: true,
          ...this._config
        });
      }
    };
    const [app, deviceInfo] = await Promise.all([
      this.window.postMessage({ type: "getApp" }, true),
      this.window.postMessage(
        { type: "getDeviceInfo" },
        true
      ),
      setConfig()
    ]);
    this.app = app;
    this.device = deviceInfo;
    this.ready = true;
  }
  async waitUntilReady() {
    if (this.ready) {
      return;
    }
    return waitFor(async () => {
      if (!this.ready) {
        throw new Error("Timed out waiting for client to be ready");
      }
    }, 3e4);
  }
  async startSession(config) {
    const wasRequestingSession = this.isRequestingSession;
    const wasCancelled = () => this.isRequestingSession === false;
    this.isRequestingSession = true;
    try {
      try {
        await this.waitUntilReady();
      } catch (e) {
        const message = e instanceof Error ? e.message : e;
        throw new Error(`Failed to start session. ${message}`);
      }
      if (!wasCancelled()) {
        if (this.session) {
          await this.session.end();
        } else if (wasRequestingSession) {
          await this.cancelSessionRequest();
          this.isRequestingSession = true;
        }
      }
      if (!wasCancelled()) {
        await this.setConfig(config != null ? config : {});
      }
      if (!wasCancelled()) {
        const [session] = await Promise.all([
          new Promise((resolve, reject) => {
            const handleResolve = (data) => {
              this.off("session", handleResolve);
              this.off("sessionError", handleReject);
              this.off("error", handleReject);
              resolve(data);
            };
            const handleReject = (data) => {
              this.off("session", handleResolve);
              this.off("sessionError", handleReject);
              this.off("error", handleReject);
              if (data instanceof Error) {
                reject(data);
              } else if (data && typeof data.message === "string") {
                reject(
                  new Error(
                    `Session failed to start - ${data.message}`
                  )
                );
              } else {
                reject(data);
              }
            };
            this.on("session", handleResolve);
            this.on("sessionError", handleReject);
            this.on("error", handleReject);
          }),
          this.window.postMessage({ type: "requestSession" }, true)
        ]);
        return session;
      } else {
        throw new Error("Session request was cancelled");
      }
    } finally {
      this.isRequestingSession = false;
    }
  }
  async endSession() {
    if (this.session) {
      await this.session.end();
    } else if (this.isRequestingSession) {
      await this.cancelSessionRequest();
    }
  }
  async config(args) {
    this.logger.warn(
      `client.config() is deprecated and will be removed in a future major release. Use client.setConfig() instead.`
    );
    return this.setConfig(args);
  }
  async setConfig({
    buildId,
    publicKey,
    ...config
  }) {
    this._lastSetConfigCallId = Math.random().toString(36);
    const currentSetConfigCallId = this._lastSetConfigCallId;
    if (!buildId && publicKey) {
      buildId = publicKey;
    }
    if (buildId) {
      const response = await this.window.postMessage(
        {
          type: "loadApp",
          value: buildId
        },
        true
      );
      if (response && "error" in response) {
        if (response.error === "cancelled") {
          return this._config;
        }
        throw new Error(response.error);
      }
      if (currentSetConfigCallId !== this._lastSetConfigCallId) {
        return this._config;
      }
    }
    const validatedConfig = await this.window.postMessage(
      {
        type: "setConfig",
        value: this.validateConfig({
          ...config,
          ...buildId ? { publicKey: buildId } : {}
        })
      },
      true
    );
    return this.assignConfig(validatedConfig);
  }
  assignConfig(config) {
    if (config.autoplay === true) {
      this.logger.warn.once(
        "autoplay=true may cause the session to start before the SDK is ready. You should start the session programmatically using client.startSession() instead."
      );
    }
    this._config = parseConfig(config);
    return this._config;
  }
  validateConfig(config) {
    return config;
  }
  async cancelSessionRequest() {
    if (this.isRequestingSession) {
      this.isRequestingSession = false;
      await this.window.postMessage("endSession");
      this.emit("sessionEnded");
    }
  }
  createSession(config, info) {
    throw new Error("Not implemented");
  }
}
class PlaywrightLogger extends Logger {
  constructor() {
    super(...arguments);
    this.logHistory = [];
    this.logLevel = process.env.CI === "true" ? "warnings-errors" : "verbose";
    this.log = this.createPlaywrightLogFn("log", () => this.logLevel === "verbose");
    this.warn = this.createPlaywrightLogFn(
      "warn",
      () => this.logLevel === "verbose" || this.logLevel === "warnings-errors"
    );
    this.error = this.createPlaywrightLogFn(
      "error",
      () => this.logLevel === "verbose" || this.logLevel === "warnings-errors"
    );
    this.debug = this.createPlaywrightLogFn(
      "debug",
      () => this.logLevel === "verbose"
    );
    this.clearLogHistory = () => {
      this.logHistory = [];
    };
  }
  createPlaywrightLogFn(type, print) {
    const loggedMessages = /* @__PURE__ */ new Set();
    const context = "[Appetize]";
    const fn = (...data) => {
      this.logHistory.push({
        method: type,
        data
      });
      if (print()) {
        console[type](context, ...data);
      }
    };
    fn.once = (msg) => {
      if (loggedMessages.has(msg)) {
        return;
      } else {
        loggedMessages.add(msg);
      }
      return fn.call(console, msg);
    };
    return fn;
  }
}
const logger = new PlaywrightLogger();
function uint8ArrayToString(uint8Arr) {
  const length = uint8Arr.length;
  let result = "";
  for (let i = 0; i < length; i += 65535) {
    let addition = 65535;
    if (i + 65535 > length) {
      addition = length - i;
    }
    result += String.fromCharCode.apply(
      null,
      uint8Arr.subarray(i, i + addition)
    );
  }
  return result;
}
function uint8ArrayToBase64(uint8Arr, mimeType) {
  if (typeof window === "undefined" && typeof Buffer !== "undefined") {
    const str = Buffer.from(uint8Arr).toString("base64");
    return `data:${mimeType};base64,` + str;
  } else {
    const str = uint8ArrayToString(uint8Arr);
    const base64String = btoa(str);
    return `data:${mimeType};base64,` + base64String;
  }
}
class SwipeGesture {
  constructor({ duration, stepDuration }) {
    this.moves = [];
    this.duration = duration;
    this.stepDuration = stepDuration != null ? stepDuration : 16;
    this.moves = [{ x: 0, y: 0 }];
  }
  to(x, y) {
    if (typeof x !== "string" || typeof y !== "string") {
      throw new OperationalError(
        'x and y must be strings and in percentages (e.g. "50%")'
      );
    }
    if (!x.endsWith("%") || !y.endsWith("%")) {
      throw new OperationalError(
        'x and y must be in percentages (e.g. "50%")'
      );
    }
    this.moves.push({
      x: parseFloat(x) / 100,
      y: parseFloat(y) / 100
    });
    return this;
  }
  wait(duration) {
    var _a;
    const previous = this.moves[this.moves.length - 1];
    if (previous) {
      previous.wait = duration + ((_a = previous.wait) != null ? _a : 0);
    }
    return this;
  }
  build() {
    var _a;
    const stepDuration = this.stepDuration;
    const duration = (_a = this.duration) != null ? _a : Math.max(500, stepDuration * (this.moves.length - 1));
    const totalSteps = Math.floor(duration / stepDuration);
    const stepsPerSegment = Math.floor(
      totalSteps / (this.moves.length - 1)
    );
    const result = [];
    let accruedWaitTime = 0;
    if (stepsPerSegment === 0) {
      const requiredDuration = (this.moves.length - 1) * stepDuration;
      throw new Error(
        `Duration is too short for ${this.moves.length - 1} moves, please set duration to at least ${requiredDuration}ms`
      );
    }
    for (let i = 0; i < this.moves.length - 1; i++) {
      const lowerCoord = this.moves[i];
      const upperCoord = this.moves[i + 1];
      const isLastPair = i === this.moves.length - 2;
      for (let step = 0; step <= stepsPerSegment; step++) {
        if (!isLastPair && step === stepsPerSegment)
          continue;
        const progress = step / stepsPerSegment;
        const interpolatedX = lowerCoord.x + progress * (upperCoord.x - lowerCoord.x);
        const interpolatedY = lowerCoord.y + progress * (upperCoord.y - lowerCoord.y);
        const t = ((i * stepsPerSegment + step) * stepDuration + accruedWaitTime) / 1e3;
        result.push({ x: interpolatedX, y: interpolatedY, t });
        if (step === 0 && lowerCoord.wait) {
          result.push({
            x: interpolatedX,
            y: interpolatedY,
            t: t + lowerCoord.wait / 1e3
          });
          accruedWaitTime += lowerCoord.wait;
        }
      }
      if (i === this.moves.length - 2 && upperCoord.wait) {
        const lastResult = result[result.length - 1];
        result.push({
          x: lastResult.x,
          y: lastResult.y,
          t: lastResult.t + upperCoord.wait / 1e3
        });
      }
    }
    return result;
  }
  up(distance = "50%") {
    const value = parseFloat(distance);
    return this.to("0%", `-${value}%`);
  }
  down(distance = "50%") {
    const value = parseFloat(distance);
    return this.to("0%", `${value}%`);
  }
  left(distance = "50%") {
    const value = parseFloat(distance);
    return this.to(`-${value}%`, "0%");
  }
  right(distance = "50%") {
    const value = parseFloat(distance);
    return this.to(`${value}%`, "0%");
  }
}
class SessionSocketMapper extends EventEmitter {
  constructor({
    socket,
    platform,
    screen,
    app
  }) {
    super();
    this._socket = socket;
    this.platform = platform;
    this.screen = screen;
    this.app = app;
    socket.on("*", ({ type, value }) => {
      const mapped = this.mapEmit(type, value);
      const suppressed = mapped === null;
      if (!suppressed) {
        this.handleEvent(mapped.type, mapped.value);
        this.emit(mapped.type, mapped.value);
        this.emit("*", mapped);
      }
    });
  }
  send(event, data) {
    const mapped = this.mapSend(event, data);
    return this._socket.send(mapped.type, mapped.value);
  }
  disconnect() {
    return this._socket.disconnect();
  }
  handleEvent(type, value) {
    switch (type) {
      case "app":
        this.app = value;
        break;
      case "deviceInfo": {
        const deviceInfo = value;
        if (deviceInfo == null ? void 0 : deviceInfo.screen) {
          this.screen = deviceInfo.screen;
        }
        break;
      }
      case "config": {
        const config = value;
        if (config.platform) {
          this.platform = config.platform;
        }
        break;
      }
    }
  }
  mapEmit(type, value) {
    const eventMapper = new SessionEventMapper({
      platform: this.platform,
      screen: this.screen,
      app: this.app
    });
    return eventMapper.toPublic(type, value);
  }
  mapSend(type, value) {
    const eventMapper = new SessionEventMapper({
      platform: this.platform,
      screen: this.screen,
      app: this.app
    });
    return eventMapper.toInternal(type, value);
  }
}
class Session extends EventEmitter {
  constructor({
    socket,
    config,
    path: path2,
    token,
    app,
    device,
    logger: logger2 = new Logger()
  }) {
    super();
    __privateAdd(this, _adbConnection, void 0);
    __privateAdd(this, _networkInspectorUrl, void 0);
    this.isEndingManually = false;
    this.countdownWarning = false;
    this.ready = false;
    this._waitForAnimationsPromises = /* @__PURE__ */ new Set();
    this.config = config;
    this.socket = new SessionSocketMapper({
      socket,
      app,
      screen: device.screen,
      platform: config.platform
    });
    this.device = device;
    this.app = app;
    this.path = path2;
    this.token = token;
    this.logger = logger2;
    const handleSocketEvent = ({ type, value }) => {
      switch (type) {
        case "ready":
          this.ready = true;
          break;
        case "adbOverTcp": {
          __privateSet(this, _adbConnection, {
            ...value,
            command: getAdbShellCommand(value)
          });
          break;
        }
        case "networkInspectorUrl":
          __privateSet(this, _networkInspectorUrl, value);
          break;
        case "countdownWarning":
          this.countdownWarning = true;
          break;
        case "timeoutReset":
          this.countdownWarning = false;
          break;
        case "deviceInfo":
          this.device = value;
          break;
        case "disconnect":
          this.emit("end");
          this.emit("*", { type: "end" });
          break;
      }
      this.emit(type, value);
      this.emit("*", { type, value });
    };
    this.socket.on("*", handleSocketEvent);
    this.on("disconnect", () => {
      this.socket.off("*", handleSocketEvent);
      if (!this.isEndingManually) {
        if (this.countdownWarning) {
          this.logger.warn(
            `Appetize session has ended due to inactivity`
          );
        } else {
          this.logger.warn(`Session disconnected`);
        }
      }
    });
  }
  on(event, listener) {
    if (event === "network" && this.config.proxy !== "intercept") {
      this.logger.warn(
        'Session must be configured with `proxy: "intercept"` to listen to network events.'
      );
    }
    if (event === "log" && this.config.debug !== true) {
      this.logger.warn(
        "Session must be configured with `debug: true` to listen to log events."
      );
    }
    if (event === "action" && this.config.record !== true) {
      this.logger.warn(
        "Session must configured with `record: true` to listen to action events."
      );
    }
    return super.on(event, listener);
  }
  async waitUntilReady() {
    let isConnected = true;
    const waitForValue = async (cb) => {
      return new Promise((res) => {
        const interval = setInterval(() => {
          if (cb()) {
            res(void 0);
          }
        }, 10);
        setTimeout(() => {
          clearInterval(interval);
          res(void 0);
        }, 3e3);
      });
    };
    const handleDisconnect = () => {
      isConnected = false;
    };
    this.socket.once("disconnect", handleDisconnect);
    try {
      await waitFor((bail) => {
        if (this.ready) {
          return;
        }
        if (isConnected) {
          throw new TimeoutError(
            "Timed out after 180s waiting for session to be ready"
          );
        } else {
          bail(new Error("Session disconnected"));
        }
      }, 18e4);
    } finally {
      this.socket.off("disconnect", handleDisconnect);
    }
    await Promise.all([
      this.config.proxy === "intercept" ? waitForValue(() => Boolean(__privateGet(this, _networkInspectorUrl))) : Promise.resolve(),
      this.config.enableAdb ? waitForValue(() => Boolean(__privateGet(this, _adbConnection))) : Promise.resolve()
    ]);
  }
  async waitForEvent(event, options) {
    try {
      return await waitForEvent(this, event, options);
    } catch (e) {
      captureOperationalError(e, this.waitForEvent);
      throw e;
    }
  }
  async end() {
    this.isEndingManually = true;
    await this.socket.disconnect();
  }
  get networkInspectorUrl() {
    if (this.config.proxy !== "intercept") {
      this.logger.warn(
        'Session must be configured with `proxy: "intercept"` to use the network inspector'
      );
    }
    return __privateGet(this, _networkInspectorUrl);
  }
  get adbConnection() {
    if (this.config.platform && this.config.platform !== "android") {
      this.logger.warn(
        "Session must be connected to an Android device to use adb"
      );
    }
    if (!this.config.enableAdb) {
      this.logger.warn(
        "Session must be configured with `enableAdb: true` to use adb"
      );
    }
    if (__privateGet(this, _adbConnection)) {
      return __privateGet(this, _adbConnection);
    }
  }
  async rotate(direction) {
    try {
      const [orientation] = await Promise.all([
        this.waitForEvent("orientationChanged"),
        this.socket.send("userInteraction", {
          type: "keypress",
          key: direction === "left" ? "rotateLeft" : "rotateRight",
          timeStamp: Date.now()
        })
      ]);
      return orientation;
    } catch (e) {
      captureOperationalError(e, this.rotate);
      throw e;
    }
  }
  async screenshot(format = "buffer") {
    var _a;
    try {
      this.socket.send("getScreenshot", {});
      const result = await waitForEvent(this.socket, "screenshot", { timeout: 6e4 });
      if (!result.success) {
        throw new OperationalError((_a = result.error) != null ? _a : `Screenshot failed`);
      }
      const toBuffer = (data2) => {
        return typeof window === "undefined" ? Buffer.from(data2) : data2;
      };
      const data = format === "buffer" ? toBuffer(result.data) : uint8ArrayToBase64(
        new Uint8Array(result.data),
        result.mimeType
      );
      return {
        data,
        mimeType: result.mimeType
      };
    } catch (e) {
      captureOperationalError(e, this.screenshot);
      throw e;
    }
  }
  async heartbeat() {
    try {
      return await this.socket.send("heartbeat");
    } catch (e) {
      captureOperationalError(e, this.heartbeat);
      throw e;
    }
  }
  async type(text) {
    try {
      await waitForTimeout(1e3);
      const result = await this.playAction({
        type: "typeText",
        text
      });
      await waitForTimeout(500);
      return result;
    } catch (e) {
      captureOperationalError(e, this.type);
      throw e;
    }
  }
  async keypress(key, options) {
    try {
      if (key === "ANDROID_KEYCODE_MENU") {
        return await this.socket.send("androidKeycodeMenu");
      }
      if ((options == null ? void 0 : options.shift) || key === "HOME") {
        switch (key) {
          case "ArrowUp":
            key = "arrowUp";
            break;
          case "ArrowDown":
            key = "arrowDown";
            break;
          case "ArrowLeft":
            key = "arrowLeft";
            break;
          case "ArrowRight":
            key = "arrowRight";
            break;
          case "Enter":
            key = "\r";
            break;
          case "Tab":
            key = "	";
            break;
          case "Backspace":
            key = "\b";
            break;
        }
        return this.playAction({
          type: "keypress",
          key,
          shiftKey: !!(options == null ? void 0 : options.shift)
        });
      } else {
        return this.playAction({
          type: "keypress",
          character: key
        });
      }
    } catch (e) {
      captureOperationalError(e, this.keypress);
      throw e;
    }
  }
  async setLanguage(language) {
    try {
      this.config.language = language;
      return await this.socket.send("setLanguage", {
        language,
        timeStamp: Date.now()
      });
    } catch (e) {
      captureOperationalError(e, this.setLanguage);
      throw e;
    }
  }
  async setLocation(latitude, longitude) {
    try {
      if (typeof latitude !== "number" || typeof longitude !== "number") {
        throw new OperationalError(
          `setLocation requires latitude and longitude to be numbers`
        );
      }
      const location = [latitude, longitude];
      this.config.location = location;
      return await this.socket.send("setLocation", {
        location,
        timeStamp: Date.now()
      });
    } catch (e) {
      captureOperationalError(e, this.setLocation);
      throw e;
    }
  }
  async openUrl(url) {
    try {
      return await this.socket.send("openUrl", {
        url,
        timeStamp: Date.now()
      });
    } catch (e) {
      captureOperationalError(e, this.openUrl);
      throw e;
    }
  }
  async launchApp(appId) {
    try {
      return await this.socket.send("launchApp", {
        appId,
        timeStamp: Date.now()
      });
    } catch (e) {
      captureOperationalError(e, this.launchApp);
      throw e;
    }
  }
  async shake() {
    try {
      return await this.socket.send("shakeDevice");
    } catch (e) {
      captureOperationalError(e, this.swipe);
      throw e;
    }
  }
  async toggleSoftKeyboard() {
    try {
      if (this.config.platform !== "ios") {
        throw new Error(
          "toggleSoftKeyboard is only available on iOS devices"
        );
      }
      return await this.socket.send("toggleSoftKeyboard");
    } catch (e) {
      captureOperationalError(e, this.toggleSoftKeyboard);
      throw e;
    }
  }
  async biometry({ match }) {
    try {
      return await this.socket.send(
        match ? "biometryMatch" : "biometryNonMatch"
      );
    } catch (e) {
      captureOperationalError(e, this.biometry);
      throw e;
    }
  }
  async addMedia(file) {
    if (file.size > 50 * 1024 * 1024) {
      throw new Error(
        "Your proposed upload exceeds the maximum allowed size of 50MB"
      );
    }
    try {
      const endpoint = `${this.path}/session/${this.token}/addMedia`;
      const invalidFileNameExpression = /[^\u0000-\u00ff]/g;
      const filename = file.name.replace(invalidFileNameExpression, "-");
      const response = await fetch(endpoint, {
        method: "POST",
        body: file,
        headers: {
          "X-Appetize-File-Name": filename,
          "Content-Type": file.type
        }
      });
      if (!response.ok) {
        const message = await response.text();
        throw new Error(
          `Failed to upload media file. Received ${response.status} - ${message}`
        );
      }
      return response;
    } catch (error) {
      captureOperationalError(error, this.addMedia);
      throw error;
    }
  }
  async biometryEnrollment(isEnrolled) {
    try {
      if (this.config.platform !== "ios") {
        throw new Error(
          "biometryEnrollment is only available on iOS devices"
        );
      }
      return await this.socket.send("biometryEnrollment", { isEnrolled });
    } catch (e) {
      captureOperationalError(e, this.biometryEnrollment);
      throw e;
    }
  }
  async allowInteractions(allow) {
    try {
      return await this.socket.send(
        allow ? "enableInteractions" : "disableInteractions"
      );
    } catch (e) {
      captureOperationalError(e, this.allowInteractions);
      throw e;
    }
  }
  async restartApp() {
    try {
      if (this.isStandalone) {
        this.logger.warn("restartApp has no effect on a Standalone");
      } else {
        this.socket.send("restartApp");
        await this.waitForEvent("appLaunch", { timeout: 6e4 });
      }
    } catch (e) {
      captureOperationalError(e, this.restartApp);
      throw e;
    }
  }
  async reinstallApp() {
    try {
      if (this.isStandalone) {
        this.logger.warn("reinstallApp has no effect on a Standalone");
      } else {
        this.socket.send("reinstallApp");
        await this.waitForEvent("appLaunch", { timeout: 6e4 });
      }
    } catch (e) {
      captureOperationalError(e, this.reinstallApp);
      throw e;
    }
  }
  async adbShellCommand(command) {
    if (this.config.platform !== "android") {
      throw new Error(
        "adbShellCommand is only available on Android devices"
      );
    }
    try {
      return await this.socket.send("adbShellCommand", {
        command,
        timeStamp: Date.now()
      });
    } catch (e) {
      captureOperationalError(e, this.adbShellCommand);
      throw e;
    }
  }
  async playAction(action, options = {}) {
    const { timeout = 1e4 } = options;
    const MAX_APP_RECORDER_TIMEOUT = 1e4;
    const MAX_WAIT_FOR_RESPONSE = timeout + 3e4;
    try {
      if (!this.config.record) {
        throw new RecorderRequiredError("playAction()");
      }
      if (isNaN(timeout)) {
        throw new OperationalError(
          `Invalid timeout value: ${options.timeout}`
        );
      }
      if (timeout < 0) {
        throw new OperationalError(
          `Timeout value cannot be negative: ${options.timeout}`
        );
      }
      if ("element" in action && action.element) {
        DataValidator.isValidElementSelector(action.element);
      }
      const payload = {
        id: uuid(),
        action,
        options: {
          ...options,
          timeout: Math.round(
            Math.min(timeout, MAX_APP_RECORDER_TIMEOUT) / 1e3
          )
        }
      };
      try {
        const result = await new Promise(
          (resolve, reject) => {
            const hardTimeout = setTimeout(() => {
              cleanup();
              reject(
                new ActionTimeoutError(
                  {
                    id: payload.id,
                    action,
                    timeout: payload.options.timeout
                  },
                  `Timed out waiting for response from device`
                )
              );
            }, MAX_WAIT_FOR_RESPONSE);
            const cleanup = () => {
              this.off("playbackFoundAndSent", handleSuccess);
              this.off("playbackError", handleError);
              clearTimeout(hardTimeout);
            };
            const handleSuccess = async (value) => {
              var _a;
              if (((_a = value.playback) == null ? void 0 : _a.id) !== payload.id)
                return;
              cleanup();
              resolve(value);
            };
            const handleError = async (error) => {
              var _a;
              if (((_a = error.playback) == null ? void 0 : _a.id) !== payload.id)
                return;
              cleanup();
              switch (error.errorId) {
                case "internalError":
                  reject(new ActionInternalError(error));
                  break;
                case "notFound": {
                  reject(
                    new ActionElementNotFoundError(error)
                  );
                  break;
                }
                case "ambiguousMatch":
                  reject(
                    new ActionAmbiguousElementError(error)
                  );
                  break;
                case "invalidArgument": {
                  reject(
                    new ActionInvalidArgumentError(error)
                  );
                  break;
                }
                default:
                  reject(new ActionError(error));
                  break;
              }
            };
            this.on("playbackFoundAndSent", handleSuccess);
            this.on("playbackError", handleError);
            this.socket.send("playAction", payload);
          }
        );
        return result;
      } catch (e) {
        const remainingTimeout = Math.max(
          0,
          timeout - MAX_APP_RECORDER_TIMEOUT
        );
        if (remainingTimeout > 0 && !(e instanceof ActionTimeoutError) && !(e instanceof ActionInternalError)) {
          return await this.playAction(action, {
            ...options,
            timeout: remainingTimeout
          });
        }
        throw e;
      }
    } catch (e) {
      captureOperationalError(e, this.playAction);
      throw e;
    }
  }
  async playActions(actions, options = {}) {
    try {
      if (!this.config.record) {
        throw new RecorderRequiredError("playActions()");
      }
      const results = [];
      for (const action of actions) {
        const result = await this.playAction(action, options);
        results.push(result);
        const nextAction = actions[actions.indexOf(action) + 1];
        const isConsecutiveKeypress = nextAction && nextAction.type === "keypress" && action.type === "keypress";
        if (!isConsecutiveKeypress) {
          await this.waitForAnimations({ timeout: 2e3 }).catch(
            () => {
            }
          );
        }
      }
      return results;
    } catch (e) {
      captureOperationalError(e, this.playActions);
      throw e;
    }
  }
  async getUI({
    timeout = 3e4
  } = {}) {
    try {
      this.socket.send("dumpUi");
      const data = await waitForEvent(this, "uiDump", {
        timeout
      });
      return data;
    } catch (e) {
      captureOperationalError(e, this.getUI);
      throw e;
    }
  }
  async findElement(element, options) {
    var _a;
    try {
      const result = await this.playAction(
        {
          type: "findElements",
          element,
          appId: options == null ? void 0 : options.appId
        },
        options
      );
      return (_a = result.matchedElements) == null ? void 0 : _a[0];
    } catch (e) {
      captureOperationalError(e, this.findElement);
      throw e;
    }
  }
  async findElements(element, options) {
    try {
      const result = await this.playAction(
        {
          type: "findElements",
          element,
          appId: options == null ? void 0 : options.appId
        },
        options
      );
      return result.matchedElements;
    } catch (e) {
      captureOperationalError(e, this.findElements);
      throw e;
    }
  }
  async tap(args, options) {
    var _a;
    try {
      if (!this.config.record) {
        throw new RecorderRequiredError("tap()");
      }
      return await this.playAction(
        {
          type: "tap",
          ...args,
          duration: ((_a = args.duration) != null ? _a : 0) / 1e3
        },
        options
      );
    } catch (e) {
      captureOperationalError(e, this.tap);
      throw e;
    }
  }
  async swipe({ duration, gesture, ...args }, options) {
    try {
      if (!this.config.record) {
        throw new RecorderRequiredError("swipe()");
      }
      let action;
      const g = new SwipeGesture({
        duration,
        stepDuration: args.stepDuration
      });
      if (typeof gesture === "function") {
        gesture(g);
      } else {
        switch (gesture) {
          case "up":
            g.up();
            break;
          case "down":
            g.down();
            break;
          case "left":
            g.left();
            break;
          case "right":
            g.right();
            break;
        }
      }
      if ("element" in args) {
        action = {
          type: "swipe",
          element: args.element,
          localPosition: args.localPosition,
          moves: g.build()
        };
      } else if ("position" in args) {
        action = {
          type: "swipe",
          position: args.position,
          moves: g.build()
        };
      } else {
        throw new Error("Either element or position must be specified");
      }
      return this.playAction(action, options);
    } catch (e) {
      captureOperationalError(e, this.swipe);
      throw e;
    }
  }
  async waitForAnimations(options = {}) {
    try {
      const { imageThreshold = 1e-3, timeout = 1e4 } = options;
      let imageThresholdDuration = 1e3;
      let lowestImageThreshold = 1;
      if (options.imageThresholdDuration) {
        imageThresholdDuration = options.imageThresholdDuration;
      }
      const { promise, resolve, reject } = createDeferredPromise();
      const timeoutId = setTimeout(() => {
        let msg = `Timed out after ${timeout}ms waiting for animation to end.`;
        if (imageThreshold < lowestImageThreshold) {
          msg += ` Waited for imageThreshold of ${imageThreshold} but lowest was ${Math.round(lowestImageThreshold * 1e4) / 1e4}`;
        }
        reject(new TimeoutError(msg));
      }, timeout);
      let lastTimeUnderThreshold;
      const handlePixelsChanged = ({
        percentage,
        timestamp
      }) => {
        if (percentage < lowestImageThreshold) {
          lowestImageThreshold = percentage;
        }
        if (percentage <= imageThreshold) {
          if (!lastTimeUnderThreshold) {
            lastTimeUnderThreshold = timestamp;
          }
          if (lastTimeUnderThreshold && timestamp - lastTimeUnderThreshold >= imageThresholdDuration) {
            resolve();
          }
        } else {
          lastTimeUnderThreshold = void 0;
        }
      };
      this.socket.send("enablePixelChangeDetection");
      this.socket.on("pixelsChanged", handlePixelsChanged);
      this._waitForAnimationsPromises.add(promise);
      return await promise.finally(() => {
        clearTimeout(timeoutId);
        this.socket.off("pixelsChanged", handlePixelsChanged);
        this._waitForAnimationsPromises.delete(promise);
        if (this._waitForAnimationsPromises.size === 0) {
          this.socket.send("disablePixelChangeDetection");
        }
      });
    } catch (e) {
      captureOperationalError(e, this.waitForAnimations);
      throw e;
    }
  }
  async getAdbInfo() {
    this.logger.warn(
      `getAdbInfo() is deprecated. Please use the \`adbConnection\` property instead.`
    );
    return Promise.resolve(__privateGet(this, _adbConnection));
  }
  async getNetworkInspectorUrl() {
    this.logger.warn(
      `getNetworkInspectorUrl() is deprecated. Please use the \`networkInspectorUrl\` property instead.`
    );
    return Promise.resolve(__privateGet(this, _networkInspectorUrl));
  }
  async getDeviceInfo() {
    this.logger.warn(
      `getDeviceInfo() is deprecated. Please use the \`device\` property instead.`
    );
    return Promise.resolve(this.device);
  }
  get isStandalone() {
    var _a;
    if ((_a = this.app) == null ? void 0 : _a.buildId) {
      return this.app.buildId.startsWith("standalone_");
    }
    return false;
  }
}
_adbConnection = new WeakMap();
_networkInspectorUrl = new WeakMap();
function getAdbShellCommand(connectionInfo) {
  const template = "ssh -fN -o StrictHostKeyChecking=no -oHostKeyAlgorithms=+ssh-rsa -p SERVER_PORT USERNAME@HOSTNAME -L6000:FORWARD_DESTINATION:FORWARD_PORT && adb connect localhost:6000";
  if (!connectionInfo || !connectionInfo.forwards[0]) {
    return void 0;
  }
  let returnValue = template;
  returnValue = returnValue.replace(
    /SERVER_PORT/,
    connectionInfo.port.toString()
  );
  returnValue = returnValue.replace(/USERNAME/, connectionInfo.user);
  returnValue = returnValue.replace(/HOSTNAME/, connectionInfo.hostname);
  returnValue = returnValue.replace(
    /FORWARD_DESTINATION/,
    connectionInfo.forwards[0].destination
  );
  returnValue = returnValue.replace(
    /FORWARD_PORT/,
    connectionInfo.forwards[0].port.toString()
  );
  return returnValue;
}
async function pause(page) {
  await page.pause();
}
function getKeyFromKeypress(keypress) {
  if (keypress.character) {
    return keypress.character;
  }
  const key = keypress.key;
  if (isSpecialKey(key)) {
    return key;
  }
  return keypress.shiftKey ? key.toUpperCase() : key.toLowerCase();
}
function isSpecialKey(key) {
  const pattern = /^[\b\t\r]/;
  return pattern.test(key);
}
class Codegen {
  constructor({
    testInfo,
    session
  }) {
    this.currentRecord = 0;
    this.session = session;
    this.testInfo = testInfo;
  }
  async record() {
    const file = this.testInfo.file;
    const contents = await fs.promises.readFile(file, "utf8");
    const recordStatements = contents.split("\n").map((line, num) => ({ line, num: num + 1 })).slice(this.testInfo.line).filter(({ line }) => line.includes("session.record()"));
    const currentLine = recordStatements[this.currentRecord].num;
    if (currentLine !== void 0) {
      console.log(`\u{1F534} Recording at line ${currentLine}`);
      const actions = [];
      const handleAction = (action) => {
        concatActions(actions, action);
        console.log(describeAction(action));
      };
      this.session.on("action", handleAction);
      await pause(this.session.page);
      await waitForTimeout(2e3);
      this.session.off("action", handleAction);
      const newContents = contents.split("\n").map((line, index) => {
        var _a, _b;
        if (index === currentLine - 1) {
          const tabs = (_b = (_a = line.match(/^\s*/)) == null ? void 0 : _a[0]) != null ? _b : 0;
          const descriptions = actions.map((action) => {
            return describeAction(action);
          }).reduce(
            (acc, cur, i) => `${acc}
// ${i + 1}. ${cur}`,
            "// Recorded using session.record()"
          );
          return `${descriptions}
await session.playActions(${JSON.stringify(
            actions,
            null,
            "	"
          )})`.split("\n").map((line2) => tabs + line2).join("\n");
        }
        return line;
      });
      await fs.promises.writeFile(file, newContents.join("\n"));
      console.log(`\u{1F7E2} Finished`);
      this.currentRecord += 1;
    }
  }
}
function concatActions(actions, action) {
  const lastAction = actions[actions.length - 1];
  if (lastAction) {
    switch (action.type) {
      case "keypress": {
        if ((lastAction == null ? void 0 : lastAction.type) === "keypress" && !isSpecialKey(action.key) && !isSpecialKey(lastAction.key)) {
          actions.pop();
          actions.push({
            type: "typeText",
            text: getKeyFromKeypress(lastAction) + getKeyFromKeypress(action)
          });
        } else if ((lastAction == null ? void 0 : lastAction.type) === "typeText" && !isSpecialKey(action.key)) {
          actions.pop();
          actions.push({
            type: "typeText",
            text: lastAction.text + getKeyFromKeypress(action)
          });
        } else {
          actions.push(action);
        }
        break;
      }
      default:
        actions.push(action);
    }
  } else {
    actions.push(action);
  }
}
function describeAction(action) {
  var _a, _b, _c, _d, _e, _f;
  let on = "";
  switch (action.type) {
    case "swipe":
    case "tap": {
      const element = action.element;
      if (typeof element === "string") {
        on = ` on element "${element}"`;
      } else {
        if ((_a = element == null ? void 0 : element.attributes) == null ? void 0 : _a.accessibilityIdentifier) {
          on = `element with accessibilityIdentifier "${(_b = element.attributes) == null ? void 0 : _b.accessibilityIdentifier}"`;
        } else if ((_c = element == null ? void 0 : element.attributes) == null ? void 0 : _c.class) {
          on = `element with class "${(_d = element.attributes) == null ? void 0 : _d.class}"`;
        } else if ("position" in action && ((_e = action.position) == null ? void 0 : _e.x) && ((_f = action.position) == null ? void 0 : _f.y)) {
          on = `position ${Math.round(
            action.position.x * 100
          )}%, ${Math.round(action.position.y * 100)}%`;
        }
      }
      if (on) {
        return `${action.type} on ${on}`;
      } else {
        return action.type;
      }
    }
    case "keypress":
      return `type "${getKeyFromKeypress(action)}"`;
    case "typeText":
      return `type "${action.text}"`;
  }
}
const version = "1.5.0";
const VERSION = version;
class AppetizeWindow extends EventEmitter {
  constructor({
    page,
    testFixture
  }) {
    super();
    this.ready = false;
    this.page = page;
    this.testFixture = testFixture;
  }
  async init() {
    this.ready = false;
    await this.testFixture.step("Connect to Appetize page", async () => {
      await this.page.exposeFunction("__appetize_on", (json) => {
        const data = JSON.parse(json, function(key, value2) {
          try {
            if ("flag" in value2 && value2.flag === "TYPED_ARRAY") {
              return global[value2.constructor].from(
                value2.data.split(",").map(Number)
              );
            }
          } catch (e) {
          }
          return value2;
        });
        const type = data === "string" ? data : data.type;
        const value = data.value;
        this.emit(type, value);
        this.emit("*", { type, value });
      });
      await this.page.evaluate(
        async ([VERSION2]) => {
          return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              clearInterval(interval);
              reject(
                new TimeoutError(
                  `Timed out after 60000ms waiting for connection to Appetize page`
                )
              );
            }, 6e4);
            const interval = setInterval(() => {
              const channel = new MessageChannel();
              channel.port1.onmessage = () => {
                clearInterval(interval);
                clearTimeout(timeout);
                channel.port1.close();
                channel.port2.close();
                resolve(false);
              };
              window.postMessage(
                {
                  type: "init",
                  appetizeClient: true,
                  version: VERSION2
                },
                "*",
                [channel.port2]
              );
              window.__appetize_postMessage = async (data, waitForResponse = false) => {
                const channel2 = new MessageChannel();
                window.postMessage(data, "*", [channel2.port2]);
                if (waitForResponse) {
                  return new Promise((resolve2, reject2) => {
                    const tm = setTimeout(() => {
                      reject2(
                        new TimeoutError(
                          "Timed out after 60000ms while waiting for postMessage response"
                        )
                      );
                    }, 6e4);
                    channel2.port1.onmessage = (ev) => {
                      clearTimeout(tm);
                      channel2.port1.close();
                      channel2.port2.close();
                      resolve2(ev.data);
                    };
                  });
                } else {
                  channel2.port1.close();
                  channel2.port2.close();
                }
              };
            }, 100);
          });
        },
        [VERSION]
      );
      await this.page.evaluate(() => {
        window.addEventListener("message", (event) => {
          var _a;
          if (event.source === window) {
            const eventType = typeof event.data === "string" ? event.data : (_a = event.data) == null ? void 0 : _a.type;
            switch (eventType) {
              case "frameData":
              case "recordedAction":
              case "playbackFoundAndSent":
              case "playbackNotFound":
              case "debug":
              case "interceptRequest":
              case "interceptResponse":
              case "interceptError":
              case "uiDump":
                return;
            }
            window.__appetize_on(
              JSON.stringify(event.data, function(key, value) {
                if (value instanceof Int8Array || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int16Array || value instanceof Uint16Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Float32Array || value instanceof Float64Array) {
                  const replacement = {
                    constructor: value.constructor.name,
                    data: value.join(","),
                    flag: "TYPED_ARRAY"
                  };
                  return replacement;
                }
                return value;
              })
            );
          }
        });
      }, []);
    });
    this.ready = true;
  }
  async waitUntilReady() {
    return waitFor(async () => {
      if (!this.ready) {
        throw new TimeoutError(
          `Timed out after 60000ms while waiting for Appetize window to be ready.`
        );
      }
    }, 6e4);
  }
  async postMessage(data, waitForResponse = false) {
    await this.waitUntilReady();
    try {
      return await this.testFixture.step(
        "postMessage",
        async () => this.page.evaluate(
          async ([data2, waitForResponse2]) => {
            return window.__appetize_postMessage(
              data2,
              waitForResponse2
            );
          },
          [data, waitForResponse]
        )
      );
    } catch (e) {
      logger.error("Error sending postMessage: ", data);
      throw e;
    }
  }
}
class PlaywrightSocket extends EventEmitter {
  constructor({
    page,
    type,
    window: window2
  }) {
    super();
    this.page = page;
    this.type = type;
    this.window = window2;
    this.window.on("*", ({ type: type2, value }) => {
      switch (type2) {
        case "socketEvent":
          if (value.socket === this.type) {
            const socketEventType = value.type;
            const socketEventValue = value.value;
            this.emit(socketEventType, socketEventValue);
            this.emit("*", {
              type: socketEventType,
              value: socketEventValue
            });
          }
          break;
        case "disconnect":
          this.emit("disconnect");
          this.emit("*", { type: "disconnect" });
          break;
        case "sessionInfo":
        case "chromeDevToolsUrl":
        case "orientationChanged":
        case "deviceInfo":
          if (this.type === "appetizer") {
            this.emit(type2, value);
            this.emit("*", { type: type2, value });
          }
          break;
        case "sessionRequested":
          if (this.type === "webserver") {
            this.emit(type2, value);
            this.emit("*", { type: type2, value });
          }
          break;
      }
    });
  }
  async send(event, data) {
    return this.window.postMessage({
      type: "emitSocketEvent",
      value: { type: event, value: data, socket: this.type }
    });
  }
  async disconnect() {
    await this.send("disconnect");
  }
  waitForEvent(event, options) {
    return waitForEvent(this, event, options);
  }
}
class PlaywrightSession extends Session {
  constructor({
    page,
    config,
    window: window2,
    testFixture,
    ...args
  }) {
    const socket = new PlaywrightSocket({
      page,
      window: window2,
      type: "appetizer"
    });
    super({ ...args, socket, config, logger });
    this.actionLogs = [];
    this.window = window2;
    this.page = page;
    this.config = config;
    this.testFixture = testFixture;
    this.page.on("load", () => {
      this.emit("disconnect");
    });
    this.adbShellCommand = this.wrapAsStep(this.adbShellCommand);
    this.biometry = this.wrapAsStep(this.biometry);
    this.findElement = this.wrapAsStep(this.findElement, {
      subStepTitle: (selector) => JSON.stringify(selector)
    });
    this.findElements = this.wrapAsStep(this.findElements, {
      subStepTitle: (selector) => JSON.stringify(selector)
    });
    this.getUI = this.wrapAsStep(this.getUI);
    this.keypress = this.wrapAsStep(this.keypress, {
      subStepTitle: (key) => JSON.stringify(key)
    });
    this.launchApp = this.wrapAsStep(this.launchApp, {
      subStepTitle: (app) => JSON.stringify(app)
    });
    this.openUrl = this.wrapAsStep(this.openUrl, {
      subStepTitle: (url) => JSON.stringify(url)
    });
    this.playAction = this.wrapAsStep(this.playAction, {
      subStepTitle: (action) => JSON.stringify(action)
    });
    this.playActions = this.wrapAsStep(this.playActions, {
      subStepTitle: (actions) => JSON.stringify(actions)
    });
    this.reinstallApp = this.wrapAsStep(this.reinstallApp);
    this.restartApp = this.wrapAsStep(this.restartApp);
    this.rotate = this.wrapAsStep(this.rotate, {
      subStepTitle: (direction) => JSON.stringify(direction)
    });
    this.screenshot = this.wrapAsStep(this.screenshot);
    this.setLanguage = this.wrapAsStep(this.setLanguage, {
      subStepTitle: (language) => JSON.stringify(language)
    });
    this.setLocation = this.wrapAsStep(this.setLocation, {
      subStepTitle: (location) => JSON.stringify(location)
    });
    this.shake = this.wrapAsStep(this.shake);
    this.swipe = this.wrapAsStep(this.swipe, {
      subStepTitle: (args2) => JSON.stringify(args2)
    });
    this.tap = this.wrapAsStep(this.tap, {
      subStepTitle: (args2) => JSON.stringify(args2)
    });
    this.type = this.wrapAsStep(this.type, {
      subStepTitle: (text) => JSON.stringify(text)
    });
    this.waitForAnimations = this.wrapAsStep(this.waitForAnimations);
    this.waitForElement = this.wrapAsStep(this.waitForElement, {
      subStepTitle: (selector) => JSON.stringify(selector)
    });
    this.waitForEvent = this.wrapAsStep(this.waitForEvent, {
      title: (event) => `session.waitForEvent - ${JSON.stringify(event)}`
    });
    this.waitForTimeout = this.wrapAsStep(this.waitForTimeout, {
      title: (ms) => `session.waitForTimeout - ${JSON.stringify(ms)}`
    });
  }
  async addActionLog(log) {
    if (log.error) {
      const ui = await this.getUI().catch(this.logger.warn);
      if (ui) {
        log.ui = ui;
      }
    }
    this.actionLogs.push(log);
  }
  async rotate(direction) {
    try {
      const [orientation] = await Promise.all([
        waitForEvent(
          this.window,
          "orientationChanged"
        ),
        await this.window.postMessage(
          direction === "left" ? "rotateLeft" : "rotateRight"
        )
      ]);
      this.window.page.waitForTimeout(1e3);
      return orientation;
    } catch (e) {
      captureOperationalError(e, this.rotate);
      throw e;
    }
  }
  async record() {
    try {
      if (!this.config.record) {
        throw new OperationalError(
          "Recording is not enabled, please enable it by setting `record: true` in session config"
        );
      }
      if (!this.testFixture) {
        throw new OperationalError(
          "session.record() requires using `session` from the test() arguments"
        );
      }
      const codegen = new Codegen({
        session: this,
        testInfo: this.testFixture.info()
      });
      return codegen.record();
    } catch (e) {
      captureOperationalError(e, this.record);
      throw e;
    }
  }
  async waitForEvent(event, options) {
    try {
      return await waitForEvent(this, event, options);
    } catch (e) {
      captureOperationalError(e, this.waitForEvent);
      throw e;
    }
  }
  async waitForTimeout(ms) {
    try {
      return await waitForTimeout(ms);
    } catch (e) {
      captureOperationalError(e, this.waitForTimeout);
      throw e;
    }
  }
  async waitForElement(element, options) {
    try {
      const elements = await this.findElements(element, options);
      if (elements.length) {
        if ((options == null ? void 0 : options.matches) && elements.length !== options.matches) {
          throw new Error(
            `Expected ${options.matches} elements, found ${elements.length}`
          );
        }
        return elements;
      } else {
        throw new Error(
          `Element not found:
${JSON.stringify(element)}`
        );
      }
    } catch (e) {
      captureOperationalError(e, this.waitForElement);
      throw e;
    }
  }
  on(event, listener) {
    return super.on(event, listener);
  }
  once(event, listener) {
    return super.once(event, listener);
  }
  async getVideoFrames() {
    console.warn(
      `getVideoFrames() is deprecated. Use session.on('video') event instead`
    );
    return [];
  }
  async getAudioFrames() {
    console.warn(
      `getAudioFrames() is deprecated. Use session.on('audio') event instead`
    );
    return [];
  }
  wrapAsStep(fn, options = {}) {
    return (...args) => {
      var _a;
      let title = `session.${fn.name}`;
      if (options == null ? void 0 : options.title) {
        title = options.title(...args);
      }
      const subStepTitle = (_a = options == null ? void 0 : options.subStepTitle) == null ? void 0 : _a.call(options, ...args);
      if (subStepTitle) {
        return this.testFixture.step(
          title,
          () => this.testFixture.step(
            subStepTitle,
            () => fn.apply(this, args)
          ),
          { box: true }
        );
      } else {
        return this.testFixture.step(
          title,
          () => fn.apply(this, args),
          { box: true }
        );
      }
    };
  }
}
const windows = /* @__PURE__ */ new WeakMap();
class PlaywrightClient extends HeadfulClient {
  constructor({
    page,
    testFixture
  }) {
    var _a;
    const window2 = (_a = windows.get(page)) != null ? _a : new AppetizeWindow({ page, testFixture });
    windows.set(page, window2);
    const socket = new PlaywrightSocket({
      type: "webserver",
      page,
      window: window2
    });
    super({ socket, window: window2, logger, autoInit: false });
    this.window = window2;
    this.page = page;
    this.testFixture = testFixture;
    let isInQueue = false;
    this.on("queue", (queue) => {
      if (!isInQueue) {
        isInQueue = true;
        if (queue.type === "concurrent") {
          this.logger.log(
            `Entered ${queue.name}. Please wait until a slot becomes available.`
          );
        } else {
          this.logger.log(
            `All devices are currently in use. Please wait until requested device becomes available.`
          );
        }
      }
      if (queue.position > 0) {
        if (queue.type === "concurrent") {
          this.logger.log(
            `Position in ${queue.name}: ${queue.position}`
          );
        } else {
          this.logger.log(`Position in queue: ${queue.position}`);
        }
      }
    });
    this.on("session", () => {
      if (isInQueue) {
        isInQueue = false;
      }
    });
  }
  async init() {
    return this.testFixture.step("Initialize client", async () => {
      await this.window.init();
      await super.init();
    });
  }
  validateConfig(config) {
    var _a;
    const browserType = (_a = this.page.context().browser()) == null ? void 0 : _a.browserType().name();
    return {
      codec: browserType === "chromium" ? "jpeg" : "h264",
      ...config
    };
  }
  createSession(config, sessionInfo) {
    this.session = new PlaywrightSession({
      config,
      page: this.page,
      window: this.window,
      path: sessionInfo.path,
      token: sessionInfo.token,
      device: this.device,
      app: this.app,
      testFixture: this.testFixture
    });
    return this.session;
  }
}
class AppetizePage {
  constructor(args) {
    var _a;
    this.queueStart = null;
    this.queueEnd = null;
    this.baseURL = "https://appetize.io";
    this.sessionDebugInfo = {
      playedActions: [],
      videoFrames: [],
      audioFrames: [],
      debugLogs: []
    };
    this.page = args.page;
    this.testFixture = args.testFixture;
    this.config = {
      ...args.config,
      buildId: (_a = args.config.buildId) != null ? _a : args.config.publicKey,
      ...args.config.publicKey ? { publicKey: args.config.publicKey } : {}
    };
    if (args.baseURL) {
      this.baseURL = args.baseURL;
    }
  }
  get queueTime() {
    var _a;
    if (this.queueStart) {
      return ((_a = this.queueEnd) != null ? _a : Date.now()) - this.queueStart;
    }
    return null;
  }
  async init() {
    var _a;
    const params = {};
    for (const key in this.config) {
      switch (key) {
        case "device":
        case "osVersion":
        case "scale":
        case "orientation":
          params[key] = this.config[key];
          break;
      }
    }
    const pageRes = await this.page.goto(
      `${this.baseURL}/embed/${this.config.buildId}?${queryString(
        params
      )}`
    );
    if ((pageRes == null ? void 0 : pageRes.status()) === 404) {
      const label = this.config.publicKey ? "publicKey" : "buildId";
      throw new Error(
        `App not found for ${label} "${(_a = this.config.publicKey) != null ? _a : this.config.buildId}"`
      );
    }
    this.client = new PlaywrightClient({
      page: this.page,
      testFixture: this.testFixture
    });
    await this.client.init();
  }
  async start(args) {
    this.queueStart = null;
    this.queueEnd = null;
    this.client.on("queue", () => {
      if (!this.queueStart) {
        this.queueStart = Date.now();
      }
    });
    this.client.on("queueEnd", () => {
      if (this.queueStart) {
        this.queueEnd = Date.now();
      }
    });
    const resizeToDevice = async (info) => {
      if (info == null ? void 0 : info.embed) {
        await this.page.setViewportSize({
          width: info.embed.width + 8,
          height: info.embed.height + 8
        });
      }
    };
    this.client.on("deviceInfo", resizeToDevice);
    await this.client.waitUntilReady();
    if (this.client.device) {
      resizeToDevice(this.client.device);
    }
    const session = await retry(
      () => this.client.startSession(args.config),
      {
        retries: 5,
        timeout: 3e4,
        predicate: (e, attempt) => {
          if (e instanceof Error && e.message.match(/too many requests/)) {
            console.warn(
              `Too many session requests. Retrying in 30 seconds... (attempt #${attempt})`
            );
            return true;
          }
          return false;
        }
      }
    );
    this.config = session.config;
    this.requestKeyFrame();
    if (session.config.debug === true) {
      session.on("log", (value) => {
        this.sessionDebugInfo.debugLogs.push(value.message);
      });
    }
    session.on("playbackFoundAndSent", (value) => {
      this.sessionDebugInfo.playedActions.push(value);
    });
    session.on("playbackError", (value) => {
      this.sessionDebugInfo.playedActions.push(value);
    });
    session.on("video", (frame) => {
      this.sessionDebugInfo.videoFrames.push(frame);
    });
    session.on("audio", (frame) => {
      this.sessionDebugInfo.audioFrames.push(frame);
    });
    session.on("end", () => {
      this.session = void 0;
    });
    this.session = session;
    return session;
  }
  onTestStart() {
    this.clearSessionDebugInfo();
    this.requestKeyFrame();
  }
  clearSessionDebugInfo() {
    this.sessionDebugInfo.playedActions = [];
    this.sessionDebugInfo.videoFrames = [];
    this.sessionDebugInfo.audioFrames = [];
    this.sessionDebugInfo.debugLogs = [];
  }
  requestKeyFrame() {
    if (this.session) {
      this.testFixture.step("", async () => {
        var _a;
        return (_a = this.session) == null ? void 0 : _a.socket.send("requestKeyFrame").catch(() => {
        });
      });
    }
  }
}
const execAsync = promisify(exec);
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
async function createAndroidDeviceBrowserPage(session, testInfo) {
  const adbInfo = session.adbConnection;
  const host = "localhost";
  const port = 6e3;
  if (!adbInfo) {
    throw new Error(
      "ADB connection info not found. Session must be configured with `enableAdb: true`"
    );
  }
  await checkAdbInstalled();
  try {
    await execAsync(`adb disconnect ${host}:${port}`);
  } catch (e) {
  }
  const sshCmd = `ssh -fN -o StrictHostKeyChecking=no -oHostKeyAlgorithms=+ssh-rsa -p ${adbInfo.port} ${adbInfo.user}@${adbInfo.hostname} -L${port}:${adbInfo.forwards[0].destination}:${adbInfo.forwards[0].port}`;
  const sshOutput = await execAsync(sshCmd);
  if (sshOutput.stdout) {
    logger.error(sshOutput.stdout);
  }
  if (sshOutput.stderr) {
    logger.error(sshOutput.stderr);
  }
  const adbCmd = `adb connect ${host}:${port}`;
  const adbOutput = await execAsync(adbCmd);
  if (adbOutput.stdout) {
    logger.error(adbOutput.stdout);
  }
  if (adbOutput.stderr) {
    logger.error(adbOutput.stderr);
  }
  const device = await _android.devices().then(
    (devices) => devices.find((device2) => device2.serial() === `${host}:${port}`)
  );
  if (!device) {
    throw new Error(`Device ${host}:${port} not found`);
  }
  logger.debug(
    `Connected to device ${device.model()} with serial ${device.serial()}`
  );
  const flags = await getExistingChromeCommandLineFlags(testInfo);
  const browserContext = await device.launchBrowser({
    args: flags
  });
  await pushChromeCommandLine(testInfo, `chrome ${flags.join(" ")}`);
  const pages = browserContext.pages();
  if (pages[0]) {
    return {
      page: pages[0],
      browserContext,
      device
    };
  }
  const page = await browserContext.newPage();
  return { page, browserContext, device };
}
async function disconnectAndroidDevice(device) {
  await device.close();
  await execAsync(`adb disconnect ${device.serial()}`);
}
async function getExistingChromeCommandLineFlags(testInfo) {
  const testOutputDir = testInfo.outputPath();
  const pulledPath = testInfo.outputPath("chrome-command-line");
  const chromeCommandLinePath = "/data/local/tmp/chrome-command-line";
  let flags = [];
  try {
    await execAsync(`adb pull ${chromeCommandLinePath} ${testOutputDir}`);
    const file = await readFileAsync(pulledPath, "utf-8");
    if (file) {
      const flagsString = file.split("chrome ").at(1);
      if (flagsString) {
        flags = flagsString.split(" ") || [];
      }
    }
    await execAsync(`adb push ${pulledPath} ${chromeCommandLinePath}`);
  } catch (e) {
  }
  return flags;
}
async function pushChromeCommandLine(testInfo, content) {
  const pulledPath = testInfo.outputPath("chrome-command-line");
  const chromeCommandLinePath = "/data/local/tmp/chrome-command-line";
  try {
    await writeFileAsync(pulledPath, content);
    await execAsync(`adb push ${pulledPath} ${chromeCommandLinePath}`);
  } catch (e) {
    logger.error("Error pushing chrome-command-line file", e);
  }
}
async function checkAdbInstalled() {
  try {
    await execAsync("adb version");
  } catch (e) {
    throw new Error(
      "ADB is not installed or not found in PATH. Please install ADB and ensure it is accessible."
    );
  }
}
let appetizePage = null;
let lastConfig = null;
const _test = test$1.extend({
  config: [
    async ({ _useConfig }, use, testInfo) => {
      const config = {
        ...testInfo.project.use.config,
        ..._useConfig,
        autoplay: false
      };
      if ("publicKey" in config && !!config.publicKey) {
        if ("buildId" in config && !!config.buildId) {
          logger.warn(
            `Both "buildId" ("${config.buildId}") and "publicKey" ("${config.publicKey}") were defined in the test config. Using buildId.`
          );
          config.publicKey = config.buildId;
        } else {
          config.buildId = config.publicKey;
        }
      }
      await use(config);
    },
    { auto: true }
  ],
  async page({ context, config, baseURL }, use, testInfo) {
    if (isAppetize(testInfo)) {
      appetizePage != null ? appetizePage : appetizePage = await setupAppetizePage(context, config, baseURL);
      const session = await setupSession(appetizePage, config);
      if (session.config.platform !== "android") {
        throw new Error(
          "Appetize browser tests are currently only supported on Android devices."
        );
      }
      const { page, browserContext, device } = await createAndroidDeviceBrowserPage(session, testInfo);
      try {
        await use(page);
        await browserContext.close();
      } finally {
        await disconnectAndroidDevice(device);
      }
      return;
    }
    const newPage = await context.newPage();
    await use(newPage);
  },
  async appetizePage({ context, config, baseURL }, use, testInfo) {
    if (!isAppetize(testInfo)) {
      throw new Error(
        "Appetize config not found in test. Either define it in the Playwright project or with test.use({ config: { ... } })"
      );
    }
    if (appetizePage) {
      const { session, page } = appetizePage;
      if (session) {
        let shouldClose = false;
        if (lastConfig) {
          for (const key in config) {
            if (JSON.stringify(lastConfig[key]) !== JSON.stringify(config[key])) {
              shouldClose = true;
              break;
            }
          }
        } else {
          shouldClose = true;
        }
        if (shouldClose) {
          if (session) {
            await session.end().catch(() => {
            });
          }
          await page.close();
          appetizePage = null;
        }
      }
    }
    if (!appetizePage) {
      appetizePage = await setupAppetizePage(context, config, baseURL);
    }
    lastConfig = config;
    await use(appetizePage);
  },
  async session({ appetizePage: appetizePage2, config, _doSetupAndTeardown }, use) {
    const session = await setupSession(appetizePage2, config);
    await use(session);
  },
  async client({ appetizePage: appetizePage2 }, use) {
    await use(appetizePage2.client);
  },
  _useConfig: [{}, { option: true }],
  _autoSnapshotSuffix: [
    async ({}, use, testInfo) => {
      testInfo.snapshotSuffix = "";
      await use();
    },
    { auto: true }
  ],
  _doSetupAndTeardown: [
    async ({ appetizePage: appetizePage2 }, use, testInfo) => {
      logger.clearLogHistory();
      if (appetizePage2) {
        appetizePage2.onTestStart();
      }
      await use();
      try {
        await saveAttachmentsOnFail({ appetizePage: appetizePage2, testInfo });
      } catch (e) {
        logger.error(`Failed to save attachments`, e);
      }
      if (testInfo.status === "timedOut") {
        if (appetizePage2.queueTime) {
          logger.error(
            `Test timed out while in queue for a device. You may increase your test timeout to account for higher queue times.`
          );
        }
      }
      try {
        removeHiddenSteps(testInfo);
      } catch (e) {
      }
    },
    { auto: false }
  ],
  context: [
    async ({ _browserContext, video, contextOptions }, use) => {
      if (video && video !== "off") {
        logger.warn.once(
          `Video recording is not yet supported with @appetize/playwright. Use tracing instead to view recordings of your tests https://docs.appetize.io/javascript-sdk/playwright/trace-viewer`
        );
      }
      if (Object.keys(contextOptions).length) {
        logger.warn.once(
          `contextOptions are not supported with @appetize/playwright`
        );
      }
      await use(_browserContext);
    },
    {
      scope: "test"
    }
  ],
  _browserContext: [
    async ({ browser }, use) => {
      const context = await browser.newContext();
      await use(context);
      await context.close();
    },
    {
      scope: "worker"
    }
  ]
});
const makeUse = (test2) => {
  const use = test2.use;
  return (options) => {
    const { config, ...rest } = options;
    return use({
      ...rest,
      _useConfig: config
    });
  };
};
const makeAfterEach = (test2) => {
  const afterEach = test2.afterEach;
  return (fn) => {
    afterEach(async ({ appetizePage: appetizePage2 }, testInfo) => {
      if (appetizePage2) {
        try {
          await saveAttachmentsOnFail({ appetizePage: appetizePage2, testInfo });
        } catch (e) {
          logger.error(`Failed to save attachments`, e);
        }
      }
    });
    return afterEach(fn);
  };
};
const makeExtend = (test2) => {
  const extend = test2.extend;
  return (options) => {
    const extended = extend(options);
    extended.afterEach = makeAfterEach(extended).bind(extended);
    extended.use = makeUse(extended).bind(extended);
    extended.extend = makeExtend(extended).bind(extended);
    return extended;
  };
};
Object.assign(_test, {
  use: makeUse(_test),
  afterEach: makeAfterEach(_test),
  extend: makeExtend(_test),
  setup(options) {
    if (!{}.__APPETIZE__SETUP_WARNED) {
      logger.warn(
        `test.setup() is deprecated and will be removed in a future release. Use test.use({ config: {...} }) instead`
      );
    }
    return test.use({ config: options });
  }
});
const test = _test;
const outputCache = /* @__PURE__ */ new WeakMap();
async function saveAttachmentsOnFail(args) {
  const { appetizePage: appetizePage2, testInfo } = args;
  const session = appetizePage2.session;
  const shouldSaveOutput = testInfo.status === "failed" || testInfo.status === "timedOut" || testInfo.status === "interrupted";
  if (!shouldSaveOutput)
    return;
  if (outputCache.get(testInfo.fn))
    return;
  outputCache.set(testInfo.fn, true);
  const tmpDir = path.join(
    os.tmpdir(),
    `appetize-playwright-${testInfo.testId}-${testInfo.workerIndex}`
  );
  const removeTmpDir = async () => {
    if (fs.existsSync(tmpDir)) {
      await fs.promises.rm(tmpDir, {
        recursive: true,
        force: true
      }).catch(() => {
      });
    }
  };
  try {
    await removeTmpDir();
    await fs.promises.mkdir(tmpDir);
    const actionLogs = appetizePage2.sessionDebugInfo.playedActions;
    const saveScreenshot = async () => {
      try {
        if (session) {
          const screenshot = await session.screenshot("buffer");
          const screenshotPath = path.join(tmpDir, "screenshot.png");
          await fs.promises.writeFile(
            screenshotPath,
            Buffer.from(screenshot.data)
          );
          await testInfo.attach("screenshot", {
            path: screenshotPath,
            contentType: "image/png"
          });
        }
      } catch (e) {
        logger.error(
          `Failed to attach screenshot.png`,
          e instanceof Error ? e.message : void 0
        );
      }
    };
    const saveActions = async () => {
      try {
        const actions = actionLogs.map((log) => {
          if ("screenshot" in log) {
            const { screenshot, ...r } = log;
            return r;
          }
          return log;
        });
        if (!actions.length) {
          return;
        }
        const content = JSON.stringify(actions, null, 2);
        const actionsPath = path.join(tmpDir, "actions.json");
        await fs.promises.writeFile(actionsPath, content);
        await testInfo.attach("actions", {
          path: actionsPath,
          contentType: "application/json"
        });
      } catch (e) {
        logger.error(
          `Failed to attach actions.json`,
          e instanceof Error ? e.message : void 0
        );
      }
    };
    const saveH264Video = async () => {
      try {
        const { videoFrames } = appetizePage2.sessionDebugInfo;
        if (videoFrames.length === 0 || videoFrames.some((f) => f.codec !== "h264")) {
          return;
        }
        const mode = "video";
        const jmuxer = new JMuxer(
          {
            mode,
            fps: 15
          }
        );
        const mp4 = await new Promise((res, rej) => {
          const tm = setTimeout(() => {
            rej(new Error("Timed out muxing session video"));
          }, 3e4);
          const reader = new Readable({
            objectMode: true,
            read() {
            }
          });
          const video = Buffer.concat(
            videoFrames.map((frame) => Buffer.from(frame.buffer))
          );
          reader.push({ video });
          reader.push(null);
          let mp42 = Buffer.from([]);
          reader.pipe(jmuxer.createStream()).on("data", (d) => {
            mp42 = Buffer.concat([mp42, d]);
          }).on("error", (e) => {
            clearTimeout(tm);
            rej(e);
          }).on("end", () => {
            clearTimeout(tm);
            res(mp42);
          });
        });
        const mp4Path = path.join(tmpDir, "video.mp4");
        await fs.promises.writeFile(mp4Path, mp4);
        await testInfo.attach("video.mp4", {
          path: mp4Path,
          contentType: "video/mp4"
        });
      } catch (e) {
        logger.error(
          `Failed to attach video.mp4`,
          e instanceof Error ? e.message : void 0
        );
      }
    };
    const saveSDKLogs = async () => {
      if (!logger.logHistory.length) {
        return;
      }
      try {
        const content = `${logger.logHistory.map(
          (log) => `[${log.method}] ${JSON.stringify(log.data).slice(
            2,
            -2
          )}`
        ).join("\n")}`;
        const logsPath = path.join(tmpDir, "sdk-logs.txt");
        await fs.promises.writeFile(logsPath, content);
        await testInfo.attach("sdk-logs", {
          path: logsPath,
          contentType: "application/text"
        });
      } catch (e) {
        logger.error(`Failed to attach sdk-logs.txt`, e);
      }
    };
    const saveDebugLogs = async () => {
      const { debugLogs } = appetizePage2.sessionDebugInfo;
      if (debugLogs.length > 0) {
        try {
          const content = debugLogs.join("");
          const logsPath = path.join(tmpDir, "debug-logs.txt");
          await fs.promises.writeFile(logsPath, content);
          await testInfo.attach("debug-logs", {
            path: logsPath,
            contentType: "application/text"
          });
        } catch (e) {
          logger.error(`Failed to attach debug-logs.txt`, e);
        }
      }
    };
    const saveSession = async () => {
      try {
        if (appetizePage2.session) {
          const infoPath = path.join(tmpDir, "session.json");
          const content = JSON.stringify(
            {
              path: appetizePage2.session.path,
              token: appetizePage2.session.token,
              config: appetizePage2.session.config
            },
            null,
            2
          );
          await fs.promises.writeFile(infoPath, content);
          await testInfo.attach("session", {
            path: infoPath,
            contentType: "application/json"
          });
        }
      } catch (e) {
        logger.error(`Failed to attach session.json`, e);
      }
    };
    await Promise.all([
      saveScreenshot(),
      saveActions(),
      saveH264Video(),
      saveDebugLogs(),
      saveSession()
    ]);
    await saveSDKLogs();
  } finally {
    await removeTmpDir();
  }
}
function removeHiddenSteps(parent) {
  const steps = parent.steps || parent._steps;
  if (!steps) {
    return;
  }
  steps.forEach((step, i) => {
    if (step.title === "") {
      steps.splice(i, 1);
    }
    removeHiddenSteps(step);
  });
}
function isAppetize(testInfo) {
  return !!testInfo.project.use.config;
}
async function setupAppetizePage(context, config, baseURL) {
  if (!config.buildId) {
    throw new Error(
      'Appetize buildId not set. Make sure you have set it with `test.use({ config: { buildId: "..." } })` or in your Playwright config file.'
    );
  }
  const appetizePage2 = new AppetizePage({
    page: await context.newPage(),
    testFixture: test,
    config,
    baseURL
  });
  await appetizePage2.init();
  return appetizePage2;
}
async function setupSession(appetizePage2, config) {
  let session = appetizePage2.session;
  if (!session) {
    session = await test.step(
      "Start Appetize session",
      async () => {
        await appetizePage2.start({ config });
        if (appetizePage2.queueTime) {
          test.info().annotations.push({
            type: "queueTime",
            description: `${appetizePage2.queueTime}ms`
          });
        }
        if (!appetizePage2.session) {
          throw new Error("Appetize session failed to start");
        }
        return appetizePage2.session;
      },
      { box: true }
    );
    test.info().annotations.push({
      type: "Appetize Documentation",
      description: "https://docs.appetize.io/testing"
    });
  }
  session.testFixture = test;
  return session;
}
var internal = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
export { internal as InternalRecorderAPI, PlaywrightClient, PlaywrightSession, test };
//# sourceMappingURL=index.es.js.map
